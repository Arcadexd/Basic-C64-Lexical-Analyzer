{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f4\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Times;}
{\f5\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Helvetica;}{\f6\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier;}{\f7\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Geneva;}
{\f8\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset0\fprq2{\*\panose 00000000000000000000}MS Serif;}
{\f11\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\froman\fcharset0\fprq2{\*\panose 00000000000000000000}New York;}{\f13\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}System;}
{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}{\f15\froman\fcharset128\fprq1{\*\panose 00000000000000000000}Mincho{\*\falt ??};}{\f16\fnil\fcharset129\fprq1{\*\panose 00000000000000000000}Batang{\*\falt ??};}
{\f17\fnil\fcharset134\fprq2{\*\panose 00000000000000000000}SimSun{\*\falt ??};}{\f18\fnil\fcharset136\fprq2{\*\panose 00000000000000000000}PMingLiU{\*\falt ????};}{\f19\fmodern\fcharset128\fprq1{\*\panose 00000000000000000000}Gothic{\*\falt ?????};}
{\f20\fmodern\fcharset129\fprq1{\*\panose 00000000000000000000}Dotum{\*\falt ??};}{\f21\fmodern\fcharset134\fprq1{\*\panose 00000000000000000000}SimHei{\*\falt ??};}{\f22\fmodern\fcharset136\fprq1{\*\panose 00000000000000000000}MingLiU{\*\falt ???};}
{\f23\froman\fcharset128\fprq1{\*\panose 00000000000000000000}MS Mincho{\*\falt MS ??};}{\f24\froman\fcharset129\fprq1{\*\panose 00000000000000000000}Gulim{\*\falt ??};}
{\f25\fmodern\fcharset128\fprq1{\*\panose 00000000000000000000}MS Gothic{\*\falt MS ????};}{\f26\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Century;}{\f27\fswiss\fcharset0\fprq3{\*\panose 020b0604030504040204}Tahoma;}
{\f28\fscript\fcharset0\fprq2{\*\panose 030f0702030302020204}Comic Sans MS;}{\f29\fmodern\fcharset0\fprq1{\*\panose 020b0609020202020204}Monospac821 BT;}{\f30\froman\fcharset238\fprq2 Times New Roman CE;}
{\f31\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f33\froman\fcharset161\fprq2 Times New Roman Greek;}{\f34\froman\fcharset162\fprq2 Times New Roman Tur;}{\f35\froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\f36\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f37\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f38\fswiss\fcharset238\fprq2 Arial CE;}{\f39\fswiss\fcharset204\fprq2 Arial Cyr;}{\f41\fswiss\fcharset161\fprq2 Arial Greek;}
{\f42\fswiss\fcharset162\fprq2 Arial Tur;}{\f43\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f44\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f45\fswiss\fcharset186\fprq2 Arial Baltic;}{\f254\fscript\fcharset238\fprq2 Comic Sans MS CE;}
{\f255\fscript\fcharset204\fprq2 Comic Sans MS Cyr;}{\f257\fscript\fcharset161\fprq2 Comic Sans MS Greek;}{\f258\fscript\fcharset162\fprq2 Comic Sans MS Tur;}{\f261\fscript\fcharset186\fprq2 Comic Sans MS Baltic;}
{\f262\fmodern\fcharset238\fprq1 Monospac821 BT CE;}{\f265\fmodern\fcharset161\fprq1 Monospac821 BT Greek;}{\f266\fmodern\fcharset162\fprq1 Monospac821 BT Tur;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;
\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;
\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\f28\fs18\cf2\lang3082\langfe1033\cgrid\langnp3082\langfenp1033 \snext0 Normal;}{\*\cs10 \additive 
Default Paragraph Font;}{\s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\f29\fs20\lang3082\langfe1033\cgrid\langnp3082\langfenp1033 \sbasedon0 \snext15 Plain Text;}}{\*\revtbl {Unknown;}}{\info{\title   *********}{\author Windows98}
{\operator djtho0}{\creatim\yr2004\mo10\dy24\hr12\min21}{\revtim\yr2004\mo10\dy24\hr12\min21}{\version2}{\edmins0}{\nofpages55}{\nofwords138154}{\nofchars787481}{\*\company Windows98}{\nofcharsws967081}{\vern8203}}
\paperw11906\paperh16838\margl1152\margr1152\margt1417\margb1417 \deftab708\widowctrl\ftnbj\aenddoc\hyphhotz425\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\formshade\horzdoc\dghspace180\dgvspace180\dghorigin1701\dgvorigin1984\dghshow0\dgvshow0
\jexpand\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot\nolnhtadjtbl \fet0\sectd \linex0\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3
\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}
{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain 
\s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\f29\fs20\lang3082\langfe1033\cgrid\langnp3082\langfenp1033 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  *********
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Welcome to Project 64!
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The goal of Project 64 is to preserve Commodore 64 related documents
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in electronic text format that might otherwise cease to exist with the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  rapid advancement of computer technology and declining interest in 8-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  bit computers on the part of the general population. If you would like
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to help by converting C64 related hardcopy documents to electronic
\par   texts please contact the manager of Project 64, Cris Berneburg, at
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  <74171.2136@compuserve.com>.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Extensive efforts were made to preserve the contents of the original
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  document.  However, certain portions, such as diagrams, program
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  listings, and indexes may have been either altered or sacrificed due
\par   to the limitations of plain vanilla text.  Diagrams may have been
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  eliminated where ASCII-art was not feasible.  Program listings may be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  missing display codes where substitutions were not possible.  Tables
\par   of contents and indexes may have been changed from page number
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  references to section number references. Please accept our apologies
\par   for these limitations, alterations, and possible omissions.
\par 
\par     The author(s) of the original document and members of Project 64 make
\par   no representations about the accuracy or suitability of this material
\par   for any purpose.  This etext is provided "as-is".  Please refer to the
\par   warantee of the original document, if any, that may included in this
\par   etext.  No other warantees, express or implied, are made to you as to
\par   the etext or any medium it may be on.  Neither the author(s) nor the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  members of Project 64 will assume liability for damages either from
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the direct or indirect use of this etext or from the distribution of
\par   or modification to this etext.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  *********
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The Project 64 etext of the Commodore 64 Programmer's Reference Guide,
\par   first edition. Converted to etext by Ville Muikkula. Some errors in
\par   the original document were corrected in this etext.
\par 
\par   C64PRG10.TXT, June 1996, etext #46
\par 
\par   *********
\par 
\par 
\par 
\par 
\par \page 
\par 
\par 
\par   I would like to thank the following persons for their valuable help:
\par 
\par     Jouko Valta for the memory maps on pages 310-334.
\par     Marko Makela for the combined table of memory maps on pages 264-266.
\par     Cris Berneburg for proof reading.
\par     Kimmo Hamalainen for proof reading.
\par 
\par 
\par     There was a lot of work, but finally, after five weeks of correcting
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  OCR-errors and formatting the text to readable format, it is ready. I
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  hope that this massive project shows to the C= community that it is in
\par   a fact possible for one man to convert a 500 page book to ASCII text.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  One just have to be dedicated, believe that it can be done and have
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the PATIENCE for it... and lots of free time. So, who's going to etext
\par   Inside Commodore DOS?
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    If you find errors in the text, please report them so that they can
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  be fixed. There should not be many, though...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    There are some pictures missing on pages 132,157,162-163,195,364-365,
\par   377-378,380-381,404,406-407,416-417,421,459,476-477 and 481. Also the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  schematics of C-64 are not available. I apologize for the possible
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  inconvenience this might cause.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Ville Muikkula <vmuikku@yrttis.ratol.fi> or <vmuikku@raahenet.ratol.fi>.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   *********
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Note: To extract the ascii text basic programs all at once from this
\par   etext use "tok64" by Cris Berneburg <74171.2136@compuserve.com>.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  *********
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Windows 95 MS-DOS Edit is the ideal program for reading this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  etext.  Just check that ANSI.SYS is loaded in CONFIG.SYS and issue
\par   the command:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    mode con lines=50
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Now a whole page fits nicely on the screen and you can use Page Up/Page
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Down keys to flip pages. Just be sure that the ~ characters are always
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  on the last line of the screen.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  *********
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                 COMMODORE 64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                PROGRAMMER'S
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                               REFERENCE GUIDE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                Published by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      Commodore Business Machines, Inc.
\par                                      and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          Howard W. Sams & Co., Inc.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                       i
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FIRST EDITION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FOURTH PRINTING-1983
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Copyright (C) 1982 by Commodore Business Machines, Inc.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  All rights reserved.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  This manual is copyrighted and contains proprietary information. No part
\par   of this publication may be reproduced, stored in a retrieval system, or
\par   transmitted in any form or by any means, electronic, mechanical, photo-
\par   copying, recording, or otherwise, without the prior written permission
\par   of COMMODORE BUSINESS MACHINES, Inc.
\par 
\par                                      ii
\par \page 
\par 
\par 
\par 
\par 
\par 
\par 
\par   TABLE OF CONTENTS
\par 
\par 
\par   INTRODUCTION .......................................................   ix
\par      o What's Included? ..............................................    x
\par      o How to Use This Reference Guide ...............................   xi
\par      o Commodore 64 Applications Guide ...............................  xii
\par      o Commodore Information Network ................................. xvii
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  1. BASIC PROGRAMMING RULES .........................................    1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     o Introduction ..................................................    2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     o Screen Display Codes (BASIC Character Set) ....................    2
\par          The Operating System (OS) ...................................    2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     o Programming Numbers and Variables .............................    4
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Integer, Floating-Point and String Constants ................    4
\par          Integer, Floating-Point and String Variables ................    7
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Integer, Floating-Point and String Arrays ...................    8
\par      o Expressions and Operators .....................................    9
\par          Arithmetic Expressions ......................................   10
\par          Arithmetic Operations .......................................   10
\par          Relational Operators ........................................   12
\par          Logical Operators ...........................................   13
\par          Hierarchy of Operations .....................................   15
\par          String Operations ...........................................   16
\par          String Expressions ..........................................   17
\par      o Programming Techniques ........................................   18
\par          Data Conversions ............................................   18
\par          Using the INPUT Statement ...................................   18
\par          Using the GET Statement .....................................   22
\par          How to Crunch BASIC Programs ................................   24
\par 
\par   2. BASIC LANGUAGE VOCABULARY .......................................   29
\par      o Introduction ..................................................   30
\par      o BASIC Keywords, Abbreviations, and Function Types .............   31
\par      o Description of BASIC Keywords (Alphabetical) ..................   35
\par      o The Commodore 64 Keyboard and Features ........................   93
\par      o Screen Editor .................................................   94
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     iii
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   3. PROGRAMMING GRAPHICS ON THE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     COMMODORE 64 ....................................................   99
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     o Graphics Overview .............................................  100
\par          Character Display Modes .....................................  100
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Bit Map Modes ...............................................  100
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Sprites .....................................................  100
\par      o Graphics locations ............................................  101
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Video Bank Selection ........................................  101
\par          Screen Memory ...............................................  102
\par          Color Memory ................................................  103
\par          Character Memory ............................................  103
\par      o Standard Character Mode .......................................  107
\par          Character Definitions .......................................  107
\par      o Programmable Characters .......................................  108
\par      o Multi-Color Mode Graphics .....................................  115
\par          Multi-Color Mode Bit ........................................  115
\par      o Extended Background Color Mode ................................  120
\par      o Bit Mapped Graphics ...........................................  121
\par          Standard High-Resolution Bit Map Mode .......................  122
\par          How It Works ................................................  122
\par      o Multi-Color Bit Map Mode ......................................  127
\par      o Smooth Scrolling ..............................................  128
\par      o Sprites .......................................................  131
\par          Defining a Sprite ...........................................  131
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Sprite Pointers .............................................  133
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Turning Sprites On ..........................................  134
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Turning Sprites Off .........................................  135
\par          Colors ......................................................  135
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Multi-Color Mode ............................................  135
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Setting a Sprite to Multi-Color Mode ........................  136
\par          Expanded Sprites ............................................  136
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Sprite Positioning ..........................................  137
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Sprite Positioning Summary ..................................  143
\par          Sprite Display Priorities ...................................  144
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Collision Detects ...........................................  144
\par      o Other Graphics Features .......................................  150
\par          Screen Blanking .............................................  150
\par          Raster Register .............................................  150
\par          Interrupt Status Register ...................................  151
\par          Suggested Screen and Character Color Combinations ...........  152
\par 
\par 
\par 
\par                                      iv
\par \page 
\par 
\par 
\par      o Programming Sprites-Another Look ..............................  153
\par          Making Sprites in BASIC-A Short Program .....................  153
\par          Crunching Your Sprite Programs ..............................  156
\par          Positioning Sprites on the Screen ...........................  157
\par          Sprite Priorities ...........................................  161
\par          Drawing a Sprite ............................................  162
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Creating a Sprite ... Step by Step ..........................  163
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Moving Your Sprite on the Screen ............................  165
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Vertical Scrolling ..........................................  166
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         The Dancing Mouse-A Sprite Program Example ..................  166
\par          Easy Spritemaking Chart .....................................  176
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Spritemaking Notes ..........................................  177
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   4. PROGRAMMING SOUND AND MUSIC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     ON YOUR COMMODORE 64 ............................................  183
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     o Introduction ..................................................  184
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Volume Control ..............................................  186
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Frequencies of Sound Waves ..................................  186
\par      o Using Multiple Voices .........................................  187
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Controlling Multiple Voices .................................  191
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     o Changing Waveforms ............................................  192
\par          Understanding Waveforms .....................................  194
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     o The Envelope Generator ........................................  196
\par      o Filtering .....................................................  199
\par      o Advanced Techniques ...........................................  202
\par      o Synchronization and Ring Modulation ...........................  207
\par 
\par   5. BASIC TO MACHINE LANGUAGE .......................................  209
\par      o What is Machine Language? .....................................  210
\par          What Does Machine Code Look Like? ...........................  211
\par          Simple Memory Map of the Commodore 64 .......................  212
\par          The Registers Inside the 6510 Microprocessor ................  213
\par      o How Do You Write Machine Language Programs? ...................  214
\par          64MON .......................................................  215
\par      o Hexadecimal Notation ..........................................  215
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Your First Machine Language Instruction .....................  218
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Writing Your First Program ..................................  220
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     o Addressing Modes ..............................................  221
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Zero Page ...................................................  221
\par          The Stack ...................................................  222
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      v
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     o Indexing ......................................................  223
\par          Indirect Indexed ............................................  223
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Indexed Indirect ............................................  224
\par          Branches and Testing ........................................  226
\par      o Subroutines ...................................................  228
\par      o Useful Tips for the Beginner ..................................  229
\par      o Approaching a Large Task ......................................  230
\par      o MCS6510 Microprocessor Instruction Set-
\par        Alphabetic Sequence ...........................................  232
\par          Instruction Addressing Modes and
\par            Related Execution Times ...................................  254
\par      o Memory Management on the Commodore 64 .........................  260
\par      o The KERNAL ....................................................  268
\par      o KERNAL Power-Up Activities ....................................  269
\par          How to Use the KERNAL .......................................  270
\par          User Callable KERNAL Routines ...............................  272
\par          Error Codes .................................................  306
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     o Using Machine Language From BASIC .............................  307
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Where to Put Machine Language Routines ......................  309
\par          How to Enter Machine language ...............................  309
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     o Commodore 64 Memory Map .......................................  310
\par          Commodore 64 Input/Output Assignments .......................  320
\par 
\par   6. INPUT/OUTPUT GUIDE ..............................................  335
\par      o Introduction ..................................................  336
\par      o Output to the TV ..............................................  336
\par      o Output to Other Devices .......................................  337
\par          Output to Printer ...........................................  338
\par          Output to Modem .............................................  339
\par          Working With Cassette Tape ..................................  340
\par          Data Storage on Floppy Diskettes ............................  342
\par      o The Game Ports ................................................  343
\par          Paddles .....................................................  346
\par          Light Pen ...................................................  348
\par      o RS-232 Interface Description ..................................  348
\par         General Outline ..............................................  348
\par         Opening an RS-232 Channel ....................................  349
\par         Getting Data From an RS-232 Channel ..........................  352
\par         Sending Data to an RS-232 Channel ............................  353
\par         Closing an RS-232 Data Channel ...............................  354
\par         Sample BASIC Programs ........................................  356
\par 
\par 
\par                                      vi
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        Receiver/Transmitter Buffer Base Location Pointers ...........  357
\par         Zero-Page Memory Locations and Usage
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          for RS-232 System Interface ................................  358
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        Nonzero-Page Memory Locations and Usage
\par           for RS-232 System Interface ................................  358
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     o The User Port .................................................  359
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Port Pin Description ........................................  359
\par      o The Serial Bus ................................................  362
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Serial Bus Pinouts ..........................................  363
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     o The Expansion Port ............................................  366
\par      o Z-80 Microprocessor Cartridge .................................  368
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Using Commodore CP/M (R) ....................................  369
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Running Commodore CP/M (R) ..................................  369
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  APPENDICES .........................................................  373
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     A.  Abbreviations for BASIC Keywords ............................  374
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     B.  Screen Display Codes ........................................  376
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     C.  ASCII and CHR$ Codes ........................................  379
\par      D.  Screen and Color Memory Maps ................................  382
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     E.  Music Note Values ...........................................  384
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     F.  Bibliography ................................................  388
\par      G.  VIC Chip Register Map .......................................  391
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     H.  Deriving Mathematical Functions .............................  394
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     I.  Pinouts for Input/Output Devices ............................  395
\par      J.  Converting Standard BASIC Programs to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           Commodore 64 BASIC ........................................  398
\par      K.  Error Messages ..............................................  400
\par      L.  6510 Microprocessor Chip Specifications .....................  402
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     M.  6526 Complex Interface Adapter (CIA)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           Chip Specifications .......................................  419
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     N.  6566/6567 (VIC-II) Chip Specifications ......................  436
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     0.  6581 Sound Interface Device (SID) Chip Specifications .......  457
\par      P.  Glossary ....................................................  482
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INDEX ..............................................................  483
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  COMMODORE 64 QUICK REFERENCE CARD ..................................  487
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SCHEMATIC DIAGRAM OF THE COMMODORE 64 ..............................  491
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     vii
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INTRODUCTION
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The COMMODORE 64 PROGRAMMER'S REFERENCE GUIDE has been developed as a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  working tool and reference source for those of you who want to maximize
\par   your use of the built-in capabilities of your COMMODORE 64. This manual
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  contains the information you need for your programs, from the simplest
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  example all the way to the most complex. The PROGRAMMER'S REFERENCE GUIDE
\par   is designed so that everyone from the beginning BASIC programmer to the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  professional experienced in 6502 machine language can get information to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  develop his or her own creative programs. At the same time this book
\par   shows you how clever your COMMODORE 64 really is.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This REFERENCE GUIDE is not designed to teach the BASIC programming
\par   language or the 6502 machine language. There is, however, an extensive
\par   glossary of terms and a "semi-tutorial" approach to many of the sections
\par   in the book. If you don't already have a working knowledge of BASIC and
\par   how to use it to program, we suggest that you study the COMMODORE 64
\par   USER'S GUIDE that came with your computer. The USER'S GUIDE gives you an
\par   easy to read introduction to the BASIC programming language. If you still
\par   have difficulty understanding how to use BASIC then turn to the back of
\par   this book (or Appendix N in the USER'S GUIDE) and check out the
\par   Bibliography.
\par     The COMMODORE 64 PROGRAMMER'S REFERENCE GUIDE is just that; a
\par   reference. Like most reference books, your ability to apply the
\par   information creatively really depends on how much knowledge you have
\par   about the subject. In other words if you are a novice programmer you will
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  not be able to use all the facts and figures in this book until you
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  expand your current programming knowledge.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     ix
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    What you can do with this book is to find a considerable amount of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  valuable programming reference information written in easy to read,
\par   plain English with the programmer's jargon explained. On the other hand
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the programming professional will find all the information needed to use
\par   the capabilities of the COMMODORE 64 effectively.
\par 
\par   WHAT'S INCLUDED?
\par 
\par     o Our complete "BASIC dictionary" includes Commodore BASIC language
\par       commands, statements and functions listed in alphabetical order.
\par       We've created a "quick list" which contains all the words and their
\par       abbreviations. This is followed by a section containing a more
\par       detailed definition of each word along with sample BASIC programs
\par       to illustrate how they work.
\par     o If you need an introduction to using machine language with BASIC
\par       programs our layman's overview will get you started.
\par     o A powerful feature of all Commodore computers is called the KERNAL.
\par       It helps insure that the programs you write today can also be used
\par       on your Commodore computer of tomorrow.
\par     o The Input/Output Programming section gives you the opportunity to
\par       use your computer to the limit. It describes how to hook-up and use
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      everything from lightpens and joysticks to disk drives, printers,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      and telecommunication devices called modems.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    o You can explore the world of SPRITES, programmable characters, and
\par       high resolution graphics for the most detailed and advanced animated
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      pictures in the microcomputer industry.
\par     o You can also enter the world of music synthesis and create your own
\par       songs and sound effects with the best built-in synthesizer available
\par       in any personal computer.
\par     o If you're an experienced programmer, the soft load language section
\par       gives you information about the COMMODORE 64's ability to run CP/M*
\par       and high level languages. This is in addition to BASIC.
\par 
\par     Think of your COMMODORE 64 PROGRAMMER'S REFERENCE GUIDE as a useful
\par   tool to help you and you will enjoy the -hours of programming ahead
\par   of you.
\par 
\par 
\par 
\par 
\par   -----------
\par   * CP/M is a registered trademark of Digital Research, Inc.
\par 
\par   x   INTRODUCTION
\par \page 
\par 
\par 
\par   HOW TO USE THIS REFERENCE GUIDE
\par 
\par     Throughout this manual certain conventional notations are used to de-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  scribe the syntax (programming sentence structure) of BASIC commands or
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  statements and to show both the required and optional parts of each BASIC
\par   keyword. The rules to use for interpreting statement syntax are as
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  follows:
\par 
\par     1. BASIC keywords are shown in capital letters. They must appear where
\par        shown in the statement, entered and spelled exactly as shown.
\par     2. Items shown within quotation marks (" ") indicate variable data
\par        which you must put in. Both the quotation marks and the data inside
\par        the quotes must appear where shown in each statement.
\par     3. Items inside the square brackets ([ ]) indicate an optional state-
\par        ment parameter. A parameter is a limitation or additional qualifier
\par        for your statements. If you use an optional parameter you must
\par        supply the data for that optional parameter. In addition, ellipses
\par        (...) show that an optional item can be repeated as many times as
\par        a programming line allows.
\par     4. If an item in the square brackets ([ ]) is UNDERLINED, that means
\par        that you MUST use those certain characters in the optional para-
\par        meters, and they also have to be spelled exactly as shown.
\par     5. Items inside angle brackets (< >) indicate variable data which you
\par        provide. While the slash (/) indicates that you must make a choice
\par        between two mutually exclusive options.
\par 
\par   EXAMPLE OF SYNTAX FORMAT:
\par 
\par     OPEN <file-num>,<device>[,<address>],["<drive>:<filename>][,<mode>]"
\par 
\par   EXAMPLES OF ACTUAL STATEMENTS:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 OPEN 2,8,6,"0:STOCK FOLIO,S,W"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 OPEN 1,1,2,"CHECKBOOK"
\par     30 OPEN 3,4
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When you actually apply the syntax conventions in a practical situa-
\par   tion, the sequence of parameters in your statements might not be exactly
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the same as the sequence shown in syntax examples. The examples are not
\par   meant to show every possible sequence. They are intended to present all
\par   required and optional parameters.
\par 
\par 
\par                                                           INTRODUCTION   xi
\par \page 
\par 
\par 
\par     Programming examples in this book are shown with blanks separating
\par   words and operators for the sake of readability. Normally though, BASIC
\par   doesn't require blanks between words unless leaving them out would give
\par   you an ambiguous or incorrect syntax.
\par     Shown below are some examples and descriptions of the symbols used for
\par   various statement parameters in the following chapters. The list is not
\par   meant to show every possibility, but to give you a better understanding
\par   as to how syntax examples are presented.
\par 
\par     SYMBOL        EXAMPLE                 DESCRIPTION
\par   <file-num>        50              A logical file number
\par   <device>          4               A hardware device number
\par   <address>         15              A serial bus secondary
\par                                     device address number
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  <drive>           0               A physical disk drive number
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  <file-name>       "TEST.DATA"     The name of a data or program file
\par   <constant>        "ABCDEFG"       Literal data supplied by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                    the programmer
\par   <variable>        X145            Any BASIC data variable name or
\par                                     constant
\par   <string>          AB$             Use of a string type variable required
\par   <number>          12345           Use of a numeric type variable
\par                                     required
\par   <line-number>     1000            An actual program line number
\par   <numeric>         1.5E4           An integer or floating-point variable
\par 
\par 
\par   COMMODORE 64 APPLICATIONS GUIDE
\par 
\par     When you first thought about buying a computer you probably asked
\par   yourself, "Now that I can afford to buy a computer, what can I do with
\par   it once I get one?"
\par     The great thing about your COMMODORE 64 is that you can make it do what
\par   YOU want it to do! You can make it calculate and keep track of home and
\par   business budget needs. You can use it for word processing. You can make
\par   it play arcade-style action games. You can make it sing. You can even
\par   create your own animated cartoons, and more. The best part of owning a
\par   COMMODORE 64 is that even if it did only one of the things listed below
\par   it would be well worth the price you paid for it. But the 64 is a
\par   complete computer and it does do EVERYTHING listed and then some!
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  xii   INTRODUCTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    By the way, in addition to everything here you can pick up a lot of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  other creative and practical ideas by signing up with a local Commodore
\par   Users' Club, subscribing to the COMMODORE and POWER/PLAY magazines, and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  joining the COMMODORE INFORMATION NETWORK on CompuServe(TM)
\par 
\par       APPLICATION               COMMENTS/REQUIREMENTS
\par 
\par   ACTION PACKED           You can get real Bally Midway arcade games GAMES
\par                           like Omega Race, Gorf and Wizard of War, as well
\par                           as "play and learn" games like Math Teacher 1,
\par                           Home Babysitter and Commodore Artist.
\par 
\par   ADVERTISING &           Hook your COMMODORE 64 to a TV, put it in
\par   MERCHANDISING           a store window with a flashing, animated, and
\par                           musical message and you've got a great point of
\par                           purchase store display.
\par 
\par   ANIMATION               Commodore's Sprite Graphics allow you to create
\par                           real cartoons with 8 different levels so that
\par                           shapes can move in front of or behind each
\par                           other.
\par 
\par   BABYSITTING             The COMMODORE 64 HOME BABYSITTER cartridge can
\par                           keep your youngest child occupied for hours and
\par                           teach alphabet/ keyboard recognition at the same
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          time. It also teaches special learning concepts
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          and relationships.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BASIC PROGRAMMING       Your COMMODORE 64 USER'S GUIDE and the TEACH
\par                           YOURSELF PROGRAMMING series of books and tapes
\par                           offer an excellent starting point.
\par 
\par   BUSINESS                The COMMODORE 64 offers the "Easy" series
\par   SPREADSHEET             of business aids including the most powerful
\par                           word processor and largest spreadsheet
\par                           available for any personal computer.
\par 
\par   COMMUNICATION           Enter the fascinating world of computer "net-
\par                           working." If you hook a VICMODEM to your
\par                           COMMODORE 64 you can communicate with other
\par                           computer owners all around the world.
\par 
\par 
\par                                                         INTRODUCTION   xiii
\par \page 
\par 
\par 
\par                           Not only that, if you join the COMMODORE
\par                           INFORMATION NETWORK on CompuServe(TM) you can
\par                           get the latest news and updates on all Commodore
\par                           products, financial information, shop at home
\par                           services, you can even play games with the
\par                           friends you make through the information systems
\par                           you join.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  COMPOSING SONGS         The COMMODORE 64 is equipped with the most
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          sophisticated built-in music synthesizer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          available on any computer. It has three com-
\par                           pletely programmable voices, nine full music
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          octaves, and four controllable waveforms.
\par                           Look for Commodore Music Cartridges and
\par                           Commodore Music books to help you create or
\par                           reproduce all kinds of music and sound effects.
\par 
\par   CP/M*                   Commodore offers a CP/M* add-on and access to
\par                           software through an easy-to-load cartridge.
\par 
\par   DEXTERITY TRAINING      Hand/Eye coordination and manual dexterity
\par                           are aided by several Commodore games...
\par                           including "Jupiter lander" and night driving
\par                           simulation.
\par 
\par   EDUCATION               While working with a computer is an education in
\par                           itself, The COMMODORE Educational Resource Book
\par                           contains general information on the educational
\par                           uses of computers. We also have a variety of
\par                           learning cartridges designed to teach everything
\par                           from music to math and art to astronomy.
\par 
\par   FOREIGN LANGUAGE        The COMMODORE 64 programmable character set
\par                           lets you replace the standard character set
\par                           with user defined foreign language characters.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  GRAPHICS AND ART        In addition to the Sprite Graphics mentioned
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          above, the COMMODORE 64 offers high-resolution,
\par                           multi-color graphics plotting, programmable
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -----------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  * CP/M is a Registered trademark of Digital Research, Inc.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   xiv   INTRODUCTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          characters, and combinations of all the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          different graphics and character display modes.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INSTRUMENT              Your COMMODORE 64 has a serial port, RS-232 port
\par   CONTROL                 and a user port for use with a variety of special
\par                           industrial applications. An IEEE/488 cartridge is
\par                           also available as an optional extra.
\par 
\par   JOURNALS AND            The COMMODORE 64 will soon offer an exceptional
\par   CREATIVE WRITING        wordprocessing system that matches or exceeds
\par                           the qualities and flexibilities of most "high-
\par                           priced" wordprocessors available. Of course you
\par                           can save the information on either a 1541 Disk
\par                           Drive or a Datassette TM recorder and have it
\par                           printed out using a VIC-PRINTER or PLOTTER.
\par 
\par   LIGHTPEN CONTROL        Applications requiring the use of a lightpen
\par                           can be performed by any lightpen that will fit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          the COMMODORE 64 game port connector.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   MACHINE CODE            Your COMMODORE 64 PROGRAMMER'S REFERENCE GUIDE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PROGRAMMING             includes a machine language section, as well as
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          a BASIC to machine code interface section.
\par                           There's even a bibliography available for more
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          in-depth study.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   PAYROLL & FORMS         The COMMODORE 64 can be programmed to handle
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PRINTOUT                a variety of entry-type business applications.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          Upper/lower case letters combined with C64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          "business form" graphics make it easy for you
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          to design forms which can then be printed on
\par                           your printer.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PRINTING                The COMMODORE 64 interfaces with a variety of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          dot matrix and letter quality printers as well
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          as plotters.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RECIPES                 You can store your favorite recipes on your
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          COMMODORE 64 and its disk or cassette storage
\par                           unit, and end the need for messy recipe cards
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          that often get lost when you need them most.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                          INTRODUCTION   xv
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SIMULATIONS             Computer simulations let you conduct dangerous
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          or expensive experiments at minimum risk and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          cost.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SPORTS DATA             The Source (TM) and CompuServe (TM) both offer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          sports information which you can get using
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          your COMMODORE 64 and a VICMODEM.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   STOCK QUOTES            With a VICMODEM and a subscription to any of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          appropriate network services, your COMMODORE 64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          becomes your own private stock ticker.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    These are just a few of the many applications for you and your
\par   COMMODORE 64. As you can see, for work or play, at home, in school
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  or the office, your COMMODORE 64 gives you a practical solution for
\par   just about any need.
\par     Commodore wants you to know that our support for users only STARTS
\par   with your purchase of a Commodore computer. That's why we've created
\par   two publications with Commodore information from around the world, and
\par   a "two-way" computer information network with valuable input for users
\par   in the U.S. and Canada from coast to coast.
\par     In addition, we wholeheartedly encourage and support the growth of
\par   Commodore Users' Clubs around the world. They are an excellent source
\par   of information for every Commodore computer owner from the beginner
\par   to the most advanced. The magazines and network, which are more fully
\par   described below, have the most up-to-date information about how to get
\par   involved with the Users' Club in your area.
\par     Finally, your local Commodore dealer is a useful source of Commodore
\par   support and information.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  POWER/PLAY
\par   The Home Computer Magazine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When it comes to entertainment, learning at home and practical home
\par   applications, POWER/PLAY is THE prime source of information for Com-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  modore home users. Find out where your nearest user clubs are and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  what they're doing, learn about software, games, programming techniques,
\par   telecommunications, and new products. POWER/PLAY is your personal
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  connection to other Commodore users, outside software and hardware
\par   developers, and to Commodore itself. Published quarterly. Only $10.00
\par   for a year of home computing excitement.
\par 
\par 
\par   xvi   INTRODUCTION
\par \page 
\par 
\par 
\par   COMMODORE
\par   The Microcomputer Magazine
\par 
\par     Widely read by educators, businessmen and students, as well as home
\par   computerists, COMMODORE Magazine is our main vehicle for sharing
\par   exclusive information on the more technical use of Commodore systems.
\par   Regular departments cover business, science and education, programming
\par   tips, "excerpts from a technical notebook," and many other features of
\par   interest to anyone who uses or is thinking about purchasing Commodore
\par   equipment for business, scientific or educational applications.
\par   COMMODORE is the ideal complement to POWER/PLAY. Published bimonthly.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Subscription price: $15.00 per year.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   AND FOR EVEN MORE INFORMATION...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ...DIAL UP OUR PAPERLESS USER MAGAZINE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   COMMODORE INFORMATION NETWORK
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The magazine of the future is here. To supplement and enhance your
\par   subscription to POWER/PLAY and COMMODORE magazines, the COMMODORE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INFORMATION NETWORK - our "paperless magazine" - is available now over
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the telephone using your Commodore computer and modem.
\par     Join our computer club, get help with a computing problem, "talk" to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  other Commodore friends, or get up-to-the-minute information on new
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  products, software and educational resources. Soon you will even be
\par   able to save yourself the trouble of typing in the program listings you
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  find in POWER/PLAY or COMMODORE by downloading direct from the
\par   Information Network (a new user service planned for early 1983). The
\par   best part is that most of the answers are there before you even ask the
\par   questions. (How's that for service?)
\par     To call our electronic magazine you need only a modem and a sub-
\par   scription to CompuServe TM, one of the nation's largest telecommunica-
\par   tions networks. (To make it easy for you Commodore includes a FREE year's
\par   subscription to CompuServe TM in each VICMODEM package.) Just dial your
\par   local number for the CompuServe (TM) data bank and connect your phone to
\par   the modem. When the CompuServe (TM) video text appears on your screen
\par   type G CBM on your computer keyboard. When the COMMODORE INFORMATION
\par   NETWORK'S table of contents, or "menu," appears on your screen choose
\par   from one of our sixteen departments, make yourself comfortable, and enjoy
\par   the paperless magazine other magazines are writing about.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        INTRODUCTION   xvii
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    For more information, visit your Commodore dealer or contact Com-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  puserve(TM) customer service at 800-848-8990 (in Ohio, 614-457-8600).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                         COMMODORE INFORMATION NETWORK
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------+-----------------------------------+
\par   |  Main Menu Description            |  Commodore Dealers                |
\par   |  Direct Access Codes              |  Educational Resources            |
\par   |  Special Commands                 |  User Groups                      |
\par   |  User Questions                   |  Descriptions                     |
\par   |  Public Bulletin Board            |  Questions and Answers            |
\par   |  Magazines and Newsletters        |  Software Tips                    |
\par   |  Products Announced               |  Technical Tips                   |
\par   |  Commodore News Direct            |  Directory Descriptions           |
\par   +-----------------------------------+-----------------------------------+
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  xviii   INTRODUCTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 CHAPTER 1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                     BASIC
\par                                                PROGRAMMING
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                     RULES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Introduction
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Screen Display Codes (BASIC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                             Character Set)
\par                            o Programming Numbers and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                             variables
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Expressions and Operators
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Programming Techniques
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      1
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   INTRODUCTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This chapter talks about how BASIC stores and manipulates data. The
\par   topics include:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) A brief mention of the operating system components and functions
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       as well as the character set used in the Commodore 64.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) The formation of constants and variables. What types of variables
\par        there are. And how constants and variables are stored in memory.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) The rules for arithmetic calculations, relationship tests, string
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       handling, and logical operations. Also included are the rules for
\par        forming expressions, and the data conversions necessary when you're
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       using BASIC with mixed data types.
\par 
\par   SCREEN DISPLAY CODES (BASIC CHARACTER SET)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  THE OPERATING SYSTEM (OS)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The Operating System is contained in the Read Only Memory (ROM) chips
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and is a combination of three separate, but interrelated, program
\par   modules.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) The BASIC Interpreter
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) The KERNAL
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) The Screen Editor
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) The BASIC Interpreter is responsible for analysing BASIC statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       syntax and for performing the required calculations and/or data
\par        manipulation. The BASIC Interpreter has a vocabulary of 65
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       "keywords" which have special meanings. The upper and lower case
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       alphabet and the digits 0-9 are used to make both keywords and
\par        variable names. Certain punctuation characters and special symbols
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       also have meanings for the Interpreter. Table 1-1 lists the special
\par        characters and their uses.
\par     2) The KERNAL handles most of the interrupt level processing in the
\par        system (for details on interrupt level processing, see Chapter 5).
\par        The KERNAL also does the actual input and output of data.
\par     3) The Screen Editor controls the output to the video screen (tele-
\par        vision set) and the editing of BASIC program text. In addition, the
\par        Screen Editor intercepts keyboard input so that it can decide
\par        whether the characters put in should be acted upon immediately, or
\par        passed on to the BASIC Interpreter.
\par 
\par   2  BASIC PROGRAMMING RULES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    Table 1 - 1. CBM BASIC Character Set
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------------+---------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  CHARACTER  |                NAME and DESCRIPTION                     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------------+---------------------------------------------------------+
\par   |             | BLANK - separates keywords and variable names           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      ;      | SEMI-COLON - used in variable lists to format output    |
\par   |      =      | EQUAL SIGN - value assignment and relationship testing  |
\par   |      +      | PLUS SIGN - arithmetic addition or string concatenation |
\par   |             |            (concatenation: linking together in a chain) |
\par   |      -      | MINUS SIGN - arithmetic subtraction, unary minus        |
\par   |      *      | ASTERISK - arithmetic multiplication                    |
\par   |      /      | SLASH - arithmetic division                             |
\par   |      ^      | UP ARROW - arithmetic exponentiation                    |
\par   |      (      | LEFT PARENTHESIS - expression evaluation and functions  |
\par   |      )      | RIGHT PARENTHESIS - expression evaluation and functions |
\par   |      %      | PERCENT - declares variable name as an integer          |
\par   |      #      | NUMBER - comes before logical file number in input/     |
\par   |             |          output statements                              |
\par   |      $      | DOLLAR SIGN - declares variable name as a string        |
\par   |      ,      | COMMA - used in variable lists to format output; also   |
\par   |             |         separates command parameters                    |
\par   |      .      | PERIOD - decimal point in floating point constants      |
\par   |      "      | QUOTATION MARK - encloses string constants              |
\par   |      :      | COLON - separates multiple BASIC statements in a line   |
\par   |      ?      | QUESTION MARK - abbreviation for the keyword PRINT      |
\par   |      <      | LESS THAN - used in relationship tests                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      >      | GREATER THAN - used in relationship tests               |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     \{pi\}    | PI - the numeric constant 3.141592654                   |
\par   +-------------+---------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The Operating System gives you two modes of BASIC operation:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) DIRECT Mode
\par     2) PROGRAM Mode
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) When you're using the DIRECT mode, BASIC statements don't have
\par        line numbers in front of the statement. They are executed whenever
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       the <RETURN> key is pressed.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) The PROGRAM mode is the one you use for running programs.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                 BASIC PROGRAMMING RULES   3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       When using the PROGRAM mode, all of your BASIC statements must have
\par        line numbers in front of them. You can have more than one BASIC
\par        statement in a line of your program, but the number of statements is
\par        limited by the fact that you can only put 80 characters on a logical
\par        screen line. This means that if you are going to go over the 80
\par        character limit you have to put the entire BASIC statement that
\par        doesn't fit on a new line with a new line number.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         Always type NEW and hit <RETURN> before starting a new program.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The Commodore 64 has two complete character sets that you can use
\par   either from the keyboard or in your programs.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    In SET 1, the upper case alphabet and the numbers 0-9 are available
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  without pressing the <SHIFT> key. If you hold down the <SHIFT> key
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  while typing, the graphics characters on the RIGHT side of the front of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the keys are used. If you hold down the <C=> key while typing, the
\par   graphics characters on the LEFT side of the front of the key are used.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Holding down the <SHIFT> key while typing any character that doesn't
\par   have graphic symbols on the front of the key gives you the symbol on the
\par   top most part of the key.
\par     In SET 2, the lower case alphabet and the numbers 0-9 are available
\par   without pressing the <SHIFT> key. The upper case alphabet is available
\par   when you hold down the <SHIFT> key while typing. Again, the graphic
\par   symbols on the LEFT side of the front of the keys are displayed by press-
\par   ing the <C=> key, while the symbols on the top most part of any key
\par   without graphics characters are selected when you hold down the <SHIFT>
\par   key while typing.
\par     To switch from one character set to the other press the <C=> and
\par   the <SHIFT> keys together.
\par 
\par   PROGRAMMING NUMBERS AND VARIABLES
\par 
\par   INTEGER, FLOATING-POINT AND STRING CONSTANTS
\par 
\par     Constants are the data values that you put in your BASIC statements.
\par   BASIC uses these values to represent data during statement execution.
\par   CBM BASIC can recognize and manipulate three types of constants:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) INTEGER NUMBERS
\par     2) FLOATING-POINT NUMBERS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) STRINGS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  4   BASIC PROGRAMMING RULES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Integer constants are whole numbers (numbers without decimal points).
\par   Integer constants must be between -32768 and +32767. Integer constants
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  do not have decimal points or commas between digits. If the plus (+) sign
\par   is left out, the constant is assumed to be a positive number. Zeros
\par   coming before a constant are ignored and shouldn't be used since they
\par   waste memory and slow down your program. However, they won't cause an
\par   error. Integers are stored in memory as two-byte binary numbers. Some
\par   examples of integer constants are:
\par 
\par                                -12
\par                               8765
\par                             -32768
\par                                +44
\par                                  0
\par                             -32767
\par   +-----------------------------------------------------------------------+
\par   |  NOTE: Do NOT put commas inside any number. For example, always type  |
\par   |  32,000 as 32000. If you put a comma in the middle of a number you    |
\par   | will get the BASIC error message ?SYNTAX ERROR.                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Floating-point constants are positive or negative numbers and can
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  contain fractions. Fractional parts of a number may be shown using a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  decimal point. Once again remember that commas are NOT used between
\par   numbers. If the plus sign (+) is left off the front of a number, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Commodore 64 assumes that the number is positive. If you leave off the
\par   decimal point the computer will assume that it follows the last digit of
\par   the number. And as with integers, zeros that come before a constant
\par   are ignored. Floating-point constants can be used in two ways:
\par 
\par     1) SIMPLE NUMBER
\par     2) SCIENTIFIC NOTATION
\par 
\par     Floating-point constants will show you up to nine digits on your
\par   screen. These digits can represent values between -999999999. and
\par   +999999999. If you enter more than nine digits the number will be
\par   rounded based on the tenth digit. if the tenth digit is greater than or
\par   equal to 5 the number will be rounded upward. Less than 5 the number
\par   be rounded downward. This could be important to the final totals of
\par   some numbers you may want to work with.
\par     Floating-point numbers are stored (using five bytes of memory) and
\par   are manipulated in calculations with ten places of accuracy. However,
\par 
\par                                                 BASIC PROGRAMMING RULES   5
\par \page 
\par 
\par 
\par   the numbers are rounded to nine digits when results are printed. Some
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  examples of simple floating-point numbers are:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                   1.23                 .7777777
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                  -.998877         -333.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 +3.1459               .01
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Numbers smaller than .01 or larger than 999999999. will be printed in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  scientific notation. In scientific notation a floating-point constant is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  made up of three parts:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) THE MANTISSA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) THE LETTER E
\par     3) THE EXPONENT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The mantissa is a simple floating-point number. The letter E is used to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  tell you that you're seeing the number in exponential form. In other
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  words E represents * 10 (eg., 3E3 = 3*10^3 = 3000). And the exponent is
\par   what multiplication power of 10 the number is raised to.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Both the mantissa and the exponent are signed (+ or -) numbers. The
\par   exponent's range is from -39 to +38 and it indicates the number of places
\par   that the actual decimal point in the mantissa would be moved to the left
\par   (-) or right (+) if the value of the constant were represented as a
\par   simple number.
\par     There is a limit to the size of floating-point numbers that BASIC can
\par   handle, even in scientific notation: the largest number is
\par   +1.70141183E+38 and calculations which would result in a larger number
\par   will display the BASIC error message ?OVERFLOW ERROR. The smallest
\par   floating-point number is +2.93873588E-39 and calculations which result
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in a smaller value give you zero as an answer and NO error message. Some
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  examples of floating-point numbers in scientific notation (and their
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  decimal values) are:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par  \tab 235.988E-3\tab (.235988)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        2359E6          (2359000000.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        -7.09E-12       (-.00000000000709)
\par \tab -3.14159E+5\tab (-314159.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    String constants are groups of alphanumeric information like letters,
\par   numbers and symbols. When you enter a string from the keyboard, it
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  can have any length up to the space available in an 80-character line
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   6   BASIC PROGRAMMING RULES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (that is, any character spaces NOT taken up by the line number and other
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  required parts of the statement).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    A string constant can contain blanks, letters, numbers, punctuation
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and color or cursor control characters in any combination. You can even
\par   put commas between numbers. The only character which cannot be included
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in a string is the double quote mark ("). This is because the double
\par   quote mark is used to define the beginning and end of the string.
\par   A string can also have a null value-which means that it can contain no
\par   character data. You can leave the ending quote mark off of a string if
\par   it's the last item on a line or if it's followed by a colon (:). Some
\par   examples of string constants are:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               ""         ( a null string)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               "HELLO"
\par                "$25,000.00"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               "NUMBER OF EMPLOYEES"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  NOTE: Us CHR$(34) to include quotes (") in strings.                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INTEGER, FLOATING-POINT AND STRING VARIABLES
\par 
\par     Variables are names that represent data values used in your BASIC
\par   statements. The value represented by a variable can be assigned by
\par   setting it equal to a constant, or it can be the result of calculations
\par   in the program. Variable data, like constants, can be integers, floating-
\par   point numbers, or strings. If you refer to a variable name in a program
\par   before a value has been assigned, the BASIC Interpreter will auto-
\par   matically create the variable with a value of zero if it's an integer or
\par   floating-point number. Or it will create a variable with a null value if
\par   you're using strings.
\par     Variable names can be any length but only the first two characters are
\par   considered significant in CBM BASIC. This means that all names used for
\par   variables must NOT have the same first two characters. Variable names may
\par   NOT be the same as BASIC keywords and they may NOT contain keywords in
\par   the middle of variable names. Keywords include all BASIC commands, state-
\par   ments, function names and logical operator names. If you accidentally use
\par   a keyword in the middle of a variable name, the BASIC error message
\par   ?SYNTAX ERROR will show up on your screen.
\par     The characters used to form variable names are the alphabet and the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  numbers 0-9. The first character of the name must be a letter. Data
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                BASIC PROGRAMMING RULES   7
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   type declaration characters (%) and ($) can be used as the last char-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  acter of the name. The percent sign declares the variable to be an
\par   integer and the dollar sign ($) declares a string variable. If no type
\par   declaration character is used the Interpreter will assume that the vari-
\par   able is a floating-point. Some examples of variable names, value as-
\par   signments and data types are:
\par 
\par             A$="GROSS SALES"        (string variable)
\par             MTH$="JAN"+A$           (string variable)
\par             K%=5                    (integer variable)
\par             CNT%=CNT%+1             (integer variable)
\par             FP=12.5                 (floating-point variable)
\par             SUM=FP*CNT%             (floating-point variable)
\par 
\par 
\par   INTEGER, FLOATING-POINT AND STRING ARRAYS
\par 
\par     An array is a table (or list) of associated data items referred to by
\par   a single variable name. In other words, an array is a sequence of related
\par   variables. A table of numbers can be seen as an array, for example.
\par   The individual numbers within the table become "elements" of the array.
\par     Arrays are a useful shorthand way of describing a large number of
\par   related variables. Take a table of numbers for instance. Let's say that
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the table has 10 rows of numbers with 20 numbers in each row. That makes
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  total of 200 numbers in the table. Without a single array name to call
\par   on you would have to assign a unique name to each value in the table. But
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  because you can use arrays you only need one name for the array and all
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the elements in the array are identified by their individual locations
\par   within the array.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Array names can be integers, floating-points or string data types and
\par   all elements in the array have the same data type as the array name.
\par   Arrays can have a single dimension (as in a simple list) or they can have
\par   multiple dimensions (imagine a grid marked in rows and columns or a
\par   Rubik's Cube(R)). Each element of an array is uniquely identified and re-
\par   ferred to by a subscript (or index variable) following the array name,
\par   enclosed within parentheses ( ).
\par     The maximum number of dimensions an array can have in theory is 255
\par   and the number of elements in each dimension is limited to 32767. But
\par   for practical purposes array sizes are limited by the memory space
\par   available to hold their data and/or the 80 character logical screen line.
\par   If an array has only one dimension and its subscript value will never
\par 
\par 
\par   8   BASIC PROGRAMMING RULES
\par \page 
\par 
\par 
\par   exceed 1 0 (1 I items: 0 thru 1 0) then the array will be created by the
\par   Interpreter and filled with zeros (or nulls if string type) the first
\par   time any element of the array is referred to, otherwise the BASIC DIM
\par   statement must be used to define the shape and size of the array. The
\par   amount of memory required to store an array can be determined as follows:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                5 bytes for the array name
\par               + 2 bytes for each dimension of the array
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              + 2 bytes per element for integers
\par            OR + 5 bytes per element for floating-point
\par            OR + 3 bytes per  element for strings
\par           AND + 1 byte per character in each string element
\par 
\par     Subscripts can be integer constants, variables, or an arithmetic ex-
\par   pression which gives an integer result. Separate subscripts, with com-
\par   mas between them, are required for each dimension of an array. Sub-
\par   scripts can have values from zero up to the number of elements in the
\par   respective dimensions of the array. Values outside that range will cause
\par   the BASIC error message ?BAD SUBSCRIPT. Some examples of array names,
\par   value assignments and data types are:
\par 
\par         A$(0)="GROSS SALES"     (string array)
\par         MTH$(K%)="JAN"          (string array)
\par         G2%(X)=5                (integer array)
\par         CNT%(G2%(X))=CNT%(1)-2  (integer array)
\par         FP(12*K%)=24.8          (floating-point array)
\par         SUM(CNT%(1))=FP^K%      (floating-point array)
\par 
\par      A(5)=0     (sets the 5th element in the 1 dimensional
\par                  array called "A" equal to 0)
\par 
\par      B(5,6)=0   (sets the element in row position 5 and column position 6
\par                  in the 2 dimensional array called "B" equal to 0)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     C(1,2,3)=0 (sets the element in row position 1, column position 2,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 and depth position 3 in the 3 dimensional array called
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 "C" equal to 0)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXPRESSIONS AND OPERATORS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Expressions are formed using constants, variables and/or arrays. An
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  expression can be a single constant, simple variable, or an array vari-
\par 
\par                                                 BASIC PROGRAMMING RULES   9
\par \page 
\par 
\par 
\par   able of any type. It can also be a combination of constants and variables
\par   with arithmetic, relational or logical operators designed to produce a
\par   ingle value. How operators work is explained below. Expressions can be
\par   separated into two classes:
\par 
\par     1) ARITHMETIC
\par     2) STRING
\par 
\par     Expressions are normally thought of as having two or more data items
\par   called operands. Each operand is separated by a single operator to
\par   produce the desired result. This is usually done by assigning the value
\par   of the expression to a variable name. All of the examples of constants
\par   and variables that you've seen so for, were also examples of expressions.
\par     An operator is a special symbol the BASIC Interpreter in your Commodore
\par   64 recognizes as representing an operation to be performed on the
\par   variables or constant data. One or more operators, combined with one or
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  more variables and/or constants form an expression. Arithmetic,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  relational and logical operators are recognized by Commodore 64 BASIC.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   ARITHMETIC EXPRESSIONS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Arithmetic expressions, when solved, will give an integer or floating-
\par   point value. The arithmetic operators (+, -, *, /, ^) are used to perform
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  addition, subtraction, multiplication, division and exponentiation opera-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  tions respectively.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ARITHMETIC OPERATIONS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     An arithmetic operator defines an arithmetic operation which is per-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  formed on the two operands on either side of the operator. Arithmetic
\par   operations are performed using floating-point numbers. Integers are
\par   converted to floating-point numbers before an arithmetic operation is
\par   performed. The result is converted back to an integer if it is assigned
\par   to an integer variable name.
\par 
\par     ADDITION (+): The plus sign (+) specifies that the operand on the
\par   right is added to the operand on the left.
\par 
\par 
\par 
\par 
\par 
\par 
\par   10   BASIC PROGRAMMING RULES
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     EXAMPLES:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     2+2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     A+B+C
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     X%+1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     BR+10E-2
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    SUBTRACTION (-): The minus sign (-) specifies that the operand on the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  right is subtracted from the operand on the left.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    EXAMPLES:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     4-1
\par                      100-64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     A-B
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     55-142
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The minus can also be used as a unary minus. That means that it is the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  minus sign in front of a negative number. This is equal to subtracting
\par   the number from zero (0).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    EXAMPLES:
\par                      -5
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     -9E4
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     -B
\par                      4-(-2) same as 4+2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    MULTIPLICATION (*): An asterisk (*) specifies that the operand on the
\par   left is multiplied by the operand on the right.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    EXAMPLES:
\par                      100*2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     50*0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     A*X1
\par                      R%*14
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    DIVISION (/): The slash (/) specifies that the operand on the left is
\par   divided by the operand on the right.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    EXAMPLES:
\par                      10/2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     6400/4
\par                      A/B
\par                      4E2/XR
\par 
\par                                                BASIC PROGRAMMING RULES   11
\par \page 
\par 
\par 
\par     EXPONENTIATION     The up arrow (^) specifies that the operand on the
\par   left is raised to the power specified by the operand on the right (the
\par   exponent). If the operand on the right is a 2, the number on the left is
\par   squared; if the exponent is a 3, the number on the left is cubed, etc.
\par   The exponent can be any number so long as the result of the operation
\par   gives a valid floating-point number.
\par 
\par     EXAMPLES:
\par                      2^2        Equivalent to: 2*2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     3^3        Equivalent to: 3*3*3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     4^4        Equivalent to: 4*4*4*4
\par                      AB^CD
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     3^-2       Equivalent to: 1/3*1/3
\par 
\par   RELATIONAL OPERATORS
\par 
\par     The relational operators (<, =, >, <=, >=, <>) are primarily used
\par   to compare the values of two operands, but they also produce an arith-
\par   metic result. The relational operators and the logical operators (AND,
\par   OR, and NOT), when used in comparisons, actually produce an arithmetic
\par   true/false evaluation of an expression. If the relationship stated in
\par   the expression is true the result is assigned an integer value of - 1
\par   and if it's false a value of 0 is assigned. These are the relational
\par   operators:
\par                    <   LESS THAN
\par                    =   EQUAL TO
\par                    >   GREATER THAN
\par                    <=  LESS THAN OR EQUAL TO
\par                    >=  GREATER THAN OR EQUAL TO
\par                    <>  NOT EQUAL TO
\par 
\par     EXAMPLES:
\par 
\par       1 =5-4          result true (-1)
\par       14>66           result false (0)
\par       15>=15          result true (-1)
\par 
\par     Relational operators can be used to compare strings. For comparison
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  purposes, the letters of the alphabet have the order A<B<C<D, etc.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Strings are compared by evaluating the relationship between corre-
\par   sponding characters from left to right (see String Operations).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   12   BASIC PROGRAMMING RULES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    EXAMPLES:
\par 
\par       "A" < "B"       result true (-1)
\par       "X" = "YY"      result false (0)
\par       BB$ <> CC$
\par 
\par     Numeric data items can only be compared (or assigned) to other numeric
\par   items. The same is true when comparing strings, otherwise the BASIC error
\par   message ?TYPE MISMATCH will occur. Numeric operands are compared by first
\par   converting the values of either or both operands from integer to
\par   floating-point form, as necessary. Then the relationship of the floating-
\par   point values is evaluated to give a true/false result.
\par     At the end of all comparisons, you get an integer no matter what data
\par   type the operand is (even if both are strings). Because of this,
\par   a comparison of two operands can be used as an operand in performing
\par   calculations. The result will be - 1 or 0 and can be used as anything but
\par   a divisor, since division by zero is illegal.
\par 
\par   LOGICAL OPERATORS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The logical operators (AND, OR, NOT) can be used to modify the meanings
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of the relational operators or to produce an arithmetic result. Logical
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  operators can produce results other than -1 and 0, though any nonzero
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  result is considered true when testing for a true/false condition.
\par     The logical operators (sometimes called Boolean operators) can also be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  used to perform logic operations on individual binary digits (bits) in
\par   two operands. But when you're using the NOT operator, the operation is
\par   performed only on the single operand to the right. The operands must be
\par   in the integer range of values (-32768 to +32767) (floating-point
\par   numbers are converted to integers) and logical operations give an integer
\par   result.
\par     Logical operations are performed bit-by-corresponding-bit on the two
\par   operands. The logical AND produces a bit result of 1 only if both operand
\par   bits are 1. The logical OR produces a bit result of I if either operand
\par   bit is 1. The logical NOT is the opposite value of each bit as a single
\par   operand. In other words, it's really saying, "if it's NOT 1 then it is 0.
\par   If it's NOT 0 then it is 1."
\par     The exclusive OR (XOR) doesn't have a logical operator but it is per-
\par   formed as part of the WAIT statement. Exclusive OR means that if the bits
\par   of two operands are equal then the result is 0 otherwise the result is 1.
\par     Logical operations are defined by groups of statements which, taken
\par   together, constitute a Boolean "truth table" as shown in Table 1-2.
\par 
\par                                                BASIC PROGRAMMING RULES   13
\par \page 
\par 
\par 
\par                       Table 1-2. Boolean Truth Table
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | The AND operation results in a 1 only if both bits are 1:             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |                                                                       |
\par   |                            1 AND 1 = 1                                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |                            0 AND 1 = 0                                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |                            1 AND 0 = 0                                |
\par   |                            0 AND 0 = 0                                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |                                                                       |
\par   | The OR operation results  in a 1 if either bit is 1:                  |
\par   |                                                                       |
\par   |                            1 OR 1 = 1                                 |
\par   |                            0 OR 1 = 1                                 |
\par   |                            0 OR 0 = 1                                 |
\par   |                            0 OR 0 = 0                                 |
\par   |                                                                       |
\par   | The NOT operation logically complements each bit:                     |
\par   |                                                                       |
\par   |                            NOT 1 = 0                                  |
\par   |                            NOT 0 = 1                                  |
\par   |                                                                       |
\par   | The exclusive OR (XOR) is part of the WAIT statement!                 |
\par   |                                                                       |
\par   |                            1 XOR 1 = 0                                |
\par   |                            1 XOR 0 = 1                                |
\par   |                            0 XOR 1 = 1                                |
\par   |                            0 XOR 0 = 0                                |
\par   +-----------------------------------------------------------------------+
\par 
\par     The logical operators AND, OR and NOT specify a Boolean arithmetic
\par   operation to be performed on the two operand expressions on either side
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of the operator. In the case of NOT, ONLY the operand on the RIGHT is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  considered. Logical operations (or Boolean arithmetic) aren't performed
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  until all arithmetic and relational operations in an expression have been
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  completed.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    EXAMPLES:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     IF A=100 AND B=100 THEN 10    (if both A and B have a value
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                   of 100 then the result is true)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     A=96 AND 32: PRINT A          (A = 32)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  14   BASIC PROGRAMMING RULES
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     IF A=100 OR B=100 THEN 20     (if A or B is 100 then the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                   result is true)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     A=64 OR 32: PRINT A           (A = 96)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    IF NOT X<Y THEN 30            (if X>=Y the result is true)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    X= NOT 96                     (result is -97 (two's complement))
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  HIERARCHY OF OPERATIONS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    All expressions perform the different types of operations according to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a fixed hierarchy. In other words, certain operations are performed be-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  fore other operations. The normal order of operations can be modified
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  by enclosing two or more operands within parentheses ( ), creating a
\par   "subexpression." The parts of an expression enclosed in parentheses will
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  be reduced to a single value before working on parts outside the par-
\par   entheses.
\par     When you use parentheses in expressions, they must be paired so that
\par   you always have an equal number of left and right parentheses. Otherwise,
\par   the BASIC error message ?SYNTAX ERROR will appear.
\par     Expressions which have operands inside parentheses may themselves
\par   be enclosed in parentheses, forming complex expressions of multiple
\par   levels. This is called nesting. Parentheses can be nested in expressions
\par   to a maximum depth of ten levels-ten matching sets of parentheses.
\par   The inner-most expression has its operations performed first. Some
\par   examples of expressions are:
\par 
\par                      A+B
\par                      C^(D+E)/2
\par                      ((X-C^(D+E)/2)*10)+1
\par                      GG$>HH$
\par                      JJ$+"MORE"
\par                      K%=1 AND M<>X
\par                      K%=2 OR (A=B AND M<X)
\par                      NOT (D=E)
\par 
\par     The BASIC Interpreter will normally perform operations on expressions
\par   by performing arithmetic operations first, then relational operations,
\par   and logical operations lost. Both arithmetic and logical operators have
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                               BASIC PROGRAMMING RULES   15
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   an order of precedence (or hierarchy of operations) within themselves. On
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the other hand, relational operators do not have an order of precedence
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and will be performed as the expression is evaluated from left to right.
\par     If all remaining operators in an expression have the same level of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  precedence then operations happen from left to right. When performing
\par   operations on expressions within parentheses, the normal order of pre-
\par   cedence is maintained. The hierarchy of arithmetic and logical opera-
\par   tions is shown in Table 1-3 from first to last in order of precedence.
\par 
\par      Table 1-3. Hierarchy of Operations Performed on Expressions
\par   +---------------+---------------------------------+---------------------+
\par   |   OPERATOR    |           DESCRIPTION           |       EXAMPLE       |
\par   +---------------+---------------------------------+---------------------+
\par   |       ^       |    Exponentiation               |      BASE ^ EXP     |
\par   |               |                                 |                     |
\par   |       -       |    Negation (Unary Minus)       |         -A          |
\par   |               |                                 |                     |
\par   |      * /      |    Multiplication               |       AB * CD       |
\par   |               |    Division                     |       EF / GH       |
\par   |               |                                 |                     |
\par   |      + -      |    Addition                     |       CNT + 2       |
\par   |               |    Subtraction                  |       JK - PQ       |
\par   |               |                                 |                     |
\par   |     > = <     |    Relational Operations        |       A <= B        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |               |                                 |                     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      NOT      |    Logical NOT                  |        NOT K%       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |               |    (Integer Two's Complement)   |                     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |               |                                 |                     |
\par   |      AND      |    Logical AND                  |      JK AND 128     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |               |                                 |                     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      OR       |    Logical OR                   |       PQ OR 15      |
\par   +---------------+---------------------------------+---------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STRING OPERATIONS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Strings are compared using the same relational operators (=, <>,
\par   <=, >=, <, >) that are used for comparing numbers. String compari-
\par   sons are mode by taking one character at a time (left-to-right) from
\par   each string and evaluating each character code position from the PET/
\par   CBM character set. If the character codes are the same, the characters
\par   are equal. If the character codes differ, the character with the lower
\par   code number is lower in the character set. The comparison stops when
\par 
\par   16   BASIC PROGRAMMING RULES
\par \page 
\par 
\par 
\par     the end of either string is reached. All other things being equal, the
\par   shorter string is considered less than the longer string. Leading or
\par   trailing blanks ARE significant.
\par     Regardless of the data types, at the end of all comparisons you get
\par   an integer result. This is true even if both operands are strings.
\par   Because of this a comparison of two string operands can be used as an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  operand in performing calculations. The result will be - 1 or 0 (true or
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  false) and can be used as anything but a divisor since division by zero
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is illegal.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   STRING EXPRESSIONS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Expressions are treated as if an implied "<>0" follows them. This means
\par   that if an expression is true then the next BASIC statements on. the same
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  program line are executed. If the expression is false the rest of the
\par   line is ignored and the next line in the program is executed.
\par     Just as with numbers, you can also perform operations on string vari-
\par   ables. The only string arithmetic operator recognized by CBM BASIC is the
\par   plus sign (+) which is used to perform concatenation of strings. When
\par   strings are concatenated, the string on the right of the plus sign is
\par   appended to the string on the left, forming a third string as a result.
\par   The result can be printed immediately, used in a comparison, or assigned
\par   to a variable name. If a string data item is compared with (or set equal
\par   to) a numeric item, or vice-versa, the BASIC error message ?TYPE MISMATCH
\par   will occur. Some examples of string expressions and concatenation are:
\par 
\par     10 A$="FILE": B$="NAME"
\par     20 NAM$=A$+B$                      (gives the string: FILENAME)
\par     30 RES$="NEW "+A$+B$               (gives the string: NEW FILENAME)
\par                 ^
\par                 |       +-----------------+
\par                 +-------+ Note space here.|
\par                         +-----------------+
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                BASIC PROGRAMMING RULES   17
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PROGRAMMING TECHNIQUES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   DATA CONVERSIONS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When necessary, the CBM BASIC Interpreter will convert a numeric
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  data item from an integer to floating-point. or vice-versa, according to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the following rules:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    o All arithmetic and relational operations are performed in floating
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      point format. Integers are converted to floating-point form for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      evaluation of the expression, and the result is converted back to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      integer. logical operations convert their operands to integers an
\par       return an integer result.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    o If a numeric variable name of one type is set equal to a numeric
\par       data item of a different type, the number will be converted and
\par       stored as the data type declared in the variable name.
\par     o When a floating-point value is converted to an integer, the frac-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      tional portion is truncated (eliminated) and the integer result is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      less than or equal to the floating-point value. If the result is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      outside the range of +32767 thru -32768, the BASIC error message
\par       ?ILLEGAL QUANTITY will occur.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  USING THE INPUT STATEMENT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Now that you know what variables are, let's take that information an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  put it together with the INPUT statement for some practical program-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ming applications.
\par     In our first example, you can think of a variable as a "storage com-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  partment" where the Commodore 64 stores the user's response to your
\par   prompt question. To write a program which asks the user to type in a
\par   name, you might assign the variable N$ to the name typed in. Now
\par   every time you PRINT N$ in your program, the Commodore 64 will
\par   automatically PRINT the name that the user typed in.
\par     Type the word NEW on your Commodore 64. Hit the <RETURN> key
\par   and try this example:
\par 
\par     10 PRINT"YOUR NAME": INPUT N$
\par     20 PRINT"HELLO",N$
\par 
\par 
\par 
\par   18   BASIC PROGRAMMING RULES
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  In this example you used N to remind yourself that this variable stands
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  for "NAME". The dollar sign ($) is used to tell the computer that you're
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  using a string variable. It is important to differentiate between the two
\par   types of variables:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) NUMERIC
\par     2) STRING
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    You probably remember from the earlier sections that numeric vari-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ables are used to store number values such as 1, 100, 4000, etc. A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  numeric variable can be a single letter (A), any two letters (AB), a
\par   letter and a number (AI), or two letters and a number (AB1). You can save
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  memory space by using shorter variables. Another helpful hint is to use
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  letters and numbers for different categories in the same program (AI,
\par   A2, A3). Also, if you want whole numbers for an answer instead of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  numbers with decimal points, all you have to do is put a percent sign
\par   (%) at the end of your variable name (AB%, AI%, etc.)
\par   Now let's look at a few examples that use different types of variables
\par   and expressions with the INPUT statement.
\par 
\par     10 PRINT"ENTER A NUMBER": INPUT A
\par     20 PRINT A
\par 
\par     10 PRINT"ENTER A WORD": INPUT A$
\par     20 PRINT A$
\par 
\par     10 PRINT"ENTER A NUMBER": INPUT A
\par     20 PRINT A "TIMES 5 EQUALS" A*5
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   NOTE: Example 3 shows that MESSAGES or PROMPTS are inside the       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | quotation marks (" ") while the variables are outside. Notice, too,   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | that in line 20 the variable A was printed first, then the message    |
\par   | "TIMES 5 EQUALS", and then the calculation, multiply variable A by 5  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | (A*5).                                                                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Calculations are important in most programs. You have a choice of using
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  "actual numbers" or variables when doing calculations, but if you're
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  working with numbers supplied by a user you must use numeric variables.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Begin by asking the user to type in two numbers like this:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 PRINT"TYPE 2 NUMBERS": INPUT A: INPUT B
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                BASIC PROGRAMMING RULES   19
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        INCOME/EXPENSE BUDGET EXAMPLE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par start tok64 page20.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  5 print"\{clear\}"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 print"monthly income":input in
\par   20 print
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  30 print"expense category 1":input e1$
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  40 print"expense amount":input e1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  50 print
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60 print"expense category 2":input e2$
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 print"expense amount":input e2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  80 print
\par   90 print"expense category 3":input e3$
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 print"expense amount":input e3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  110 print"\{clear\}"
\par   120 e=e1+e2+e3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  130 ep=e/in
\par   140 print"monthly income: $"in
\par   150 print"total expenses: $"e
\par   160 print"balance equals: $"in-e
\par   170 print
\par   180 print e1$"="(e1/e)*100"% of total expenses"
\par   190 print e2$"="(e2/e)*100"% of total expenses"
\par   200 print e3$"="(e3/e)*100"% of total expenses"
\par   210 print
\par   220 print"your expenses="ep*100"% of your total income"
\par   230 forx=1to5000:next:print
\par   240 print"repeat? (y or n)":input y$:if y$="y"then 5
\par   250 print"\{clear\}":end
\par stop tok64
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE:IN can NOT = 0, and E1, E2, E3 can NOT all be 0 at the same time.|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  20   BASIC PROGRAMMING RULES
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                          LINE-BY-LINE EXPLANATION OF
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        INCOME/EXPENSE BUDGET EXAMPLE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------+-----------------------------------------------------------+
\par   |  Line(s)  |                    Description                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------+-----------------------------------------------------------+
\par   |     5     |  Clears the screen.                                       |
\par   |    10     |  PRINT/INPUT statement.                                   |
\par   |    20     |  Inserts blank line.                                      |
\par   |    30     |  Expense Category 1 = E1$.                                |
\par   |    40     |  Expense Amount = E1.                                     |
\par   |    50     |  Inserts blank line.                                      |
\par   |    60     |  Expense Category 2 = E2.                                 |
\par   |    70     |  Expense Amount 2 = E2.                                   |
\par   |    80     |  Inserts blank line.                                      |
\par   |    90     |  Expense Category 3 = E3.                                 |
\par   |   100     |  Expense Amount 3 = E3.                                   |
\par   |   110     |  Clears the screen.                                       |
\par   |   120     |  Add Expense Amounts = E.                                 |
\par   |   130     |  Calculate Expense/income%.                               |
\par   |   140     |  Display Income.                                          |
\par   |   150     |  Display Total Expenses.                                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   160     |  Display Incomes - Expenses.                              |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   170     |  Inserts blank line.                                      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   180-200 |  lines 180-200 calculate % each expense                   |
\par   |           |    amount is of total expenses.                           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   210     |  Inserts blank line.                                      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   220     |  Display E/IN %.                                          |
\par   |   230     |  Time delay loop.                                         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------+-----------------------------------------------------------+
\par 
\par 
\par   Now multiply those two numbers together to create a new variable C as
\par   shown in line 20 below:
\par 
\par     20 C=A*B
\par 
\par   To PRINT the result as a message type
\par 
\par     30 PRINT A "TIMES" B "EQUALS" C
\par 
\par   Enter these 3 lines and RUN the program. Notice that the messages are
\par   inside the quotes while the variables are not.
\par 
\par                                                BASIC PROGRAMMING RULES   21
\par \page 
\par 
\par 
\par     Now let's say that you wanted a dollar sign ($) in front of the number
\par   represented by variable C. The $ must be PRINTed inside quotes and in
\par   front of variable C. To add the $ to your program hit the <RUN/STOP>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and <RESTORE> keys. Now type in line 40 as follows:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     40 PRINT"$" C
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Now hit <RETURN>, type RUN and hit <RETURN> again.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The dollar sign goes in quotes because the variable C only represents
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a number and can't contain a $. If the number represented by C was
\par   100 then the Commodore 64 screen would display $ 100. But, if you
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  tried to PRINT $C without using the quotes, you would get a ?SYNTAX
\par   ERROR message.
\par     One last tip about $$$: You can create a variable that represents a
\par   dollar sign which you can then substitute for the $ when you want to use
\par   it with numeric variables. For example:
\par 
\par     10 Z$="$"
\par 
\par   Now whenever you need a dollar sign you can use the string variable
\par   Z$. Try this:
\par 
\par     10 Z$="$": INPUT A
\par     20 PRINT Z$A
\par 
\par   line 10 defines the $ as a string variable called Z$, and then INPUTs a
\par   number called A. line 20 PRINTs Z$ ($) next to A (number).
\par     You'll probably find that it's easier to assign certain characters,
\par   like dollar signs, to a string variable than to type "$" every time you
\par   want to calculate dollars or other items which require "" like %.
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  USING THE GET STATEMENT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Most simple programs use the INPUT statement to get data from the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  person operating the computer. When you're dealing with more complex
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  needs, like protection from typing errors, the GET statement gives you
\par   more flexibility and your program more "intelligence." This section shows
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  you how to use the GET statement to add some special screen editing
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  features to your programs.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   22   BASIC PROGRAMMING RULES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The Commodore 64 has a keyboard buffer that holds up to 10 characters.
\par   This means that if the computer is busy doing some operation and it's
\par   not reading the keyboard, you can still type in up to 10 characters,
\par   which will be used as soon as the Commodore 64 finishes what it was
\par   doing. To demonstrate this, type in this program on your Commodore 64:
\par 
\par     NEW
\par     10 TI$="000000"
\par     20 IF TI$ < "000015" THEN 20
\par 
\par   Now type RUN, hit <RETURN>  and while the program is RUNning type in the
\par   word HELLO.
\par     Notice that nothing happened for about IS seconds when the program
\par   started. Only then did the message HELLO appear on the screen.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Imagine standing in line for a movie. The first person in the line is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the first to get a ticket and leave the line. The last person in line is
\par   last for a ticket. The GET statement acts like a ticket taker. First it
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  looks to see if there are any characters "in line." In other words have
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  any keys been typed. If the answer is yes then that character gets placed
\par   in the appropriate variable. If no key was pressed then an empty value is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  assigned to a variable,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    At this point it's important to note that if you try to put more than
\par   10 characters into the buffer at one time, all those over the 10th
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  character will be lost.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Since the GET statement will keep going even when no character is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  typed, it is often necessary to put the GET statement into a loop so that
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  it will have to wait until someone hits a key or until a character is
\par   received through your program.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Below is the recommended form for the GET statement. Type NEW to erase
\par   your previous program.
\par 
\par     10 GET A$: IF A$ ="" THEN 10
\par 
\par   Notice that there is NO SPACE between the quote marks("") on this line.
\par   This indicates an empty value and sends the program back to the GET
\par   statement in a continuous loop until someone hits a key on the computer.
\par   Once a key is hit the program will continue with the line following line
\par   10. Add this line to your program:
\par 
\par     100 PRINT A$;: GOTO 10
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab \tab \tab        BASIC PROGRAMMING RULES   23
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Now RUN the program. Notice that no cursor appears on the screen, but
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  any character you type will be printed in the screen. This 2-line program
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  can be turned into part of a screen editor program as shown below.
\par     There are many things you can do with a screen editor. You can have
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a flashing cursor. You can keep certain keys like <CLR/HOME> from
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  accidentally erasing the whole screen. You might even want to be able to
\par   use your function keys to represent whole words or phrases. And speaking
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of function keys, the following program lines give each function key a
\par   special purpose. Remember this is only the beginning of a program that
\par   you can customize for your needs.
\par 
\par     20 IF A$ = CHR$(133) THEN POKE 53280,8: GOTO 10
\par     30 IF A$ = CHR$(134) THEN POKE 53281,4: GOTO 10
\par     40 IF A$ = CHR$(135) THEN A$="DEAR SIR:"+CHR$(13)
\par     50 IF A$ = CHR$(136) THEN A$="SINCERELY,"+CHR$(13)
\par 
\par     The CHR$ numbers in parentheses come from the CHR$ code chart in
\par   Appendix C. The chart lists a different number for each character. The
\par   four function keys are set up to perform the tasks represented by the
\par   instructions that follow the word THEN in each line. By changing the
\par   CHR$ number inside each set of parentheses you can designate different
\par   keys. Different instructions would be performed if you changed the
\par   information after the THEN statement.
\par 
\par   HOW TO CRUNCH BASIC PROGRAMS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  You can pack more instructions - and power - into your BASIC programs by
\par   making each program as short as possible. This process of shortening
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  programs is called "crunching."
\par     Crunching programs lets you squeeze the maximum possible number of
\par   instructions into your program. It also helps you reduce the size of
\par   programs which might not otherwise run in a given size; and if you're
\par   writing a program which requires the input of data such as inventory
\par   items, numbers or text, a short program will leave more memory space free
\par   to hold data.
\par 
\par   ABBREVIATING KEYWORDS
\par 
\par     A list of keyword abbreviations is given in Appendix A. This is helpful
\par   when you program because you can actually crowd more information on each
\par   line using abbreviations. The most frequently used abbreviation is
\par 
\par 
\par   24   BASIC PROGRAMMING RULES
\par \page 
\par 
\par 
\par   the question mark (?) which is the BASIC abbreviation for the PRINT
\par   command. However, if you LIST a program that has abbreviations, the
\par   Commodore 64 will automatically print out the listing with the full-
\par   length keywords. If any program line exceeds 80 characters (2 lines on
\par   the screen) with the keywords unabbreviated, and you want to change it,
\par   you will have to re-enter that line with the abbreviations before saving
\par   the program. SAVEing a program incorporates the keywords without
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  inflating any lines because BASIC keywords are tokenized by the Commodore
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  64. Usually, abbreviations are added after a program is written and it
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  isn't going to be LISTed any more before SAVEing.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SHORTENING PROGRAM LINE NUMBERS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Most programmers start their programs at line 100 and number each fine
\par   at intervals of 10 (i.e., 100, 110, 120). This allows extra lines of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  instruction to be added (111, 112, etc.) as the program is developed.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  One means of crunching the program after it is completed is to change
\par   the fine numbers to the lowest numbers possible (i.e., 1, 2, 3) because
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  longer line numbers take more memory than shorter numbers when referenced
\par   by GOTO and GOSUB statements. For instance, the number 100 uses 3 bytes
\par   of memory (one for each number) while the number I uses only 1 byte.
\par 
\par   PUTTING MULTIPLE INSTRUCTIONS ON EACH LINE
\par 
\par     You can put more than one instruction on each numbered line in your
\par   program by separating them by a colon. The only limitation is that all
\par   the instructions on each line, including colons, should not exceed the
\par   standard 80-character line length. Here is an example of two programs,
\par   before and after crunching:
\par 
\par   BEFORE CRUNCHING:              AFTER CRUNCHING:
\par 
\par   10 PRINT"HELLO...";            10 PRINT "HELLO...";:FORT=1TO500:NEXT:
\par   20 FOR T=1 TO 500: NEXT           PRINT"HELLO, AGAIN...":GOTO10
\par   30 PRINT"HELLO, AGAIN..."
\par   40 GOTO 10
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  REMOVING REM STATEMENTS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    REM statements are helpful in reminding yourself-or showing other
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  programmers - what a particular section of a program is doing. However,
\par   when the program is completed and ready to use, you probably
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab \tab \tab        BASIC PROGRAMMING RULES   25
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   won't need those REM statements anymore and you can save quite a bit of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  space by removing the REM statements. If you plan to revise or study the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  program structure in the future, it's a good idea to keep a copy on file
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  with the REM statements intact.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   USING VARIABLES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    If a number, word or sentence is used repeatedly in your program it's
\par   usually best to define those long words or numbers with a one or two
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  letter variable. Numbers can be defined as single letters. Words and
\par   sentences can be defined as string variables using a letter and dollar
\par   sign. Here's one example:
\par 
\par   BEFORE CRUNCHING:                 AFTER CRUNCHING:
\par 
\par   10 POKE 54296,15                  10 V=54296:F=54273
\par   20 POKE 54276,33                  20 POKEV,15:POKE54276,33
\par   30 POKE 54273,10                  30 POKEF,10:POKEF,40:POKEF,70
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  40 POKE 54273,40                  40 POKEV,0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  50 POKE 54273,70
\par   60 POKE 54296,0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  USING READ AND DATA STATEMENTS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Large amounts of data can be typed in as one piece of data at a time,
\par   over and over again ... or you can print the instructional part of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  program ONCE and print all the data to be handled in a long running list
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  called the DATA statement. This is especially good for crowding large
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  lists of numbers into a program.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   USING ARRAYS AND MATRICES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Arrays and matrices are similar to DATA statements in that long amounts
\par   of data can be handled as a list, with the data handling portion of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  program drawing from that list, in sequence. Arrays differ in that the
\par   list can be multi-dimensional
\par 
\par   ELIMINATING SPACES
\par 
\par     One of the easiest ways to reduce the size of your program is to
\par   eliminate all the spaces. Although we often include spaces in sample
\par 
\par 
\par   26   BASIC PROGRAMMING RULES
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  programs to provide clarity, you actually don't need any spaces in your
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  program and will save space if you eliminate them.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  USING GOSUB ROUTINES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   If you use a particular line or instruction over and over, it might be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  wise to GOSUB to the line from several places in your program, rather
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  than write the whole line or instruction every time you use it.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  USING TAB AND SPC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Instead of PRINTing several cursor commands to position a character
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  on the screen, it is often more economical to use the TAB and SPC in-
\par   structions to position words or characters on the screen.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par \tab \tab \tab \tab \tab        BASIC PROGRAMMING RULES   27
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                  CHAPTER 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                             BASIC LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Introduction
\par                            o BASIC Keywords, Abbreviations,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                             and Function Types
\par                            o Description of BASIC Keywords
\par                              (Alphabetical)
\par                            o The Commodore 64 Keyboard and
\par                              Features
\par                            o Screen Editor
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INTRODUCTION
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  This chapter explains CBM BASIC Language keywords. First we give you an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  easy to read list of keywords, their abbreviations and what each letter
\par   looks like on the screen. Then we explain how the syntax and operation of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  each keyword works in detail, and examples are shown to give you an idea
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  as to how to use them in your programs.
\par     As a convenience, Commodore 64 BASIC allows you to abbreviate most
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  keywords. Abbreviations are entered by typing enough letters of the
\par   keyword to distinguish it from all other keywords, with the last letter
\par   or graphics entered holding down the <SHIFT> key.
\par     Abbreviations do NOT save any memory when they're used in programs,
\par   because all keywords are reduced to single-character "tokens" by the
\par   BASIC Interpreter. When a program containing abbreviations is listed, all
\par   keywords appear in their fully spelled form. You can use abbreviations to
\par   put more statements onto a program line even if they won't fit onto the
\par   80-character logical screen line. The Screen Editor works on an 80-
\par   character line. This means that if you use abbreviations on any line that
\par   goes over 80 characters, you will NOT be able to edit that line when
\par   LISTed. Instead, what you'll have to do is (1) retype the entire line
\par   including all abbreviations, or (2) break the single line of code into
\par   two lines, each with its own line number, etc.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    A complete list of keywords, abbreviations, and their appearance on the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  screen is presented in Table 2-1. They are followed by an alphabetical
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  description of all the statements, commands, and functions available on
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  your Commodore 64.
\par     This chapter also explains the BASIC functions built into the BASIC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Language Interpreter. Built-in functions can be used in direct mode
\par   statements or in any program, without having to define the function
\par   further. This is NOT the case with user-defined functions. The results of
\par   built-in BASIC functions can be used as immediate output or they can be
\par   assigned to a variable name of an appropriate type. There are two types
\par   of BASIC functions:
\par 
\par     1) NUMERIC
\par     2) STRING
\par 
\par     Arguments of built-in functions are always enclosed in parentheses ().
\par   The parentheses always come directly after the function keyword and NO
\par   SPACES between the last letter of the keyword and the left parenthesis (.
\par 
\par 
\par 
\par   30   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par 
\par     The type of argument needed is generally decided by the data type in
\par   the result. Functions which return a string value as their result are
\par   identified by having a dollar sign ($) as the last character of the
\par   keyword. In some cases string functions contain one or more numeric
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  argument. Numeric functions will convert between integer and floating-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  point format as needed. In the descriptions that follow, the data type of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the value returned is shown with each function name. The types of argu-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ments are also given with the statement format.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par \tab \tab     Table 2-1. COMMODORE 64 BASIC KEYWORDS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------+----------------------+----------------+-------------------+
\par   |  COMMAND  |     ABBREVIATION     |     SCREEN     |   FUNCTION TYPE   |
\par   +-----------+----------------------+----------------+-------------------+
\par   |           |                      |                |                   |
\par   |    ABS    |     A <SHIFT+B>      |                |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    AND    |     A <SHIFT+N>      |                |                   |
\par   |           |                      |                |                   |
\par   |    ASC    |     A <SHIFT+S>      |                |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    ATN    |     A <SHIFT+T>      |                |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    CHR$   |     C <SHIFT+H>      |                |     STRING        |
\par   |           |                      |                |                   |
\par   |    CLOSE  |     CL <SHIFT+O>     |                |                   |
\par   |           |                      |                |                   |
\par   |    CLR    |     C <SHIFT+L>      |                |                   |
\par   |           |                      |                |                   |
\par   |    CMD    |     C <SHIFT+M>      |                |                   |
\par   |           |                      |                |                   |
\par   |    CONT   |     C <SHIFT+O>      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    COS    |        none          |      COS       |     NUMERIC       |
\par   |           |                      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    DATA   |     D <SHIFT+A>      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par   |    DEF    |     D <SHIFT+E>      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par   |    DIM    |     D <SHIFT+I>      |                |                   |
\par 
\par 
\par \tab \tab \tab \tab \tab      BASIC LANGUAGE VOCABULARY   31
\par \page 
\par 
\par 
\par   +-----------+----------------------+----------------+-------------------+
\par   |  COMMAND  |     ABBREVIATION     |     SCREEN     |   FUNCTION TYPE   |
\par   +-----------+----------------------+----------------+-------------------+
\par   |           |                      |                |                   |
\par   |    END    |     E <SHIFT+N>      |                |                   |
\par   |           |                      |                |                   |
\par   |    EXP    |     E <SHIFT+X>      |                |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    FN     |        none          |       FN       |                   |
\par   |           |                      |                |                   |
\par   |    FOR    |     F <SHIFT+O>      |                |                   |
\par   |           |                      |                |                   |
\par   |    FRE    |     F <SHIFT+R>      |                |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    GET#   |        none          |      GET#      |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    GOSUB  |     GO <SHIFT+S>     |                |                   |
\par   |           |                      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    GOTO   |     G <SHIFT+O>      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par   |    IF     |        none          |       IF       |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par   |    INPUT  |        none          |     INPUT      |                   |
\par   |           |                      |                |                   |
\par   |    INPUT# |     I <SHIFT+N>      |                |                   |
\par   |           |                      |                |                   |
\par   |    INT    |        none          |      INT       |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    LEFT$  |     LE <SHIFT+F>     |                |     STRING        |
\par   |           |                      |                |                   |
\par   |    LEN    |        none          |      LEN       |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    LET    |     L <SHIFT+E>      |                |                   |
\par   |           |                      |                |                   |
\par   |    LIST   |     L <SHIFT+I>      |                |                   |
\par   |           |                      |                |                   |
\par   |    LOAD   |     L <SHIFT+O>      |                |                   |
\par   |           |                      |                |                   |
\par   |    LOG    |        none          |      LOG       |     NUMERIC       |
\par 
\par 
\par 
\par 
\par   32   BASIC LANGUAGE VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------+----------------------+----------------+-------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  COMMAND  |     ABBREVIATION     |     SCREEN     |   FUNCTION TYPE   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------+----------------------+----------------+-------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par   |    MID$   |     M <SHIFT+I>      |                |     STRING        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par   |    NEW    |        none          |      NEW       |                   |
\par   |           |                      |                |                   |
\par   |    NEXT   |     N <SHIFT+E>      |                |                   |
\par   |           |                      |                |                   |
\par   |    NOT    |     N <SHIFT+O>      |                |                   |
\par   |           |                      |                |                   |
\par   |    ON     |        none          |       ON       |                   |
\par   |           |                      |                |                   |
\par   |    OPEN   |     O <SHIFT+P>      |                |                   |
\par   |           |                      |                |                   |
\par   |    OR     |        none          |       OR       |                   |
\par   |           |                      |                |                   |
\par   |    PEEK   |     P <SHIFT+E>      |                |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    POKE   |     P <SHIFT+O>      |                |                   |
\par   |           |                      |                |                   |
\par   |    POS    |        none          |      POS       |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    PRINT  |          ?           |       ?        |                   |
\par   |           |                      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    PRINT# |     P <SHIFT+R>      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par   |    READ   |     R <SHIFT+E>      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    REM    |        none          |      REM       |                   |
\par   |           |                      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    RESTORE|     RE <SHIFT+S>     |                |                   |
\par   |           |                      |                |                   |
\par   |    RETURN |     RE <SHIFT+T>     |                |                   |
\par   |           |                      |                |                   |
\par   |    RIGHT$ |     R <SHIFT+I>      |                |     STRING        |
\par   |           |                      |                |                   |
\par   |    RND    |     R <SHIFT+N>      |                |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    RUN    |     R <SHIFT+U>      |                |                   |
\par 
\par 
\par                                              BASIC LANGUAGE VOCABULARY   33
\par \page 
\par 
\par 
\par   |           |                      |                |                   |
\par   |    SAVE   |     S <SHIFT+A>      |                |                   |
\par   |           |                      |                |                   |
\par   |    SGN    |     S <SHIFT+G>      |                |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    SIN    |     S <SHIFT+I>      |                |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    SPC(   |     S <SHIFT+P>      |                |     SPECIAL       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    SQR    |     S <SHIFT+Q>      |                |     NUMERIC       |
\par   |           |                      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    STATUS |          ST          |       ST       |     NUMERIC       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par   |    STEP   |     ST <SHIFT+E>     |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    STOP   |     S <SHIFT+T>      |                |                   |
\par   |           |                      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    STR$   |     ST <SHIFT+R>     |                |     STRING        |
\par   |           |                      |                |                   |
\par   |    SYS    |     S <SHIFT+Y>      |                |                   |
\par   |           |                      |                |                   |
\par   |    TAB(   |     T <SHIFT+A>      |                |     SPECIAL       |
\par   |           |                      |                |                   |
\par   |    TAN    |        none          |      TAN       |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    THEN   |     T <SHIFT+H>      |                |                   |
\par   |           |                      |                |                   |
\par   |    TIME   |         TI           |       TI       |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    TIME$  |         TI$          |      TI$       |     STRING        |
\par   |           |                      |                |                   |
\par   |    TO     |        none          |       TO       |                   |
\par   |           |                      |                |                   |
\par   |    USR    |     U <SHIFT+S>      |                |     NUMERIC       |
\par   |           |                      |                |                   |
\par   |    VAL    |     V <SHIFT+A>      |                |     NUMERIC       |
\par   |           |                      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    VERIFY |     V <SHIFT+E>      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |                      |                |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    WAIT   |     W <SHIFT+A>      |                |                   |
\par   +-----------+----------------------+----------------+-------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   34   BASIC LANGUAGE VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  DESCRIPTION OF BASIC KEYWORDS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ABS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Function-Numeric
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: ABS(<expression>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: Returns the absolute value of the number, which is its value
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  without any signs. The absolute value of a negative number is that
\par   number multiplied by -1.
\par 
\par   EXAMPLES of ABS Function:
\par 
\par     10 X = ABS (Y)
\par     10 PRINT ABS (X*J)
\par     10 IF X = ABS (X) THEN PRINT"POSITIVE"
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  AND
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Operator
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: <expression> AND <expression>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: AND is used in Boolean operations to test bits. it is also used
\par   in operations to check the truth of both operands.
\par     In Boolean algebra, the result of an AND operation is 1 only if both
\par   numbers being ANDed are 1. The result is 0 if either or both is 0
\par   (false).
\par 
\par   EXAMPLES of 1-Bit AND operation:
\par 
\par             0         1         0         1
\par         AND 0     AND 0     AND 1     AND 1
\par        ------     -----     -----     -----
\par             0         0         0         1
\par 
\par     The Commodore 64 performs the AND operation on numbers in the range
\par   from -32768 to +32767. Any fractional values are not used, and numbers
\par   beyond the range will cause an ?ILLEGAL QUANTITY error message. When
\par 
\par 
\par                                              BASIC LANGUAGE VOCABULARY   35
\par \page 
\par 
\par 
\par   converted to binary format, the range allowed yields 16 bits for each
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  number. Corresponding bits are ANDed together, forming a 16-bit result
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in the same range.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES of 16-Bit AND Operation:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                          17
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                    AND 194
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                   --------
\par                            0000000000010001
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       AND 0000000011000010
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 --------------------------
\par                   (BINARY) 0000000000000000
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 --------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 (DECIMAL)                0
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      32007
\par                                   AND 28761
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 ----------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           0111110100000111
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       AND 0111000001011001
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 --------------------------
\par                   (BINARY) 0111000000000001
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 --------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 (DECIMAL)            28673
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                       -241
\par                                   AND 15359
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 ----------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           1111111100001111
\par                        AND 0011101111111111
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 --------------------------
\par                   (BINARY) 0011101100001111
\par                  --------------------------
\par                  (DECIMAL)            15119
\par 
\par 
\par 
\par   36   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par 
\par     When evaluating a number for truth or falsehood, the computer assumes
\par   the number is true as long as its value isn't 0. When evaluating a
\par   comparison, it assigns a value of -I if the result is true, while false
\par   has a value of 0. In binary format, -1 is all 1's and 0 is all 0's.
\par   Therefore, when ANDing true/false evaluations, the result will be true if
\par   any bits in the result are true.
\par 
\par   EXAMPLES of Using AND with True/False Evaluations:
\par 
\par     50 IF X=7 AND W=3 THEN GOTO 10: REM ONLY TRUE IF BOTH X=7
\par        AND W=3 ARE TRUE
\par     60 IF A AND Q=7 THEN GOTO 10: REM TRUE IF A IS NON-ZERO
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       AND Q=7 IS TRUE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   ASC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Function-Numeric
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: ASC(<string>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: ASC will return a number from 0 to 255 which corresponds to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the Commodore ASCII value of the first character in the string. The table
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of Commodore ASCII values is shown in Appendix C.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES OF ASC Function:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 PRINT ASC("Z")
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 X = ASC("ZEBRA")
\par     30 J = ASC(J$)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    If there are no characters in the string, an ?ILLEGAL QUANTITY error
\par   results. In the third example above, if J$="", the ASC function will not
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  work. The GET and GET# statement read a CHR$(0) as a null string. To
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  eliminate this problem, you should add a CHR$(0) to the end of the
\par   string as shown below.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE of ASC Function Avoiding ILLEGAL QUANTITY ERROR:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 J = ASC(J$ + CHR$(0))
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                              BASIC LANGUAGE VOCABULARY   37
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ATN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Function-Numeric
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: ATN(<number>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: This mathematical function returns the arctangent of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  number. The result is the angle (in radians) whose tangent is the number
\par   given. The result is always in the range -pi/2 to +pi/2.
\par 
\par   EXAMPLES of ATN Function:
\par 
\par     10 PRINT ATN(0)
\par     20 X = ATN(J)*180/ \{pi\} : REM CONVERT TO DEGREES
\par 
\par 
\par   CHR$
\par 
\par   TYPE: Function-String
\par   FORMAT: CHR$ (<number>)
\par 
\par     Action: This function converts a Commodore ASCII code to its character
\par   equivalent. See Appendix C for a list of characters and their codes. The
\par   number must have a value between 0 and 255, or an ?ILLEGAL QUANTITY error
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  message results.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES of CHR$ Function:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 PRINT CHR$(65) : REM 65 = UPPER CASE A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 A$=CHR$(13) : REM 13 = RETURN KEY
\par     50 A=ASC(A$) : A$ = CHR$(A) : REM CONVERTS TO C64 ASCII CODE AND BACK
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  38   BASIC LANGUAGE VOCABULARY
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   CLOSE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: I/O Statement
\par   FORMAT: CLOSE <file number>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: This statement shuts off any data file or channel to a device.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The file number is the same as when the file or device was OPENed (see
\par   OPEN statement and the section on INPUT/OUTPUT programming).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When working with storage devices like cassette tape and disks, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CLOSE operation stores any incomplete buffers to the device. When this
\par   is not performed, the file will be incomplete on the tape and unreadable
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  on the disk. The CLOSE operation isn't as necessary with other devices,
\par   but it does free up memory for other files. See your external device
\par   manual for more details.
\par 
\par   EXAMPLES of CLOSE Statement:
\par 
\par     10 CLOSE 1
\par     20 CLOSE X
\par     30 CLOSE 9*(1+J)
\par 
\par 
\par   CLR
\par 
\par   TYPE: Statement
\par   FORMAT: CLR
\par 
\par     Action: This statement makes available RAM memory that had been used
\par   but is no longer needed. Any BASIC program in memory is untouched, but
\par   all variables, arrays, GOSUB addresses, FOR...NEXT loops, user-defined
\par   functions, and files are erased from memory, and their space is mode
\par   available to new variables, etc.
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                             BASIC LANGUAGE VOCABULARY   39
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    In the case of files to the disk and cassette tape, they are not
\par   properly CLOSED by the CLR statement. The information about the files is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  lost to the computer, including any incomplete buffers. The disk drive
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  will still think the file is OPEN. See the CLOSE statement for more
\par   information on this.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE of CLR Statement:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     10 X=25
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 CLR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 PRINT X
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    RUN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    0
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    READY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CMD
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: I/O Statement
\par   FORMAT: <file number> [,string]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: This statement switches the primary- output device from the TV
\par   screen to the file specified. This file could be on disk, tape, printer,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  or an I/O device like the modem. The file number must be specified in a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  prior OPEN statement. The string, when specified, is sent to the file.
\par   This is handy for titling printouts, etc.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When this command is in effect, any PRINT statements and LIST commands
\par   will not display on the screen, but will send the text in the same
\par   format to the file.
\par     To re-direct the output back to the screen, the PRINT# command should
\par   send a blank line to the CMD device before CLOSEing, so it will
\par   stop expecting data (called "un-listening" the device).
\par 
\par 
\par 
\par   40   BASIC LANGUAGE VOCABULARY
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Any system error (like ?SYNTAX ERROR) will cause output to return to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the screen. Devices aren't un-listened by this, so you should send a
\par   blank line after an error condition. (See your printer or disk manual for
\par   more details.)
\par 
\par   EXAMPLES of CMD Statement:
\par 
\par     OPEN 4,4: CMD 4,"TITLE" : LIST: REM LISTS PROGRAM ON PRINTER
\par     PRINT#4: CLOSE 4: REM UN-LISTENS AND CLOSES PRINTER
\par 
\par     10 OPEN 1,1,1,"TEST" : REM CREATE SEQ FILE
\par     20 CMD 1 : REM OUTPUT TO TAPE FILE, NOT SCREEN
\par     30 FOR L = 1 TO 100
\par     40 PRINT L: REM PUTS NUMBER IN TAPE BUFFER
\par     50 NEXT
\par     60 PRINT#1 : REM UNLISTEN
\par     70 CLOSE 1 : REM WRITE UNFINISHED BUFFER, PROPERLY FINISH
\par 
\par 
\par   CONT
\par 
\par   TYPE: Command
\par   FORMAT: CONT
\par 
\par     Action: This command re-starts the execution of a program which was
\par   halted by a STOP or END statement or the <RUN/STOP> key being pressed.
\par   The program will re-start at the exact place from which it left off.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    While the program is stopped, the user can inspect or change any
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  variables or look at the program. When debugging or examining a program,
\par   STOP statements can be placed at strategic locations to allow examination
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of variables and to check the flow of the program.
\par     The error message CAN'T CONTINUE will result from editing the program
\par   (even just hitting <RETURN> with the cursor on an unchanged line), or if
\par   the program halted due to an error, or if you caused an error before
\par   typing CONT to re-start the program.
\par 
\par   EXAMPLE of CONT Command:
\par 
\par     10 PI=0:C=1
\par     20 PI=PI+4/C-4/(C+2)
\par     30 PRINT PI
\par     40 C=C+4:GOTO 20
\par 
\par                                              BASIC LANGUAGE VOCABULARY   41
\par \page 
\par 
\par 
\par     This program calculates the value of PI. RUN this program, and after
\par   a short while hit the <RUN/STOP> key. You will see the display:
\par 
\par                  +----------------------------------+
\par     BREAK IN 20  | NOTE: Might be different number. |
\par                  +----------------------------------+
\par 
\par     Type the command PRINT C to see how far the Commodore 64 has gotten.
\par   Then use CONT to resume from where the Commodore 64 left off.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   COS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Function
\par   FORMAT: COS (<number>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: This mathematical function calculates the cosine of the number,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  where the number is an angle in radians.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLES of COS Function:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 PRINT COS(0)
\par     20 X = COS(Y* \{pi\} /180) : REM CONVERT DEGREES TO RADIANS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   DATA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Statement
\par   FORMAT: DATA <list of constants>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: DATA statements store information within a program. The program
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  uses the information by means of the READ statement, which pulls
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  successive constants from the DATA statements.
\par     The DATA statements don't have to be executed by the program, they
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  only have to be present. Therefore, they are usually placed at the end of
\par   the program.
\par     All data statements in a program are treated as a continuous list. Data
\par   is READ from left to right, from the lowest numbered line to the highest.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  If the READ statement encounters data that doesn't fit the type requested
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (if it needs a number and finds a string) an error message occurs.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  42   BASIC LANGUAGE VOCABULARY
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Any characters can be included as data, but if certain ones are used
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the data item must be enclosed by quote marks (" "). These include
\par   punctuation like comma (,), colon (:), blank spaces, and shifted letters,
\par   graphics, and cursor control characters.
\par 
\par   EXAMPLES of DATA Statement:
\par 
\par     10 DATA 1,10,5,8
\par     20 DATA JOHN,PAUL,GEORGE,RINGO
\par     30 DATA "DEAR MARY, HOW ARE YOU, LOVE, BILL"
\par     40 DATA -1.7E-9, 3.33
\par 
\par 
\par 
\par   DEF FN
\par 
\par   TYPE: Statement
\par   FORMAT: DEF FN <name> ( <variable> ) = <expression>
\par 
\par     Action: This sets up a user-defined function that can be used later in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the program. The function can consist of any mathematical formula. User-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  defined functions save space in programs where a long formula is used in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  several places. The formula need only be specified once, in the
\par   definition statement, and then it is abbreviated as a function name. It
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  must be executed once, but any subsequent executions are ignored.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The function name is the letters FN followed by any variable name. This
\par   can be 1 or 2 characters, the first being a letter and the second a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  letter or digit.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLES of DEF FN Statement:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 DEF FN A(X)=X+7
\par     20 DEF FN AA(X)=Y*Z
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 DEF FN A9(Q) = INT(RND(1)*Q+1)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The function is called later in the program by using the function name
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  with a variable in parentheses. This function name is used like any other
\par   variable, and its value is automatically calculated,
\par 
\par 
\par 
\par 
\par 
\par                                              BASIC LANGUAGE VOCABULARY   43
\par \page 
\par 
\par 
\par   EXAMPLES of FN Use:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    40 PRINT FN A(9)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    50 R=FN AA(9)
\par     60 G=G+FN A9(10)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    In line 50 above, the number 9 inside the parentheses does not affect
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the outcome of the function, because the function definition in line 20
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  doesn't use the variable in the parentheses. The result is Y times Z,
\par   regardless of the value of X. In the other two functions, the value in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  parentheses does affect the result.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  DIM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: DIM <variable> ( <subscripts> )[
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          <variable> ( <subscripts> )...]
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: This statement defines an array or matrix of variables. This
\par   allows you to use the variable name with a subscript. The subscript
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  points to the element being used. The lowest element number in an array
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is zero, and the highest is the number given in the DIM statement, which
\par   has a maximum of 32767.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The DIM statement must be executed once and only once for each array.
\par   A REDIM'D ARRAY error occurs if this line is re-executed. Therefore,
\par   most programs perform all DIM operations at the very beginning.
\par     There may be any number of dimensions and 255 subscripts in an array,
\par   limited only by the amount of RAM memory which is available to hold the
\par   variables. The array may be mode up of normal numeric variables, as shown
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  above, or of strings or integer numbers. If the variables are other than
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  normal numeric, use the $ or % signs after the variable name to indicate
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  string or integer variables,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  44   BASIC LANGUAGE VOCABULARY
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     If an array referenced in a program was never DiMensioned, it is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  automatically dimensioned to 11 elements in each dimension used in the
\par   first reference.
\par 
\par   EXAMPLES of DIM Statement:
\par 
\par     10 DIM A(100)
\par     20 DIM Z (5,7), Y(3,4,5)
\par     30 DIM Y7%(Q)
\par     40 DIM PH$(1000)
\par     50 F(4)=9 : REM AUTOMATICALLY PERFORMS DIM F(10)
\par 
\par   EXAMPLE of FOOTBALL SCORE-KEEPING Using DIM:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 DIM S(1,5), T$(1)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 INPUT"TEAM NAMES"; T$(0), T$(1)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 FOR Q=1 TO 5: FOR T=0 TO 1
\par     40 PRINT T$(T),"SCORE IN QUARTER" Q
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    50 INPUT S(T,Q): S(T,0)= S(T,0)+ S(T,Q)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    60 NEXT T,Q
\par     70 PRINT CHR$(147) "SCOREBOARD"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    80 PRINT "QUARTER"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    90 FOR Q= 1 TO 5
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   100 PRINT TAB(Q*2+9) Q;
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   110 NEXT: PRINT TAB(15) "TOTAL"
\par    120 FOR T=0 TO 1: PRINT T$(T);
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   130 FOR Q= 1 TO 5
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   140 PRINT TAB(Q*2+9) S(T,Q);
\par    150 NEXT: PRINT TAB(15) S(T,0)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   160 NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   CALCULATING MEMORY USED BY DIM:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    5 bytes for the array name
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2 bytes for each dimension
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2 bytes/element for integer variables
\par     5 bytes/element for normal numeric variables
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3 bytes/element for string variables
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1 byte for each character in each string element
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                             BASIC LANGUAGE VOCABULARY   45
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  END
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: END
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: This finishes a program's execution and displays the READY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  message, returning control to the person operating the computer. There
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  may be any number of END statements within a program. While it is not
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  necessary to include any END statements at all, it is recommended that
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a program does conclude with one, rather than just running out of lines.
\par     The END statement is similar to the STOP statement. The only difference
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is that STOP causes the computer to display the message BREAK IN LINE XX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and END just displays READY. Both statements allow the computer to resume
\par   execution by typing the CONT command.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES of END Statement:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 PRINT"DO YOU REALLY WANT TO RUN THIS PROGRAM"
\par     20 INPUT A$
\par     30 IF A$ = "NO" THEN END
\par     40 REM REST OF PROGRAM . . .
\par     999 END
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXP
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Function-Numeric
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: EXP ( <number> )
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: This mathematical function calculates the constant e
\par   (2.71828183) raised to the power of the number given. A value greater
\par   than 88.0296919 causes an ?OVERFLOW error to occur.
\par 
\par   EXAMPLES of EXP Function:
\par 
\par     10 PRINT EXP (1)
\par     20 X = Y*EXP (Z*Q)
\par 
\par 
\par 
\par 
\par 
\par   46   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par 
\par   FN
\par 
\par   TYPE: Function-Numeric
\par   FORMAT: FN <name> ( <number> )
\par 
\par     Action: This function references the previously DEFined formula spec-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ified by name. The number is substituted into its place (if any) and the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  formula is calculated. The result will be a numeric value.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This function can be used in direct mode, as long as the statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  DEFining it has been executed.
\par     If an FN is executed before the DEF statement which defines it, an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  UNDEF'D FUNCTION error occurs.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLES of FN (User-Defined) Function:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    PRINT FN A(Q)
\par     1100 J = FN J(7)+ FN J(9)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    9990 IF FN B7 (1+1)= 6 THEN END
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FOR ... TO ... [STEP ...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: FOR <variable> = <start> TO <limit> [ STEP <increment> ]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: This is a special BASIC statement that lets you easily use a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  variable as a counter. You must specify certain parameters: the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  floating-point variable name, its starting value, the limit of the count,
\par   and how much to add during each cycle.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Here is a simple BASIC program that counts from 1 to 10, PRINTing
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  each number and ENDing when complete, and using no FOR statements:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     100 L = 1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    110 PRINT L
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    120 L = 1 + 1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    130 IF L <= 10 THEN 110
\par     140 END
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                              BASIC LANGUAGE VOCABULARY   47
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Using the FOR statement, here is the same program:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     100 FOR L = 1 TO 10
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    110 PRINT L
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    120 NEXT L
\par     130 END
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    As you can see, the program is shorter and easier to understand using
\par   the FOR statement.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When the FOR statement is executed, several operations take place.
\par   The <start> value is placed in the <variable> being used in the
\par   counter. In the example above, a I is placed in L.
\par     When the NEXT statement is reached, the <increment> value is added to
\par   the <variable>. If a STEP was not included, the <increment> is set to
\par   + 1. The first time the program above hits line 120, 1 is added to L,
\par   so the new value of L is 2.
\par     Now the value in the <variable> is compared to the <limit>. If the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  <limit> has not been reached yet, the program G0es TO the line after
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the original FOR statement. In this case, the value of 2 in L is less
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  than the limit of 10, so it GOes TO line 110.
\par     Eventually, the value of <limit> is exceeded by the <variable>. At
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  that time, the loop is concluded and the program continues with the line
\par   following the NEXT statement. In our example, the value of L reaches
\par   11, which exceeds the limit of 10, and the program goes on with line
\par   130.
\par     When the value of <increment> is positive, the <variable> must
\par   exceed the <limit>, and when it is negative it must become less than
\par   the <limit>.
\par 
\par   +---------------------------------------------+
\par   | NOTE: A loop always executes at least once. |
\par   +---------------------------------------------+
\par 
\par 
\par   EXAMPLES of FOR...TO...STEP...Statement:
\par 
\par     100 FOR L = 100 TO 0 STEP -1
\par     100 FOR L = PI TO 6* \{pi\} STEP .01
\par     100 FOR AA = 3 TO 3
\par 
\par 
\par 
\par 
\par   48   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FRE
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: FRE ( <variable> )
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Action: This function tells you how much RAM is available for your
\par   program and its variables. If a program tries to use more space than is
\par   available, the OUT OF MEMORY error results.
\par     The number in parentheses can have any value, and it is not used in
\par   the calculation.
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE: If the result of FRE is negative, add 65536 to the FRE number   |
\par   | get the number of bytes available in memory.                          |
\par   +-----------------------------------------------------------------------+
\par 
\par   EXAMPLES of FRE Function:
\par 
\par     PRINT FRE(0)
\par     10 X = (FRE(K)-1000)/7
\par     950 IF FRE(0)< 100 THEN PRINT "NOT ENOUGH ROOM"
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE: The following always tells you the current available RAM:       |
\par   | PRINT FRE(0) - (FRE(0) < 0)* 65536                                    |
\par   +-----------------------------------------------------------------------+
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  GET
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: GET <variable list>
\par 
\par     Action: This statement reads each key typed by the user. As the user is
\par   typing, the characters are stored in the Commodore 64's keyboard buffer.
\par   Up to 10 characters are stored here, and any keys struck after the 10th
\par   are lost. Reading one of the characters with the GET statement makes room
\par   for another character.
\par     If the GET statement specifies numeric data, and the user types a key
\par   other than a number, the message ?SYNTAX ERROR appears. To be safe, read
\par   the keys as strings and convert them to numbers later.
\par 
\par 
\par                                              BASIC LANGUAGE VOCABULARY   49
\par \page 
\par 
\par 
\par     The GET statement can be used to avoid some of the limitations of the
\par   INPUT statement. For more on this, see the section on Using the GET
\par   Statement in the Programming Techniques section.
\par 
\par 
\par   EXAMPLES of GET Statement:
\par 
\par     10 GET A$: IF A$ ="" THEN 10: REM LOOPS IN 10 UNTIL ANY KEY HIT
\par     20 GET A$, B$, C$, D$, E$: REM READS 5 KEYS
\par     30 GET A, A$
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  GET#
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: I/O Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: GET# <file number>, <variable list>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: This statement reads characters one-at-a-time from the device
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  or file specified. It works the same as the GET statement, except that
\par   the data comes from a different place than the keyboard. If no character
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is received, the variable is set to an empty string (equal to "") or to 0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  for numeric variables. Characters used to separate data in files, like
\par   the comma (,) or <RETURN> key code (ASC code of 13), are received like
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  any other character.
\par     When used with device #3 (TV screen), this statement will read char-
\par   acters one by one from the screen. Each use of GET# moves the cursor 1
\par   position to the right. The character at the end of the logical line is
\par   changed to a CHR$ (13), the <RETURN> key code.
\par 
\par 
\par 
\par   EXAMPLES of GET# Statement:
\par 
\par     5 GET#1, A$
\par     10 OPEN 1,3: GET#1, Z7$
\par     20 GET#1, A, B, C$, D$
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  50   BASIC LANGUAGE VOCABULARY
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   GOSUB
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Statement
\par   FORMAT: GOSUB <line number>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: This is a specialized form of the GOTO statement, with one
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  important difference: GOSUB remembers where it came from. When the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RETURN statement (different from the <RETURN> key on the keyboard)
\par   is reached in the program, the program jumps back to the statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  immediately following the original GOSUB statement.
\par     The major use of a subroutine (GOSUB really means GO to a SUBroutine)
\par   is when a small section of program is used by different sections of the
\par   program. By using subroutines rather than repeating the same lines over
\par   and over at different places in the program, you can save lots of program
\par   space. In this way, GOSUB is similar to DEF FN. DEF FN lets you save
\par   space when using a formula, while GOSUB saves space when using a several-
\par   line routine. Here is an inefficient program that doesn't use GOSUB:
\par 
\par     100 PRINT "THIS PROGRAM PRINTS"
\par     110 FOR L = 1 TO 500:NEXT
\par     120 PRINT "SLOWLY ON THE SCREEN"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    130 FOR L = 1 TO 500:NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    140 PRINT "USING A SIMPLE LOOP"
\par     150 FOR L = 1 TO 500:NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    160 PRINT "AS A TIME DELAY."
\par     170 FOR L = 1 TO 500:NEXT
\par 
\par   Here is the same program using GOSUB:
\par 
\par     100 PRINT "THIS PROGRAM PRINTS"
\par     110 GOSUB 200
\par     120 PRINT "SLOWLY ON THE SCREEN"
\par     130 GOSUB 200
\par     140 PRINT "USING A SIMPLE LOOP"
\par     150 GOSUB 200
\par     160 PRINT "AS A TIME DELAY."
\par     170 GOSUB 200
\par     180 END
\par     200 FOR L = 1 TO 500 NEXT
\par     210 RETURN
\par 
\par 
\par 
\par                                              BASIC LANGUAGE VOCABULARY   51
\par \page 
\par 
\par 
\par     Each time the program executes a GOSUB, the line number and position
\par   in the program line are saved in a special area called the "stack,"
\par   which takes up 256 bytes of your memory. This limits the amount of data
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  that can be stored in the stack. Therefore, the number of subroutine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  return addresses that can be stored is limited, and care should be taken
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to make sure every GOSUB hits the corresponding RETURN, or else you'll
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  run out of memory even though you have plenty of bytes free.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  GOTO
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT :GOTO <line number>
\par \tab   or GO TO <line number>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: This statement allows the BASIC program to execute lines out
\par   of numerical order. The word GOTO followed by a number will make the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  program jump to the line with that number. GOTO NOT followed by a number
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  equals GOTO 0. It must have the line number after the word GOTO.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    It is possible to create loops with GOTO that will never end. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  simplest example of this is a line that GOes TO itself, like 10 GOTO 10.
\par   These loops can be stopped using the <RUN/STOP> key on the keyboard.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES of GOTO Statement:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    GOTO 100
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 GO TO 50
\par     20 GOTO 999
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   IF...THEN...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: IF <expression> THEN <line number>
\par \tab   IF <expression> GOTO <line number>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab   IF <expression> THEN <statements>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: This is the statement that gives BASIC most of its "intelli-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  gence," the ability to evaluate conditions and take different actions de-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  pending on the outcome.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   52   BASIC LANGUAGE VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The word IF is followed by an expression, which can include variables,
\par   strings, numbers, comparisons, and logical operators. The word THEN
\par   appears on the same line and is followed by either a line number or one
\par   or more BASIC statements. When the expression is false, everything after
\par   the word THEN on that line is ignored, and execution continues with the
\par   next line number in the program. A true result makes the program either
\par   branch to the line number after the word THEN or execute whatever other
\par   BASIC statements are found on that line.
\par 
\par 
\par   EXAMPLE of IF...GOTO...Statement:
\par 
\par     100 INPUT "TYPE A NUMBER"; N
\par     110 IF N <= 0 GOTO 200
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    120 PRINT "SQUARE ROOT=" SQR(N)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    130 GOTO 100
\par     200 PRINT "NUMBER MUST BE >0"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    210 GOTO 100
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     This program prints out the square root of any positive number. The IF
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  statement here is used to validate the result of the INPUT. When the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  result of N <= 0 is true, the program skips to line 200, and when the
\par   result is false the next line to be executed is 120. Note that THEN GOTO
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is not needed with IF...THEN, as in line 110 where GOTO 200 actually
\par   means THEN GOTO 200.
\par 
\par 
\par   EXAMPLE OF IF...THEN...Statement:
\par 
\par     100 FOR L = 1 TO 100
\par     110 IF RND(1) < .5 THEN X=X+1: GOTO 130
\par     120 Y=Y+1
\par     130 NEXT L
\par     140 PRINT "HEADS=" X
\par     150 PRINT "TAILS= " Y
\par 
\par   The IF in line 110 tests a random number to see if it is less than .5.
\par   When the result is true, the whole series of statements following the
\par   word THEN are executed: first X is incremented by 1, then the program
\par   skips to line 130. When the result is false, the program drops to the
\par   next statement, line 120.
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                             BASIC LANGUAGE VOCABULARY   53
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INPUT
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: INPUT [ "<prompt>" ; ] <variable list>
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: This is a statement that lets the person RUNning the program
\par   "feed" information into the computer. When executed, this statement
\par   PRINTs a question mark (?) on the screen, and positions the cursor 1
\par   space to the right of the question mark. Now the computer waits, cursor
\par   blinking, for the operator to type in the answer and press the <RETURN>
\par   key.
\par     The word INPUT may be followed by any text contained in quote marks
\par   (""). This text is PRINTed on the screen, followed by the question mark.
\par     After the text comes a semicolon (;) and the name of one or more
\par   variables separated by commas. This variable is where the computer
\par   stores the information that the operator types. The variable can be any
\par   legal variable name, and you can have several different variable
\par   names, each for a different input.
\par 
\par   EXAMPLES of INPUT Statement:
\par 
\par     100 INPUT A
\par     110 INPUT B, C, D
\par     120 INPUT "PROMPT"; E
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When this program RUNs, the question mark appears to prompt the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  operator that the Commodore 64 is expecting an input for line 100. Any
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  number typed in goes into A, for later use in the program. If the answer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  typed was not a number, the ?REDO FROM START message appears, which means
\par   that a string was received when a number was expected.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    If the operator just hits <RETURN> without typing anything, the vari-
\par   able's value doesn't change.
\par     Now the next question mark, for line 110, appears. If we type only
\par   one number and hit the <RETURN>, Commodore 64 will now display 2
\par   question marks (??), which means that more input is required. You can
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   54   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par 
\par   just type as many inputs as you need separated by commas, which prevents
\par   the double question mark from appearing. If you type more data than the
\par   INPUT statement requested, the ?EXTRA IGNORED message appears, which
\par   means that the extra items you typed were not put into any variables.
\par     Line 120 displays the word PROMPT before the question mark appears. The
\par   semicolon is required between the prompt and any list of variables.
\par     The INPUT statement can never be used outside a program. The Commodore
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  64 needs space for a buffer for the INPUT variables, the same space that
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is used for commands.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INPUT#
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: I/O Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: INPUT# <file number> , <variable list>
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: This is usually the fastest and easiest way to retrieve data
\par   stored in a file on disk or tape. The data is in the form of whole vari-
\par   ables of up to 80 characters in length, as opposed to the one-at-a-time
\par   method of GET#. First, the file must have been OPENed, then INPUT# can
\par   fill the variables.
\par     The INPUT# command assumes a variable is finished when it reads a
\par   RETURN code (CHR$ (13)), a comma (,), semicolon (;), or colon (:).
\par   Quote marks can be used to enclose these characters when writing if
\par   they are needed (see PRINT# statement).
\par     If the variable type used is numeric, and non-numeric characters are
\par   received, a BAD DATA error results. INPUT# can read strings up to 80
\par   characters long, beyond which a STRING TOO LONG error results.
\par     When used with device #3 (the screen), this statement will read an
\par   entire logical line and move the cursor down to the next line.
\par 
\par   EXAMPLES of INPUT# Statement:
\par 
\par   10 INPUT#1,A
\par   20 INPUT#2,A$,B$
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                             BASIC LANGUAGE VOCABULARY   55
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Integer Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: INT (<numeric>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: Returns the integer value of the expression. If the expression
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is positive, the fractional part is left off. If the expression is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  negative, any fraction causes the next lower integer to be returned.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES of INT Function:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    120 PRINT INT(99.4343), INT(-12.34)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par      99       -13
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   LEFT$
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: String Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: LEFT$ (<string>, <integer>)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: Returns a string comprised of the leftmost <integer> char-
\par   acters of the <string>. The integer argument value must be in the range
\par   0 to 255. If the integer is greater than the length of the string, the
\par   entire string will be returned. If an <integer> value of zero is used,
\par   then a null string (of zero length) is returned.
\par 
\par   EXAMPLES of LEFT$ Function:
\par 
\par     10 A$ = "COMMODORE COMPUTERS"
\par     20 B$ = LEFT$(A$,9): PRINT B$
\par     RUN
\par 
\par     COMMODORE
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   56   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LEN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Integer Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Format: LEN (<string>)
\par 
\par     Action: Returns the number of characters in the string expression.
\par   Non-printed characters and blanks are counted.
\par 
\par   EXAMPLE of LEN Function:
\par 
\par     CC$ = "COMMODORE COMPUTER": PRINT LEN(CC$)
\par 
\par      18
\par 
\par 
\par 
\par   LET
\par 
\par   TYPE: Statement
\par   FORMAT: [LET] <variable> = <expression>
\par 
\par     Action: The LET statement can be used to assign a value to a variable.
\par   But the word LET is optional and therefore most advanced programmers
\par   leave LET out because it's always understood and wastes valuable memory.
\par   The equal sign (=) alone is sufficient when assigning the value of an
\par   expression to a variable name.
\par 
\par   EXAMPLES of LET Statement:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 LET D= 12              (This is the same as D = 12)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 LET E$ = "ABC"
\par     30 F$ = "WORDS"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    40 SUM$= E$ + F$          (SUM$ would equal ABCWORDS)
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                              BASIC LANGUAGE VOCABULARY   57
\par \page 
\par 
\par 
\par   LIST
\par 
\par   TYPE: Command
\par   FORMAT: LIST [[<first-line>]-[<last-line>]]
\par 
\par     Action: The LIST command allows you to look at lines of the BASIC
\par   program currently in the memory of your Commodore 64. This lets you use
\par   your computer's powerful screen editor, to edit programs which you've
\par   LISTed both quickly and easily.
\par     The LIST system command displays all or part of the program that is
\par   currently in memory on the default output device. The LIST will normally
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  be directed to the screen and the CMD statement can be used to switch
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  output to an external device such as a printer or a disk. The LIST com-
\par   mand can appear in a program, but BASIC always returns to the system
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  READY message after a LIST is executed.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When you bring the program LIST onto the screen, the "scrolling" of
\par   the display from the bottom of the screen to the top can be slowed by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  holding down the ConTRoL <CTRL> key. LIST is aborted by typing the
\par   <RUN/STOP> key.
\par     If no line-numbers are given the entire program is listed. If only the
\par   first-line number is specified, and followed by a hyphen (-), that line
\par   and all higher-numbered lines are listed. If only the last line-number is
\par   specified, and it is preceded by a hyphen, then all lines from the
\par   beginning of the program through that line are listed. If both numbers
\par   are specified, the entire range, including the line-numbers LISTed, is
\par   displayed.
\par 
\par   EXAMPLES of LIST Command:
\par 
\par     LIST            (Lists the program currently in memory.)
\par 
\par     LIST 500        (Lists line 500 only.)
\par 
\par     LIST 150-       (Lists all lines from 150 to the end.)
\par 
\par     LIST -1000      (Lists all lines from the lowest through 1000.)
\par 
\par     LIST 150-1000   (Lists lines 150 through 1000, inclusive.)
\par 
\par     10 PRINT "THIS  IS LINE 10"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 LIST                             (LIST used in Program Mode)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 PRINT "THIS  IS LINE 30"
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  58   BASIC LANGUAGE VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LOAD
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Command
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: LOAD["<file-name>"][,<device>][,<address>]
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: The LOAD statement reads the contents of a program file from
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  tape or disk into memory. That way you can use the information LOADed
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  or change the information in some way. The device number is optional,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  but when it is left out the computer will automatically default to 1, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cassette unit. The disk unit is normally device number 8. The LOAD closes
\par   all open files and, if it is used in direct mode, it performs a CLR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (clear) before reading the program. If LOAD is executed from within a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  program, the program is RUN. This means that you can use LOAD to "chain"
\par   several programs together. None of the variables are cleared during a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  chain operation.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    If you are using file-name pattern matching, the first file which
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  matches the pattern is loaded. The asterisk in quotes by itself ("*")
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  causes the first file-name in the disk directory to be loaded. if the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  filename used does not exist or if it is not a program file, the BASIC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  error message ?FILE NOT FOUND occurs.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When LOADing programs from tape, the <file-name> can be left out, and
\par   the next program file on the tape will be read. The Commodore 64 will
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  blank the screen to the border color after the PLAY key is pressed. When
\par   the program is found, the screen clears to the background color and the
\par   "FOUND" message is displayed. When the <C=> key, <CTRL> key, <ARROW LEFT>
\par   key, or <SPACE BAR> is pressed, the file will be loaded. Programs will
\par   LOAD starting at memory location 2048 unless a secondary <address> of 1
\par   is used. If you use the secondary address of 1 this will cause the
\par   program to LOAD to the memory location from which it was saved.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                              BASIC LANGUAGE VOCABULARY   59
\par \page 
\par 
\par 
\par   EXAMPLES of LOAD Command:
\par 
\par 
\par     LOAD                         (Reads the next program on tape)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LOAD A$                      (Uses the name in A$ to search)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LOAD"*",8                    (LOADs first program from disk)
\par 
\par     LOAD"",1,1                   (Looks for the first program on
\par                                   tape, and LOADs it into the same
\par                                   part of memory that it came from)
\par 
\par 
\par 
\par 
\par     LOAD"STAR TREK"              (LOAD a file from tape)
\par     PRESS PLAY ON TAPE
\par     FOUND STAR TREK
\par     LOADING
\par     READY.
\par 
\par 
\par 
\par 
\par     LOAD"FUN",8                  (LOAD a file from disk)
\par     SEARCHING FOR FUN
\par     LOADING
\par     READY.
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LOAD"GAME ONE",8,1           (LOAD a file to the specific
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    SEARCHING FOR GAME ONE        memory location from which the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LOADING                       program was saved on the disk)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    READY.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   60   BASIC LANGUAGE VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LOG
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Floating-Point Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: LOG(<numeric>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: Returns the natural logarithm (log to the base of e) of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  argument. If the value of the argument is zero or negative the BASIC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  error message ?ILLEGAL QUANTITY will occur.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES of LOG Function:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     25 PRINT LOG(45/7)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     1.86075234
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     10 NUM=LOG(ARG)/LOG(10)  (Calculates the LOG of ARG to the base 10)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   MID$
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: String Function
\par   FORMAT: MID$(<string>,<numeric-1>[,<numeric-2>])
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: The MID$ function returns a sub-string which is taken from
\par   within a larger <string> argument. The starting position of the sub-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  string is defined by the <numeric-1> argument and the length of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sub-string by the <numeric-2> argument. Both of the numeric arguments
\par   can have values ranging from 0 to 255.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    If the <numeric-1> value is greater than the length of the <string>,
\par   or if the <numeric-2> value is zero, then MID$ gives a null string value.
\par   If the <numeric-2> argument is left out, then the computer will assume
\par   that a length of the rest of the string is to be used. And if the source
\par   string has fewer characters than <numeric-2>, from the starting position
\par   to the end of the string argument, then the whole rest of the string is
\par   used.
\par 
\par   EXAMPLE of MID$ Function:
\par 
\par     10 A$="GOOD"
\par     20 B$="MORNING EVENING AFTERNOON"
\par     30 PRINT A$ + MID$(B$,8,8)
\par 
\par     GOOD EVENING
\par 
\par                                              BASIC LANGUAGE VOCABULARY   61
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  NEW
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Command
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: NEW
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: The NEW command is used to delete the program currently in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  memory and clear all variables. Before typing in a new program, NEW
\par   should be used in direct mode to clear memory. NEW can also be used in
\par   a program, but you should be aware of the fact that it will erase
\par   everything that has gone before and is still in the computer's memory.
\par   This can be particularly troublesome when you're trying to debug your
\par   program.
\par 
\par   +-----------------------------------------------------------------------+
\par   | BE CAREFUL: Not clearing out an old program before typing a new one   |
\par   | can result in a confusing mix of the two programs.                    |
\par   +-----------------------------------------------------------------------+
\par 
\par   EXAMPLES of NEW Command:
\par 
\par     NEW             (Clears the program and all variables)
\par     10 NEW          (Performs a NEW operation and STOPs the program.)
\par 
\par 
\par   NEXT
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: NEXT[<counter>][,<counter>]...
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: The NEXT statement is used with FOR to establish the end of a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FOR...NEXT loop. The NEXT need not be physically the last statement
\par   in the loop, but it is always the last statement executed in a loop. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  <counter> is the loop index's variable name used with FOR to start the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  loop. A single NEXT can stop several nested loops when it is followed by
\par   each FOR's <counter> variable name(s). To do this each name must appear
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in the order of inner-most nested loop first, to outer-most nested loop
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  last. When using a single NEXT to increment and stop several variable
\par   names, each variable name must be separated by commas. Loops can be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  nested to 9 levels. If the counter variable(s) are omitted, the counter
\par   associated with the FOR of the current level (of the nested loops) is
\par   incremented.
\par 
\par 
\par   62   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par 
\par     When the NEXT is reached, the counter value is incremented by 1 or by
\par   an optional STEP value. It is then tested against an end-value to see if
\par   it's time to stop the loop. A loop will be stopped when a NEXT is found
\par   which has its counter value greater than the end-value.
\par 
\par   EXAMPLES of NEXT Statement:
\par 
\par     10 FOR J=1 TO 5: FOR K=10 TO 20: FOR N=5 TO -5 STEP - 1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 NEXT N,K,J            (Stopping Nested Loops)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     10 FOR L=1 TO 100
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 FOR M=1 TO 10
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 NEXT M
\par     400 NEXT L               (Note how the loops do NOT cross each other)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     10 FOR A=1 TO 10
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 FOR B=1 TO 20
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 NEXT
\par     40 NEXT                  (Notice that no variable names are needed)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  NOT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Logical Operator
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: NOT <expression>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: The NOT logical operator "complements" the value of each bit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in its single operand, producing an integer "twos-complement" result. In
\par   other words, the NOT is really saying, "if it isn't. When working with a
\par   floating-point number, the operands are converted to integers and any
\par   fractions are lost. The NOT operator can also be used in a comparison to
\par   reverse the true/false value which was the result of a relationship test
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and therefore it will reverse the meaning of the comparison. In the first
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  example below, if the "twos-complement" of "AA" is equal to "BB" and if
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  "BB" is NOT equal to "CC" then the expression is true.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                             BASIC LANGUAGE VOCABULARY   63
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLES of NOT Operator:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 IF NOT AA = BB AND NOT(BB = CC) THEN...
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    NN% = NOT 96: PRINT NN%
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    -97
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par   | NOTE: TO find the value of NOT use the expression X=(-(X+1)). (The    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | two's complement of any integer is the bit complement plus one.)      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ON
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: ON <variable> GOTO / GOSUB <line-number>[,<line-number>]...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: The ON statement is used to GOTO one of several given line-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  numbers, depending upon the value of a variable. The value of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  variables can range from zero through the number of lines given. if the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  value is a non-integer, the fractional portion is left off. For example,
\par   if the variable value is 3, ON will GOTO the third line-number in the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  list.
\par     If the value of the variable is negative, the BASIC error message
\par   ?ILLEGAL QUANTITY occurs. If the number is zero, or greater than the
\par   number of items in the list, the program just "ignores" the statement and
\par   continues with the statement following the ON statement.
\par     ON is really an underused variant of the IF...THEN...statement. Instead
\par   of using a whole lot of IF statements each of which sends the program to
\par   1 specific line, 1 ON statement can replace a list of IF statements. When
\par   you look at the first example you should notice that the 1 ON statement
\par   replaces 4 IF...THEN... statements.
\par 
\par     EXAMPLES of ON Statement:
\par 
\par   ON -(A=7)-2*(A=3)-3*(A<3)-4*(A>7)GOTO 400,900,1000,100
\par   ON X GOTO 100,130,180,220
\par   ON X+3 GOSUB 9000,20,9000
\par   100 ON NUM GOTO 150,300,320,390
\par   500 ON SUM/2 + 1 GOSUB 50,80,20
\par 
\par   64   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par 
\par   OPEN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: I/O Statement
\par   FORMAT: OPEN <file-num>,[<device>][,<address>]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           [,"<File-name> [,<type>] [,<mode>]"]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: This statement OPENs a channel for input and/or output to a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  peripheral device. However, you may NOT need all those parts for every
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  OPEN statement. Some OPEN statements require only 2 codes:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) LOGICAL FILE NUMBER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) DEVICE NUMBER
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The <file-num> is the logical file number, which relates the OPEN,
\par   CLOSE, CMD, GET#, INPUT#, and PRINT# statements to each other and
\par   associates them with the file-name and the piece of equipment being used.
\par   The logical file number can range from 1 to 255 and you can assign it any
\par   number you want in that range.
\par 
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE: File numbers over 128 were really designed for other uses so    |
\par   | it's good practice to use only numbers below 127 for file numbers.    |
\par   +-----------------------------------------------------------------------+
\par 
\par 
\par     Each peripheral device (printer, disk drive, cassette) in the system
\par   has its own number which it answers to. The <device> number is used with
\par   OPEN to specify on which device the data file exists. Peripherals like
\par   cassette decks, disk drives or printers also answer to several secondary
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  addresses. Think of these as codes which tell each device what operation
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to perform. The device logical file number is used with every GET#,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INPUT#, and PRINT#.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    If the <device> number is left out the computer will automatically
\par   assume that you want your information to be sent to and received from
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the Datassette(TM), which is device number 1. The file-name can also be
\par   left out, but later on in your program, you can NOT call the file by name
\par   if you have not already given it one. When you are storing files on cas-
\par   sette tape, the computer will assume that the secondary <address> is
\par   zero (0) if you omit the secondary address (a READ operation).
\par 
\par 
\par 
\par                                              BASIC LANGUAGE VOCABULARY   65
\par \page 
\par 
\par 
\par     A secondary address value of one (1) OPENs cassette tape files for
\par   writing. A secondary address value of two (2) causes an end-of-tape
\par   marker to be written when the file is later closed. The end-of-tape
\par   marker prevents accidentally reading past the end of data which results
\par   in the BASIC error message ?DEVICE NOT PRESENT.
\par     For disk files, the secondary addresses 2 thru 14 are available for
\par   data-files, but other numbers have special meanings in DOS commands.
\par   You must use a secondary address when using your disk drive(s). (See
\par   your disk drive manual for DOS command details.)
\par     The <file-name> is a string of 1-16 characters and is optional for
\par   cassette or printer files. If the file <type> is left out the type of
\par   file will automatically default to the Program file unless the <mode> is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  given.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Sequential files are OPENed for reading <mode>=R unless you specify that
\par   files should be OPENed for writing <mode> =W is specified. A file <type>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  can be used to OPEN an existing Relative file. Use REL for <type> with
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Relative files. Relative and Sequential files are for disk only.
\par     If you try to access a file before it is OPENed the BASIC error message
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ?FILE NOT OPEN will occur. If you try to OPEN a file for reading which
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  does not exist the BASIC error message ?FILE NOT FOUND will occur. If
\par   a file is OPENed to disk for writing and the file-name already exists,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the DOS error message FILE EXISTS occurs. There is no check of this type
\par   available for tape files, so be sure that the tape is properly positioned
\par   or you might accidentally write over some data that had previously been
\par   SAVED. If a file is OPENed that is already OPEN, the BASIC error message
\par   FILE OPEN occurs. (See Printer Manual for further details.)
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   66   BASIC LANGUAGE VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES of OPEN Statements:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 OPEN 2,8,4,"DISK-OUTPUT,SEQ,W"  (Opens sequential file on disk)
\par 
\par     10 OPEN 1,1,2,"TAPE-WRITE"         (Write End-of-File on Close)
\par 
\par     10 OPEN 50,0                       (Keyboard input)
\par 
\par     10 OPEN 12,3                       (Screen output)
\par 
\par     10 OPEN 130,4                      (Printer output)
\par 
\par     10 OPEN 1,1,0,"NAME"               (Read from cassette)
\par 
\par     10 OPEN 1,1,1,"NAME"               (Write to cassette)
\par 
\par     10 OPEN 1,2,0,CHR$(10)             (open channel to RS-232 device)
\par 
\par     10 OPEN 1,4,0,"STRING"             (Send upper case/graphics to
\par                                         the printer)
\par 
\par     10 OPEN 1,4,7,"STRING"             (Send upper/lower case to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                        printer)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     10 OPEN 1,5,7,"STRING"             (Send upper/lower case to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                        printer with device # 5)
\par 
\par     10 OPEN 1,8,15,"COMMAND"           (Send a command to disk)
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                              BASIC LANGUAGE VOCABULARY   67
\par \page 
\par 
\par 
\par   OR
\par 
\par   TYPE: Logical Operator
\par   FORMAT: <operand> OR <operand>
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Action: Just as the relational operators can be used to make decisions
\par   regarding program flow, logical operators can connect two or more re-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  lations and return a true or false value which can then be used in a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  decision. When used in calculations, the logical OR gives you a bit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  result of I if the corresponding bit of either or both operands is 1.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  This will produce an integer as a result depending on the values of the
\par   operands. When used in comparisons the logical OR operator is also used
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to link two expressions into a single compound expression. If either of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the expressions are true, the combined expression value is true (-1). In
\par   the first example below if AA is equal to BB OR if XX is 20, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  expression is true.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Logical operators work by converting their operands to 16-bit, signed,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  two's complement integers in the range of -32768 to +32767. If the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  operands are not in the range an error message results. Each bit of the
\par   result is determined by the corresponding bits in the two operands.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES of OR Operator:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    100 IF (AA=BB) OR (XX=20) THEN...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     230 KK%=64 OR 32: PRINT KK%         (You typed this with a bit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                         value of 1000000 for 64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                         and 100000 for 32)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    96                                  (The computer responded with
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                         bit value 1100000.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                         1100000=96.)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  68   BASIC LANGUAGE VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PEEK
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Integer Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: PEEK(<numeric>)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: Returns an integer in the range of 0 to 255, which is read
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  from a memory location. The <numeric> expression is a memory location
\par   which must be in the range of 0 to 65535. If it isn't then the BASIC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  error message ?ILLEGAL QUANTITY occurs.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLES of PEEK Function:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 PRINT PEEK(53280) AND 15   (Returns value of screen border color)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    5 A%=PEEK(45)+PEEK(46)*256    (Returns address of BASIC variable table)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  POKE
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Statement
\par   FORMAT: POKE <location>,<value>
\par 
\par   Action: The POKE statement is used to write a one-byte (8-bits) binary
\par   value into a given memory location or input/output register. The
\par   <location> is an arithmetic expression which must equal a value in the
\par   range of 0 to 65535. The <value> is an expression which can be reduced to
\par   an integer value of 0 to 255. If either value is out of its respective
\par   range, the BASIC error message ?ILLEGAL QUANTITY occurs.
\par     The POKE statement and PEEK statement (which is a built-in function
\par   that looks at a memory location) are useful for data storage, controlling
\par   graphics displays or sound generation, loading assembly language sub-
\par   routines, and passing arguments and results to and from assembly language
\par   subroutines. In addition, Operating System parameters can be examined
\par   using PEEK statements or changed and manipulated using POKE statements.
\par   A complete memory map of useful locations is given in Appendix G.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                              BASIC LANGUAGE VOCABULARY   69
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLES of POKE Statement:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 1024, 1         (Puts an "A" at position 1 on the screen)
\par     POKE 2040, PTR       (Updates Sprite #0 data pointer)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 POKE RED,32
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 POKE 36879,8
\par     2050 POKE A,B
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   POS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Integer Function
\par   FORMAT: POS (<dummy>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: Tells you the current cursor position which, of course, is in
\par   the range of 0 (leftmost character) though position 79 on an 80-character
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  logical screen line. Since the Commodore 64 has a 40-column screen, any
\par   position from 40 through 79 will refer to the second screen line. The
\par   dummy argument is ignored.
\par 
\par   EXAMPLE of POS Function:
\par 
\par     1000 IF POS(0)>38 THEN PRINT CHR$(13)
\par 
\par 
\par   PRINT
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: PRINT [<variable>][<,/;><variable>]...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: The PRINT statement is normally used to write data items to
\par   the screen. However, the CMD statement may be used to re-direct that
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  output to any other device in the system. The <variable(s)> in the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  output-list are expressions of any type. If no output-list is present, a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  blank line is printed. The position of each printed item is determined by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the punctuation used to separate items in the output-list.
\par     The punctuation characters that you can use are blanks, commas, or
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  semicolons. The 80-character logical screen line is divided into 8 print
\par   zones of 10 spaces each. In the list of expressions, a comma causes the
\par   next value to be printed at the beginning of the next zone. A semicolon
\par   causes the next value to be printed immediately following the previous
\par   value. However, there are two exceptions to this rule:
\par 
\par   70   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par 
\par     1) Numeric items are followed by an added space.
\par     2) Positive numbers have a space preceding them.
\par 
\par     When you use blanks or no punctuation between string constants or
\par   variable names it has the same effect as a semicolon. However, blanks
\par   between a string and a numeric item or between two numeric items will
\par   stop output without printing the second item.
\par     If a comma or a semicolon is at the end of the output-list, the next
\par   PRINT statement begins printing on the same line, and spaced accord-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ingly. If no punctuation finishes the list, a carriage-return and a line-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  feed are printed at the end of the data. The next PRINT statement will
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  begin on the next line. If your output is directed to the screen and the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  data printed is longer than 40 columns, the output is continued on the
\par   next screen line.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    There is no statement in BASIC with more variety than the PRINT
\par   statement. There are so many symbols, functions, and parameters
\par   associated with this statement that it might almost be considered as a
\par   language of its own within BASIC; a language specially designed for
\par   writing on the screen.
\par 
\par   EXAMPLES of PRINT Statement:
\par 
\par   1)
\par      5 X = 5
\par     10 PRINT -5*X,X-5,X+5,X^5
\par 
\par     -25     0     10     3125
\par 
\par 
\par   2)
\par      5 X=9
\par     10 PRINT X;"SQUARED IS";X*X;"AND";
\par     20 PRINT X "CUBED IS" X^3
\par 
\par     9 SQUARED IS 81 AND 9 CUBED IS 729
\par 
\par 
\par   3)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     90 AA$="ALPHA":BB$="BAKER":CC$="CHARLIE":DD$="DOG":EE$="ECHO"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    100 PRINT AA$BB$;CC$ DD$,EE$
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     ALPHABAKERCHARLIEDOG     ECHO
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                             BASIC LANGUAGE VOCABULARY   71
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Quote Mode
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Once the quote mark <SHIFT+2> is typed, the cursor controls stop
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  operating and start displaying reversed characters which actually stand
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  for the cursor control you are hitting. This allows you to program these
\par   cursor controls, because once the text inside the quotes is PRINTed they
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  perform their functions. The <INST/DEL> key is the only cursor control
\par   not affected by "quote mode."
\par 
\par   1. Cursor Movement
\par 
\par     The cursor controls which can be "programmed" in quote mode are:
\par 
\par           KEY                             APPEARS AS
\par 
\par         <CLR/HOME>
\par         <SHIFT+CLR/HOME>
\par         <CRSR UP/DOWN>
\par         <SHIFT+CRSR UP/DOWN>
\par         <CRSR LEFT/RIGHT>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        <SHIFT+CRSR LEFT/RIGHT>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    If you wanted the word HELLO to PRINT diagonally from the upper left
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  corner of the screen, you would type:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PRINT"<HOME>H<DOWN>E<DOWN>L<DOWN>L<DOWN>O"
\par 
\par   2. Reverse Characters
\par 
\par     Holding down the <CTRL> key and hitting <9> will cause <R> to appear
\par   inside the quotes. This will make all characters start printing in
\par   reverse video (like a negative of a picture). To end the reverse printing
\par   hit <CTRL+0>, or else PRINT a <RETURN> (CHR$(13)). (Just ending the PRINT
\par   statement without a semicolon or comma will take care of this.)
\par 
\par   3.Color Controls
\par 
\par     Holding down the <CTRL> key or <C=> key with any of the 8 color keys
\par   will make a special reversed character appear in the quotes. When the
\par   character is PRINTed, then the color change will occur.
\par 
\par 
\par   72   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par 
\par       KEY           COLOR                APPEARS AS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   <CTRL+1>         Black
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   <CTRL+2>         White
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   <CTRL+3>         Red
\par    <CTRL+4>         Cyan
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   <CTRL+5>         Purple
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   <CTRL+6>         Green
\par    <CTRL+7>         Blue
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   <CTRL+8>         Yellow
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   <C=+1>           Orange
\par    <C=+2>           Brown
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   <C=+3>           Light Red
\par    <C=+4>           Grey 1
\par    <C=+5>           Grey 2
\par    <C=+6>           Light Green
\par    <C=+7>           Light Blue
\par    <C=+8>           Grey 3
\par 
\par 
\par 
\par     If you wanted to PRINT the word HELLO in cyan and the word THERE
\par   in white, type:
\par 
\par     PRINT "<CTRL+4>HELLO <CTRL+2>THERE"
\par 
\par 
\par   4. Insert Mode
\par 
\par     The spaces created by using the <INST/DEL> key have some of the same
\par   characteristics as quote mode. The cursor controls and color controls
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  show up as reversed characters. The only difference is in the <INST> and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  <DEL>, which performs its normal function even in quote mode, now
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                              BASIC LANGUAGE VOCABULARY   73
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  creates the <T>. And <INST>, which created a special character in quote
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  mode, inserts spaces normally.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Because of this, it is possible to create a PRINT statement containing
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  DELetes, which cannot be PRINTed in quote mode. Here is an example
\par   of how this is done:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 PRINT"HELLO"<DEL><INST><INST><DEL><DEL>P"
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When the above line is RUN, the word displayed will be HELP, because
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the last two letters are deleted and the P is put in their place.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | WARNING: The DELetes will work when LISTing as well as PRINTing, so   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | editing a line with these characters will be difficult.               |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The "insert mode" condition is ended when the <RETURN> (or
\par   <SHIFT+RETURN>) key is hit, or when as many characters have been typed as
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  spaces were inserted.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  5. Other Special Characters
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     There are some other characters that can be PRINTed for special
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  functions, although they are not easily available from the keyboard. In
\par   order to get these into quotes, you must leave empty spaces for them in
\par   the line, hit <RETURN> or <SHIFT+RETURN>, and go back to the spaces with
\par   the cursor controls. Now you must hit <RVS ON>, to start typing reversed
\par   characters, and type the keys shown below:
\par 
\par           Function                    Type               Appears As
\par 
\par     <SHIFT+RETURN>                    <SHIFT+M>
\par     switch to lower case              <N>
\par     switch to upper case              <SHIFT+N>
\par     disable case-switching keys       <H>
\par     enable case-switching keys        <I>
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  74   BASIC LANGUAGE VOCABULARY
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The <SHIFT+RETURN> will work in the LISTing as well as PRINTing, so
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  editing will be almost impossible if this character is used. The LISTing
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  will also look very strange.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   PRINT#
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: I/O Statement
\par   FORMAT: PRINT#<file-number>[<variable>][<,/;><variable>]...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Actions: The PRINT# statement is used to write data items to a logical
\par   file. It must use the same number used to OPEN the file. Output goes to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the device-number used in the OPEN statement. The <variable> expressions
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in the output-list can be of any type. The punctuation characters between
\par   items are the same as with the PRINT statement and they can be used in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the same ways. The effects of punctuation are different in two
\par   significant respects.
\par     When PRINT# is used with tape files, the comma, instead of spacing
\par   by print zones, has the same effect as a semicolon. Therefore, whether
\par   blanks, commas, semicolons or no punctuation characters are used between
\par   data items, the effect on spacing is the same. The data items are written
\par   as a continuous stream of characters. Numeric items are followed by a
\par   space and, if positive, are preceded by a space.
\par     If no punctuation finishes the list, a carriage-return and a line-feed
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  are written at the end of the data. If a comma or semicolon terminates
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the output-list, the carriage-return and line-feed are suppressed. Re-
\par   gardless of the punctuation, the next PRINT# statement begins output in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the next available character position. The line-feed will act as a stop
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  when using the INPUT# statement, leaving an empty variable when the next
\par   INPUT# is executed. The line-feed can be suppressed or compensated for as
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  shown in the examples below.
\par     The easiest way to write more than one variable to a file on tape or
\par   disk is to set a string variable to CHR$(13), and use that string in be-
\par   tween all the other variables when writing the file.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                              BASIC LANGUAGE VOCABULARY   75
\par \page 
\par 
\par 
\par   EXAMPLES of PRINT# Statement:
\par 
\par 
\par   1)
\par 
\par     10 OPEN 1,1,1,"TAPE FILE"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 R$=CHR$(13)                      (By Changing the CHR$(13) to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 PRINT#1,1;R$;2;R$;3;R$;4;R$;5     CHR$(44) you put a "," between
\par     40 PRINT#1,6                         each variable. CHR$(59) would
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    50 PRINT# 1,7                        put a ";" between each variable.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  2)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     10 CO$=CHR$(44):CR$=CHR$(13)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 PRINT#1,"AAA"CO$"BBB",           AAA,BBB     CCCDDDEEE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       "CCC";"DDD";"EEE"CR$             (carriage return)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       "FFF"CR$;                        FFF(carriage return)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 INPUT#1,A$,BCDE$,F$
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  3)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par      5 CR$=CHR$(13)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 PRINT#2,"AAA";CR$;"BBB"          (10 blanks) AAA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 PRINT#2,"CCC";                   BBB
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                        (10 blanks)CCC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 INPUT#2,A$,B$,DUMMY$,C$
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  READ
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: READ <variable>[,<variable>]...
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: The READ statement is used to fill variable names from con-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  stants in DATA statements. The data actually read must agree with the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  variable types specified or the BASIC error message ?SYNTAX ERROR will
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  result.(*) Variables in the DATA input-list must be separated by commas.
\par     A single READ statement can access one or more DATA statements,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  which will be accessed in order (see DATA), or several READ statements
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  can access the same DATA statement. If more READ statements are executed
\par   than the number of elements in DATA statements(s) in the program, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  76   BASIC LANGUAGE VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BASIC error message ?OUT OF DATA is printed. If the number of variables
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  specified is fewer than the number of elements in the DATA statement(s),
\par   subsequent READ statements will continue reading at the next data
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  element. (See RESTORE.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | *NOTE: The ?SYNTAX ERROR will appear with the line number from the    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | DATA statement, NOT the READ statement.                               |
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES of READ Statement:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    110 READ A,B,C$
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    120 DATA 1,2,HELLO
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    100 FOR X=1 TO 10: READ A(X):NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    200 DATA 3.08, 5.19, 3.12, 3.98, 4.24
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    210 DATA 5.08, 5.55, 4.00, 3.16, 3.37
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    (Fills array items (line 1) in order of constants shown (line 5))
\par 
\par     1 READ CITY$,STATE$,ZIP
\par     5 DATA DENVER,COLORADO, 80211
\par 
\par 
\par   REM
\par 
\par   TYPE: Statement
\par   FORMAT: REM [<remark>]
\par 
\par     Action:The REM statement makes your programs more easily understood
\par   when LISTed. It's a reminder to yourself to tell you what you had in
\par   mind when you were writing each section of the program. For instance,
\par   you might want to remember what a variable is used for, or some other
\par   useful information. The REMark can be any text, word, or character
\par   including the colon (:) or BASIC keywords.
\par     The REM statement and anything following it on the same line-number
\par   are ignored by BASIC, but REMarks are printed exactly as entered when
\par   the program is listed. A REM statement can be referred to by a GOTO or
\par   GOSUB statement, and the execution of the program will continue with
\par   the next higher program line having executable statements.
\par 
\par                                              BASIC LANGUAGE VOCABULARY   77
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES of REM Statement:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 REM CALCULATE AVERAGE VELOCITY
\par     20 FOR X= 1 TO 20 :REM LOOP FOR TWENTY VALUES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 SUM=SUM + VEL(X): NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    40 AVG=SUM/20
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   RESTORE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Statement
\par   FORMAT: RESTORE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: BASIC maintains an internal pointer to the next DATA constant
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to be READ. This pointer can be reset to the first DATA constant in a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  program using the RESTORE statement. The RESTORE statement can be
\par   used anywhere in the program to begin re-READing DATA.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLES of RESTORE Statement:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    100 FOR X=1 TO 10: READ A(X): NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    200 RESTORE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    300 FOR Y=1 TO 10: READ B(Y): NEXT
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    4000 DATA 3.08, 5.19, 3.12, 3.98, 4.24
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    4100 DATA 5.08, 5.55, 4.00, 3.16, 3.37
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     (Fills the two arrays with identical data)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 DATA 1,2,3,4
\par     20 DATA 5,6,7,8
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 FOR L= 1 TO 8
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    40 READ A: PRINT A
\par     50 NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    60 RESTORE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    70 FOR L= 1 TO 8
\par     80 READ A: PRINT A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    90 NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  78   BASIC LANGUAGE VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RETURN
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: RETURN
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: The RETURN statement is used to exit from a subroutine called
\par   for by a GOSUB statement. RETURN restarts the rest of your program at
\par   the next executable statement following the GOSUB. If you are nesting
\par   subroutines, each GOSUB must be paired with at least one RETURN
\par   statement. A subroutine can contain any number of RETURN statements,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  but the first one encountered will exit the subroutine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLE of RETURN Statement:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 PRINT"THIS IS THE PROGRAM"
\par     20 GOSUB 1000
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 PRINT"PROGRAM CONTINUES"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    40 GOSUB 1000
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    50 PRINT"MORE PROGRAM"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    60 END
\par     1000 PRINT"THIS IS THE GOSUB":RETURN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   RIGHT$
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: String Function
\par   FORMAT: RIGHT$ (<string>,<numeric>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: The RIGHT$ function returns a sub-string taken from the right-
\par   most end of the <string> argument. The length of the sub-string is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  defined by the <numeric> argument which can be any integer in the range
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of 0 to 255. If the value of the numeric expression is zero, then a null
\par   string ("") is returned. If the value you give in the <numeric> argument
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is greater than the length of the <string> then the entire string is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  returned.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE of RIGHT$ Function:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     10 MSG$="COMMODORE COMPUTERS"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 PRINT RIGHT$(MSG$,9)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    RUN
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    COMPUTERS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                             BASIC LANGUAGE VOCABULARY   79
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RND
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Floating-Point Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: RND (<numeric>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: RND creates a floating-point random from 0.0 to 1.0. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  computer generates a sequence of random numbers by performing cal-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  culations on a starting number, which in computer jargon is called a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  seed. The RND function is seeded on system power-up. The <numeric>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  argument is a dummy, except for its sign (positive, zero, or negative).
\par     If the <numeric> argument is positive, the same "pseudorandom"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sequence of numbers is returned, starting from a given seed value. Dif-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ferent number sequences will result from different seeds, but any se-
\par   quence is repeatable by starting from the same seed number. Having a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  known sequence of "random" numbers is useful in testing programs.
\par     If you choose a <numeric> argument of zero, then RND generates a
\par   number directly from a free-running hardware clock (the system "jiffy
\par   clock"). Negative arguments cause the RND function to be re-seeded
\par   with each function call.
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES of RND Function:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     220 PRINT INT(RND(0)*50)               (Return random integers 0-49)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    100 X=INT(RND(1)*6)+INT(RND(1)*6)+2    (Simulates 2 dice)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    100 X=INT(RND(1)*1000)+1               (Random integers from 1-1000)
\par 
\par     100 X=INT(RND(1)*150)+100              (Random numbers from 100-249)
\par 
\par     100 X=RND(1)*(U-L)+L                   (Random numbers between
\par                                             upper (U) and lower (L) limits)
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   80   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par 
\par   RUN
\par 
\par   TYPE: Command
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: RUN [<line-number>]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: The system command RUN is used to start the program currently
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in memory. The RUN command causes an implied CLR operation to be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  performed before starting the program. You can avoid the CLeaRing
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  operation by using CONT or GOTO to restart a program instead of RUN. If
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a <line-number> is specified, your program will start on that line.
\par   Otherwise, the RUN command starts at first line of the program. The RUN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  command can also be used within a program. If the <line-number> you
\par   specify doesn't exist, the BASIC error message UNDEF'D STATEMENT occurs.
\par     A RUNning program stops and BASIC returns to direct mode when an END or
\par   STOP statement is reached, when the last line of the program is finished,
\par   or when a BASIC error occurs during execution.
\par 
\par   EXAMPLES of RUN Command:
\par 
\par     RUN           (Starts at first line of program)
\par 
\par     RUN 500       (Starts at line-number 500)
\par     RUN X         (Starts at line X, or UNDEF'D STATEMENT ERROR
\par                    if there is no line X)
\par 
\par 
\par   SAVE
\par 
\par   TYPE: Command
\par   FORMAT: SAVE ["<file-name>"][,<device-number>][,<address>]
\par 
\par     Action: The SAVE command is used to store the program that is cur-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  rently in memory onto a tape or diskette file. The program being SAVED
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is only affected by the command while the SAVE is happening. The program
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  remains in the current computer memory even after the SAVE operation is
\par   completed until you put something else there by using another command.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The file type will be "prg" (program). If the <device-number> is left
\par   out, then the C64 will automatically assume that you want the program
\par   saved on cassette, device number 1. If the <device-number> is an <8>,
\par   then the program is written onto disk. The SAVE statement can be used
\par 
\par 
\par 
\par                                              BASIC LANGUAGE VOCABULARY   81
\par \page 
\par 
\par 
\par   be used in your programs and execution will continue with the next
\par   statement after the SAVE is completed.
\par     Programs on tape are automatically stored twice, so that your Com-
\par   modore 64 can check for errors when LOADing the program back in. When
\par   saving programs to tape, the <file-name> and secondary <address> are
\par   optional. But following a SAVE with a program name in quotes ("") or
\par   by a string variable (---$) helps your Commodore 64 find each program
\par   more easily. If the file-name is left out it can NOT be LOADed by name
\par   later on.
\par     A secondary address of I will tell the KERNAL to LOAD the tape at a
\par   later time, with the program currently in memory instead of the normal
\par   2048 location. A secondary address of 2 will cause an end-of-tape marker
\par   to follow the program. A secondary address of 3 combines both functions.
\par     When saving programs onto a disk, the <file-name> must be present.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLES of SAVE Command.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    SAVE               (Write to tape without a name)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    SAVE"ALPHA",1      (Store on tape as file-name "alpha")
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     SAVE"ALPHA",1,2    (Store "alpha" with end-of-tape marker)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    SAVE"FUN.DISK",8   (SAVES on disk (device 8 is the disk))
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    SAVE A$            (Store on tape with the name A$)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 SAVE"HI"        (SAVEs program and then move to next program line)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     SAVE"ME",1,3       (Stores at same memory location and puts an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        end-of-tope marker on)
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  82   BASIC LANGUAGE VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SGN
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Integer Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: SGN (<numeric>)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: SGN gives you an integer value depending upon the sign of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  <numeric> argument. If the argument is positive the result is 1, if zero
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the result is also 0, if negative the result is -1.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLE of SGN Function:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    90 ON SGN(DV)+2 GOTO 100, 200, 300
\par     (jump to 100 if DV=negative, 200 if DV=0, 300 if DV=positive)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SIN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Floating-Point Function
\par   FORMAT: SIN (<numeric>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: SIN gives you the sine of the <numeric> argument, in radians.
\par   The value of COS(X) is equal to SIN(x+3.14159265/2).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE of SIN Function:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    235 AA=SIN(1.5):PRINT AA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     .997494987
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SPC
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: String Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: SPC (<numeric>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: The SPC function is used to control the formatting of data, as
\par   either an output to the screen or into a logical file. The number of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SPaCes given by the <numeric> argument are printed, starting at the first
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  available position. For screen or tape files the value of the argument
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is in the range of 0 to 255 and for disk files up to 254. For printer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  files, an automatic carriage-return and line-feed will be performed by
\par   the printer if a SPaCe is printed in the last character position of a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  line. No SPaCes are printed on the following line.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                              BASIC LANGUAGE VOCABULARY   83
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE of SPC Function:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     10 PRINT"RIGHT "; "HERE &";
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 PRINT SPC(5)"OVER" SPC(14)"THERE"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    RUN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    RIGHT HERE &     OVER              THERE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SQR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Floating-Point Function
\par   FORMAT: SQR (<numeric>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: SQR gives you the value of the SQuare Root of the <numeric>
\par   argument. The value of the argument must not be negative, or the BASIC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  error message ?ILLEGAL QUANTITY will happen.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLE of SQR Function:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    FOR J = 2 TO 5: PRINT J*S, SQR(J*5): NEXT
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10   3.16227766
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    15   3.87298335
\par     20   4.47213595
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    25   5
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     READY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STATUS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Integer Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: STATUS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: Returns a completion STATUS for the last input/output operation
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  which was performed on an open file. The STATUS can be read from any
\par   peripheral device. The STATUS (or simply ST) keyword is a system defined
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  84   BASIC LANGUAGE VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  variable-name into which the KERNAL puts the STATUS of I/O operations.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  A table of STATUS code values for tape, printer, disk and RS-232 file
\par   operations is shown below:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+------------+---------------+------------+-------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  ST Bit | ST Numeric |    Cassette   |   Serial   |    Tape Verify    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Position|    Value   |      Read     |  Bus R/W   |      + Load       |
\par   +---------+------------+---------------+------------+-------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    0    |      1     |               |  time out  |                   |
\par   |         |            |               |  write     |                   |
\par   +---------+------------+---------------+------------+-------------------+
\par   |    1    |      2     |               |  time out  |                   |
\par   |         |            |               |    read    |                   |
\par   +---------+------------+---------------+------------+-------------------+
\par   |    2    |      4     |  short block  |            |    short block    |
\par   +---------+------------+---------------+------------+-------------------+
\par   |    3    |      8     |   long block  |            |    long block     |
\par   +---------+------------+---------------+------------+-------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    4    |     16     | unrecoverable |            |   any mismatch    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         |            |   read error  |            |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+------------+---------------+------------+-------------------+
\par   |    5    |     32     |    checksum   |            |     checksum      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         |            |     error     |            |       error       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+------------+---------------+------------+-------------------+
\par   |    6    |     64     |  end of file  |     EOI    |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+------------+---------------+------------+-------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    7    |   -128     |  end of tape  | device not |    end of tape    |
\par   |         |            |               |   present  |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+------------+---------------+------------+-------------------+
\par 
\par   EXAMPLES of STATUS Function:
\par 
\par     10 OPEN 1,4:OPEN 2,8,4,"MASTER FILE,SEQ,W"
\par     20 GOSUB 100:REM CHECK STATUS
\par     30 INPUT#2,A$,B,C
\par     40 IF STATUS AND 64 THEN 80:REM HANDLE END-OF-FILE
\par     50 GOSUB 100:REM CHECK STATUS
\par     60 PRINT#1,A$,B;C
\par     70 GOTO 20
\par     80 CLOSE1:CLOSE2
\par     90 GOSUB 100:END
\par     100 IF ST > 0 THEN 9000:REM HANDLE FILE I/O ERROR
\par     110 RETURN
\par                                              BASIC LANGUAGE VOCABULARY   85
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STEP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: [STEP <expression>]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: The optional STEP keyword follows the <end-value> expression in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a FOR statement. It defines an increment value for the loop counter
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  variable. Any value can be used as the STEP increment. Of course, a STEP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  value of zero will loop forever. If the STEP keyword is left out, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  increment value will be + 1. When the NEXT statement in a FOR loop is
\par   reached, the STEP increment happens. Then the counter is tested against
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the end-value to see if the loop is finished. (See FOR statement for more
\par   information.)
\par   +-----------------------------------------------------------------------+
\par   | NOTE: The STEP value can NOT be changed once it's in the loop.        |
\par   +-----------------------------------------------------------------------+
\par   EXAMPLES of STEP Statement:
\par 
\par     25 FOR XX=2 TO 20 STEP 2             (Loop repeats 10 times)
\par     35 FOR ZZ=0 TO -20 STEP -2           (Loop repeats 11 times)
\par 
\par   STOP
\par 
\par   TYPE: Statement
\par   FORMAT: STOP
\par 
\par     Action: The STOP statement is used to halt execution of the current
\par   program and return to direct mode. Typing the <RUN/STOP> key on the
\par   keyboard has the same effect as a STOP statement. The BASIC error message
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ?BREAK IN LINE nnnnn is displayed on the screen, followed by READY. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  "nnnnn" is the line-number where the STOP occurs. Any open files remain
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  open and all variables are preserved and can be examined. The program can
\par   be restarted by using CONT or GOTO statements.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES of STOP Statement:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 INPUT#1,AA,BB,CC
\par     20 IF AA=BB AND BB=CC THEN STOP
\par     30 STOP
\par                     (If the variable AA is -1 and BB is equal to CC then:)
\par   BREAK IN LINE 20
\par   BREAK IN LINE 30        (For any other data values)
\par 
\par   86   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par 
\par   STR$
\par 
\par   TYPE: String Function
\par   FORMAT: STR$ (<numeric>)
\par 
\par     Action: STR$ gives you the STRing representation of the numeric value
\par   of the argument. When the STR$ value is converted to each variable
\par   represented in the <numeric> argument, any number shown is followed by
\par   a space and, if it's positive, it is also preceded by a space.
\par 
\par   EXAMPLE of STR$ Function:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    100 FLT = 1.5E4: ALPHA$ = STR$(FLT)
\par     110 PRINT FLT, ALPHA$
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    15000     15000
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SYS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Statement
\par   FORMAT: SYS <memory-location>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: This is the most common way to mix a BASIC program with a
\par   machine language program. The machine language program begins at the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  location given in the SYS statement. The system command SYS is used in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  either direct or program mode to transfer control of the microprocessor
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to an existing machine language program in memory. The memory-location
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  given is by numeric expression and can be anywhere in memory, RAM or ROM.
\par     When you're using the SYS statement you must end that section of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  machine language code with an RTS (ReTurn from Subroutine) instruction
\par   so that when the machine language program is finished, the BASIC
\par   execution will resume with the  statement following the SYS command.
\par 
\par   EXAMPLES of SYS Statement:
\par 
\par     SYS 64738                      (Jump to System Cold Start in ROM)
\par 
\par     10 POKE 4400,96:SYS 4400       (Goes to machine code location 4400
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                    and returns immediately)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                             BASIC LANGUAGE VOCABULARY   87
\par \page 
\par 
\par 
\par   TAB
\par 
\par   TYPE: String Function
\par   FORMAT: TAB (<numeric>)
\par 
\par     Action: The TAB function moves the cursor to a relative SPC move
\par   position on the screen given by the <numeric> argument, starting with
\par   the left-most position of the current line. The value of the argument can
\par   range from 0 to 255. The TAB function should only be used with the PRINT
\par   statement, since it has no effect if used with PRINT# to a logical
\par   file.
\par 
\par   EXAMPLE of TAB Function:
\par 
\par     100 PRINT"NAME" TAB(25) "AMOUNT": PRINT
\par     110 INPUT#1, NAM$, AMT$
\par     120 PRINT NAM$ TAB(25) AMT$
\par 
\par     NAME                         AMOUNT
\par 
\par 
\par     G.T. JONES                   25.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TAN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Floating-Point Function
\par   FORMAT: TAN (<numeric>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: Returns the tangent of the value of the <numeric> expression
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in radians. If the TAN function overflows, the BASIC error message
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ?DIVISION BY ZERO is displayed.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE of TAN Function:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     10 XX=.785398163: YY=TAN(XX):PRINT YY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     1
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  88   BASIC LANGUAGE VOCABULARY
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TIME
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Numeric Function
\par   FORMAT: TI
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: The TI function reads the interval Timer. This type of "clock"
\par   is called a "jiffy clock." The "jiffy clock" value is set at zero
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (initialized) when you power-up the system. This 1/60 second interval
\par   timer is turned off during tape I/O.
\par 
\par   EXAMPLE of TI Function:
\par 
\par   10 PRINT TI/60 "SECONDS SINCE POWER UP"
\par 
\par 
\par   TIME$
\par 
\par   TYPE: String Function
\par   FORMAT: TI$
\par 
\par     Action: The TI$ timer looks and works like a real clock as long as your
\par   system is powered-on. The hardware interval timer (or jiffy clock) is
\par   read and used to update the value of TI$, which will give you a TIme
\par   $tring of six characters in hours, minutes and seconds. The TI$ timer can
\par   also be assigned an arbitrary starting point similar to the way you set
\par   your wristwatch. The value of TI$ is not accurate after tape I/O.
\par 
\par   EXAMPLE of TI$ Function:
\par 
\par     1 TI$ = "000000": FOR J=1 TO 10000: NEXT: PRINT TI$
\par 
\par     000011
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                             BASIC LANGUAGE VOCABULARY   89
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  USR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Floating-Point Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: USR (<numeric>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: The USR function jumps to a User callable machine language
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SubRoutine which has its starting address pointed to by the contents of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  memory locations 785-786. The starting address is established before
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  calling the USR function by using POKE statements to set up locations
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  785-786. Unless POKE statements are used, locations 785-786 will give
\par   you an ?ILLEGAL QUANTITY error message.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The value of the <numeric> argument is stored in the floating-point
\par   accumulator starting at location 97, for access by the Assembler code,
\par   and the result of the USR function is the value which ends up there when
\par   the subroutine returns to BASIC.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLES of USR Function:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 B=T*SIN(Y)
\par     20 C=USR(B/2)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 D=USR(B/3)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VAL
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TYPE: Numeric Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: VAL (<string>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Action: Returns a numeric VALue representing the data in the <string>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  argument. If the first non-blank character of the string is not a plus
\par   sign (+), minus sign (-), or a digit the VALue returned is zero. String
\par   conversion is finished when the end of the string or any non-digit
\par   character is found (except decimal point or exponential e).
\par 
\par   EXAMPLE of VAL Function:
\par 
\par     10 INPUT#1, NAM$, ZIP$
\par     20 IF VAL(ZIP$) < 19400 OR VAL(ZIP$) > 96699
\par        THEN PRINT NAM$ TAB(25) "GREATER PHILADELPHIA"
\par 
\par 
\par 
\par 
\par   90   BASIC LANGUAGE VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VERIFY
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Command
\par   FORMAT: VERIFY ["<file-name>"][,<device>]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Action: The VERIFY command is used, in direct or program mode, to compare
\par   the contents of a BASIC program file on tape or disk with the program
\par   currently in memory. VERIFY is normally used right after a SAVE, to make
\par   sure that the program was stored correctly on tape or disk.
\par     If the <device> number is left out, the program is assumed to be on
\par   the Datassette(TM) which is device number 1. For tape files, if the
\par   <file-name> is left out, the next program found on the tape will be com-
\par   pared. For disk files (device number 8), the file-name must be present.
\par   If any differences in program text are found, the BASIC error message
\par   ?VERIFY ERROR is displayed.
\par     A program name can be given either in quotes or as a string variable.
\par   VERIFY is also used to position a tape just past the last program, so
\par   that a new program can be added to the tape without accidentally writing
\par   over another program.
\par 
\par 
\par   EXAMPLES of VERIFY Command:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    VERIFY                      (Checks 1st program on tape)
\par     PRESS PLAY ON TAPE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    OK
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    SEARCHING
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    FOUND <FILENAME>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    VERIFYING
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    9000 SAVE "ME",8:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    9010 VERIFY "ME",8          (Looks at device 8 for the program)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                             BASIC LANGUAGE VOCABULARY   91
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  WAIT
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYPE: Statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORMAT: WAIT <location>,<mask-1>[,<mask-2>]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Action: The WAIT statement causes program execution to be suspended
\par   until a given memory address recognizes a specified bit pattern. In other
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  words WAIT can be used to halt the program until some external event has
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  occurred. This is done by monitoring the status of bits in the input/
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  output registers, The data items used with WAIT can be any numeric
\par   expressions, but they will be converted to integer values. For most
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  programmers, this statement should never be used. It causes the program
\par   to halt until a specific memory location's bits change in a specific way.
\par   This is used for certain I/O operations and almost nothing else.
\par     The WAIT statement takes the value in the memory location and performs
\par   a logical AND operation with the value in mask-1. If there is a mask-2 in
\par   the statement, the result of the first operation is exclusive-ORed with
\par   mask-2. In other words mask-1 "filters out" any bits that you don't want
\par   to test. Where the bit is 0 in mask-1, the corresponding bit in the
\par   result will always be 0. The mask-2 value flips any bits, so that you
\par   can test for an off condition as well as an on condition, Any bits being
\par   tested for a 0 should have a I in the corresponding position in mask-2.
\par     If corresponding bits of the <mask-1> and <mask-2> operands differ, the
\par   exclusive-OR operation gives a bit result of 1. If corresponding bits get
\par   the same result the bit is 0. It is possible to enter an infinite pause
\par   with the WAIT statement, in which case the <RUN/STOP> and <RESTORE> keys
\par   can be used to recover. Hold down the <RUN/STOP> key and then press
\par   <RESTORE>. The first example below WAITs until a key is pressed on the
\par   tape unit to continue with the program. The second example will WAIT
\par   until a sprite collides with the screen background.
\par 
\par 
\par   EXAMPLES of WAIT Statement:
\par 
\par     WAIT 1,32,32
\par     WAIT 53273,6,6
\par     WAIT 36868,144,16         (144 & 16 are masks. 144=10010000 in binary
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                               and 16=10000 in binary. The WAIT statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                               will halt the program until the 128 bit is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                               on or until the 16 bit is off)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   92   BASIC LANGUAGE VOCABULARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  THE COMMODORE 64 KEYBOARD
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  AND FEATURES
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The Operating System has a ton-character keyboard "buffer" that is used
\par   to hold incoming keystrokes until they can be processed. This buffer, or
\par   queue, holds keystrokes in the order in which they occur so that the
\par   first one put into the queue is the first one processed. For example, if
\par   a second keystroke occurs before the first can be processed, the second
\par   character Is stored in the buffer, while processing of the first
\par   character continues. After the program has finished with the first
\par   character, the keyboard buffer is examined for more data, and the second
\par   keystroke processed. Without this buffer, rapid keyboard input would
\par   occasionally drop characters.
\par     In other words, the keyboard buffer allows you to "type-ahead" of the
\par   system, which means it can anticipate responses to INPUT prompts or GET
\par   statements. As you type on the keys their character values are lined up,
\par   single-file (queued) into the buffer to wait for processing in the order
\par   the keys were struck. This type-ahead feature can give you an occasional
\par   problem where an accidental keystroke causes a program to fetch an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  incorrect character from the buffer.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Normally, incorrect keystrokes present no problem, since they can be
\par   corrected by the CuRSoR-Left <CRSR LEFT> or DELete <INST/DEL> keys and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  then retyping the character, and the corrections will be processed before
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a following carriage-return. However, if you press the <RETURN> key, no
\par   corrective action is possible, since all characters in the buffer up to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and including the carriage-return will be processed before any cor-
\par   rections. This situation can be avoided by using a loop to empty the
\par   keyboard buffer before reading an intended response:
\par 
\par     10 GET JUNK$: IF JUNK$ <>"" THEN 10: REM EMPTY THE KEYBOARD BUFFER
\par 
\par     In addition to GET and INPUT, the keyboard can also be read using
\par   PEEK to fetch from memory location 197 ($00C5) the integer value of the
\par   key currently being pressed. If no key Is being held when the PEEK is
\par   executed, a value of 64 is returned, The numeric keyboard values,
\par   keyboard symbols and character equivalents (CHR$) are shown in Ap-
\par   pendix C. The following example loops until a key is pressed then con-
\par   verts the integer to a character value.
\par 
\par     10 AA=PEEK(197): IF AA=64 THEN 10
\par     20 BB$=CHR$(AA)
\par 
\par 
\par                                              BASIC LANGUAGE VOCABULARY   93
\par \page 
\par 
\par 
\par     The keyboard is treated as a set of switches organized into a matrix
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of 8 columns by 8 rows. The keyboard matrix is scanned for key switch-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  closures by the KERNAL using the CIA #l 1/0 chip (MOS 6526 Complex
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Interface Adapter). Two CIA registers are used to perform the scan:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  register #0 at location 56320 ($DC00) for keyboard columns and
\par   register #l at location 56321 ($DC01) for keyboard rows.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Bits 0-7 of memory location 56320 correspond to the columns 0-7. Bits
\par   0-7 of memory location 56321 correspond to rows 0-7. By writing column
\par   values in sequence, then reading row values, the KERNAL decodes the
\par   switch closures into the CHR$ (N) value of the key pressed.
\par     Eight columns by eight rows yields 64 possible values. However, if you
\par   first strike the <RVS ON>, <CTRL> or <C=> keys or hold down the <SHIFT>
\par   key and type a second character, additional values are generated. This is
\par   because the KERNAL decodes these keys separately and "remembers" when one
\par   of the control keys was pressed. The result of the keyboard scan is then
\par   placed in location 197.
\par     Characters can also be written directly to the keyboard buffer at lo-
\par   cations 631-640 using a POKE statement. These characters will be
\par   processed when the POKE is used to set a character count into location
\par   198. These facts can be used to cause a series of direct-mode commands to
\par   be executed automatically by printing the statements onto the screen,
\par   putting carriage-returns into the buffer, and then setting the character
\par   count. In the example below, the program will LIST itself to the printer
\par   and then resume execution.
\par 
\par     10 PRINT CHR$(147)"PRINT#1: CLOSE 1: GOTO 50"
\par     20 POKE 631119: POKE 632,13: POKE 633,13: POKE 198,3
\par     30 OPEN 114: CMD1: LIST
\par     40 END
\par     50 REM PROGRAM RE-STARTS HERE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SCREEN EDITOR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The SCREEN EDITOR provides you with powerful and convenient facilities
\par   for editing program text. Once a section of a program is listed to the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  screen, the cursor keys and other special keys are used to move around
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the screen so that you can make any appropriate changes. After making all
\par   the changes you want to a specific line-number of text, hitting the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  <RETURN> key anywhere on the line, causes the SCREEN EDITOR to read the
\par   entire 80-character logical screen line.
\par 
\par 
\par   94   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par 
\par     The text is then passed to the Interpreter to be tokenized and stored
\par   in the program. The edited line replaces the old version of that line in
\par   memory. An additional copy of any line of text can be created simply by
\par   changing the line-number and pressing <RETURN>.
\par     If you use keyword abbreviations which cause a program line to exceed
\par   80 characters, the excess characters will be lost when that line is
\par   edited, because the EDITOR will read only two physical screen lines. This
\par   is also why using INPUT for more than a total of 80 characters is not
\par   possible. Thus, for all practical purposes, the length of a line of BASIC
\par   text is limited to 80 characters as displayed on the screen.
\par     Under certain conditions the SCREEN EDITOR treats the cursor control
\par   keys differently from their normal mode of handling. If the CuRSoR is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  positioned to the right of an odd number of double-quote marks (") the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EDITOR operates in what is known as the QUOTE-MODE.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    In quote mode data characters are entered normally but the cursor
\par   controls no longer move the CuRSoR, instead reversed characters are
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  displayed which actually stand for the cursor control being entered. The
\par   same is true of the color control keys. This allows you to include cursor
\par   and color controls inside string data items in programs. You will find
\par   that this is a very important and powerful feature. That's because when
\par   the text inside the quotes is printed to the screen it performs the
\par   cursor positioning and color control functions automatically as part of
\par   the string. An example of using cursor controls in strings is:
\par 
\par 
\par 
\par     You type -->         10 PRINT"A(R)(R)B(L)(L)(L)C(R)(R)D": REM(R)=CRSR
\par                             RIGHT, (L)=CRSR LEFT
\par 
\par     Computer prints -->  AC BD
\par 
\par 
\par      The <DEL> key is the only cursor control NOT affected by quote mode.
\par    Therefore, if an error is made while keying in quote mode, the
\par    <CRSR LEFT> key can't be used to back up and strike over the error -
\par    even the <INST> key produces a reverse video character. Instead, finish
\par    entering the line, and then, after hitting the <RETURN> key, you can
\par    edit the line normally. Another alternative, if no further cursor-
\par    controls are needed in the string, is to press the <RUN/STOP> and
\par    <RESTORE> keys which will cancel QUOTE MODE. The cursor control keys
\par    that you can use in strings are shown in Table 2-2.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                              BASIC LANGUAGE VOCABULARY   95
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {             Table 2-2. Cursor Control Characters in QUOTE MODE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------------------------------------------------------------------------
\par                   Control Key                      Appearance
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------------------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par               CRSR up
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              CRSR down
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              CRSR left
\par               CRSR right
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              CLR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              HOME
\par               INST
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------------------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When you are NOT in quote mode, holding down the <SHIFT> key and then
\par   pressing the INSerT <INST> key shifts data to the right of the cursor to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  open up space between two characters for entering data between them. The
\par   Editor then begins operating in INSERT MODE until all of the space opened
\par   up is filled.
\par     The cursor controls and color controls again show as reversed char-
\par   acters in insert mode. The only difference occurs on the DELete and
\par   INSerT <INST/DEL> key. The <DEL> instead of operating normally as in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the quote mode, now creates the reversed <T>. The <INST> key, which
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  created a reverse character in quote mode, inserts spaces normally.
\par     This means that a PRINT statement can be created, containing DELetes,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  which can't be done in quote mode. The insert mode is cancelled by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  pressing the <RETURN>, <SHIFT> and <RETURN>, or <RUN/STOP> and <RESTORE>
\par   keys. Or you can cancel the insert mode by filling all the inserted
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  spaces. An example of using DEL characters in strings is:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     10 PRINT"HELLO"<DEL><INST><INST><DEL><DEL>P"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   (Keystroke sequence shown above, appearance when listed below)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   10 PRINT"HELP"
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When the example is RUN, the word displayed will be HELP, because the
\par   letters LO are deleted before the P is printed. The DELete character in
\par   strings will work with LIST as well as PRINT. You can use this to "hide"
\par   part or all of a line of text using this technique. However, trying to
\par   edit a line with these characters will be difficult if not impossible.
\par 
\par 
\par 
\par   96   BASIC LANGUAGE VOCABULARY
\par \page 
\par 
\par 
\par     There are some other characters that can be printed for special func-
\par   tions, although they are not easily available from the keyboard. In order
\par   to get these into quotes, you must leave empty spaces for them in the
\par   line, press <RETURN>, and go back to edit the line. Now you hold down
\par   the <CTRL> (ConTRoL) key and type <RVS ON> (ReVerSe-ON) to start typing
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  reversed characters. Type the keys as shown below:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Key Function                Key Entered         Appearance
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Shifted RETURN              <SHIFT+M>
\par     Switch to upper/lower case  <N>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Switch to upper/graphics    <SHIFT+N>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Holding down the <SHIFT> key and hitting <RETURN> causes a carriage-
\par   return and line-feed on the screen but does not end the string. This
\par   works with LIST as well as PRINT, so editing will be almost impossible if
\par   this character is used. When output is switched to the printer via the
\par   CMD statement, the reverse "N" character shifts the printer into its
\par   upper-lower case character set and the <SHIFT> "N" shifts the printer
\par   into the upper-case/graphics character set.
\par     Reverse video characters can be included in strings by holding down
\par   the ConTRoL <CTRL> key and pressing ReVerSe <RVS>, causing a reversed R
\par   to appear inside the quotes. This will make all characters print in
\par   reverse video (like a negative of a photograph). To end the reverse
\par   printing, press <CTRL> and <RVS OFF> (ReVerSe OFF) by holding down the
\par   <CTRL> key and typing the <RVS OFF> key, which prints a reverse R.
\par   Numeric data can be printed in reverse video by first printing a
\par   CHR$(18). Printing a CHR$(146) or a carriage-return will cancel reverse
\par   video output.
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                             BASIC LANGUAGE VOCABULARY   97
\par \page \page 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                                  CHAPTER 3
\par 
\par 
\par 
\par 
\par                                                PROGRAMMING
\par                                                   GRAPHICS
\par                                                     ON THE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                              COMMODORE 64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Graphics Overview
\par                            o Graphics Locations
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Standard Character Mode
\par                            o Programmable Characters
\par                            o Multi-Color Mode Graphics
\par                            o Extended Background Color Mode
\par                            o Bit Mapped Graphics
\par                            o Multi-Color Bit Map Mode
\par                            o Smooth Scrolling
\par                            o Sprites
\par                            o Other Graphics Features
\par                            o Programming Sprites -
\par                              Another Look
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                      99
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   GRAPHICS OVERVIEW
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  All of the graphics abilities of the Commodore 64 come from the 6567
\par   Video Interface Chip (also known as the VIC-II chip). This chip gives a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  variety of graphics modes, including a 40 column by 25 line text display,
\par   a 320 by 200 dot high resolution display, and SPRITES, small movable
\par   objects which make writing games simple. And if this weren't enough,
\par   many of the graphics modes can be mixed on the same screen. It is
\par   possible, for example, to define the top half of the screen to be in
\par   high resolution mode, while the bottom half is in text mode. And SPRITES
\par   will combine with anything! More on sprites later. First the other
\par   graphics modes.
\par     The VIC-II chip has the following graphics display modes:
\par 
\par 
\par 
\par   A) CHARACTER DISPLAY MODES
\par 
\par      1) Standard Character Mode
\par             a)ROM characters
\par             b)RAM programmable characters
\par      2) Multi-Color Character Mode
\par             a)ROM characters
\par             b)RAM programmable characters
\par 
\par      3) Extended Background Color Mode
\par             a)ROM characters
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {            b)RAM programmable characters
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B) BIT MAP MODES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par      1) Standard Bit Map Mode
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     2) Multi-Color Bit Map Mode
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  C) SPRITES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par      1) Standard Sprites
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     2) Multi-Color Sprites
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100   PROGRAMMING GRAPHICS
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   GRAPHICS LOCATIONS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Some general information first. There are 1000 possible locations on
\par   the Commodore 64 screen. Normally, the screen starts at location 1024
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ($0400 in HEXadecimal notation) and goes to location 2023. Each of
\par   these locations is 8 bits wide. This means that it can hold any integer
\par   number from 0 to 255. Connected with screen memory is a group of 1000
\par   locations called COLOR MEMORY or COLOR RAM. These start at location 55296
\par   ($D800 in HEX) and go up to 56295. Each of the color RAM locations is 4
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  bits wide, which means that it can hold any integer number from 0 to 15.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Since there are 16 possible colors that the Commodore 64 can use, this
\par   works out well.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    In addition, there are 256 different characters that can be displayed
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  at any time. For normal screen display, each of the 1000 locations in
\par   screen memory contains a code number which tells the VIC-II chip which
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  character to display at that screen location.
\par     The various graphics modes are selected by the 47 CONTROL registers in
\par   the VIC-II chip. Many of the graphics functions can be controlled by
\par   POKEing the correct value into one of the registers. The VIC-II chip is
\par   located starting at 53248 ($D000 in HEX) through 53294 ($D02E in HEX).
\par 
\par 
\par   VIDEO BANK SELECTION
\par 
\par     The VIC-II chip can access ("see") 16K of memory at a time. Since there
\par   is 64K of memory in the Commodore 64, you want to be able to have the
\par   VIC-II chip see all of it. There is a way. There are 4 possible BANKS
\par   (or sections) of 16K of memory. All that is needed is some means of
\par   controlling which 16K bank the VIC-II chip looks at. In that way, the
\par   chip can "see" the entire 64K of memory. The BANK SELECT bits that allow
\par   you access to all the different sections of memory are located in the
\par   6526 COMPLEX INTERFACE ADAPTER CHIP #2 (CIA #2). The POKE and PEEK BASIC
\par   statements (or their machine language versions) are used to select a
\par   bank, by controlling bits 0 and 1 of PORT A of CIA#2 (location 56576 (or
\par   $DD00 HEX)). These 2 bits must be set to outputs by setting bits 0 and 1
\par   of location 56578 ($DD02,HEX) to change banks. The following example
\par   shows this:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 56578,PEEK(56578)OR 3: REM MAKE SURE BITS 0 AND 1 ARE OUTPUTS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 56576,(PEEK(56576)AND 252)OR A: REM CHANGE BANKS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     "A" should have one of the following values:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   101
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-------+------+-------+----------+-------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | VALUE | BITS |  BANK | STARTING |  VIC-II CHIP RANGE                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  OF A |      |       | LOCATION |                                     |
\par   +-------+------+-------+----------+-------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   0   |  00  |   3   |   49152  | ($C000-$FFFF)*                      |
\par   |   1   |  01  |   2   |   32768  | ($8000-$BFFF)                       |
\par   |   2   |  10  |   1   |   16384  | ($4000-$7FFF)*                      |
\par   |   3   |  11  |   0   |       0  | ($0000-$3FFF) (DEFAULT VALUE)       |
\par   +-------+------+-------+----------+-------------------------------------+
\par 
\par 
\par 
\par     This 16K bank concept is part of everything that the VIC-II chip does.
\par   You should always be aware of which bank the VIC-II chip is pointing at,
\par   since this will affect where character data patterns come from, where the
\par   screen is, where sprites come from, etc. When you turn on the power of
\par   your Commodore 64, bits 0 and 1 of location 56576 are automatically set
\par   to BANK 0 ($0000-$3FFF) for all display information.
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | *NOTE: The Commodore 64 character set is not available to the VIC-II  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | chip in BANKS 1 and 3. (See character memory section.)                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SCREEN MEMORY
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The location of screen memory can be changed easily by a POKE to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  control register 53272 ($D018 HEX). However, this register is also used
\par   to control which character set is used, so be careful to avoid disturbing
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  that part of the control register. The UPPER 4 bits control the location
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of screen memory. To move the screen, the following statement should be
\par   used:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   POKE53272,(PEEK(53272)AND15)OR A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  102   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Where "A" has one of the following values:
\par   +---------+------------+-----------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         |            |         LOCATION*           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    A    |    BITS    +---------+-------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         |            | DECIMAL |        HEX        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+------------+---------+-------------------+
\par   |     0   |  0000XXXX  |      0  |  $0000            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    16   |  0001XXXX  |   1024  |  $0400 (DEFAULT)  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    32   |  0010XXXX  |   2048  |  $0800            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    48   |  0011XXXX  |   3072  |  $0C00            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    64   |  0100XXXX  |   4096  |  $1000            |
\par   |    80   |  0101XXXX  |   5120  |  $1400            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    96   |  0110XXXX  |   6144  |  $1800            |
\par   |   112   |  0111XXXX  |   7168  |  $1C00            |
\par   |   128   |  1000XXXX  |   8192  |  $2000            |
\par   |   144   |  1001XXXX  |   9216  |  $2400            |
\par   |   160   |  1010XXXX  |  10240  |  $2800            |
\par   |   176   |  1011XXXX  |  11264  |  $2C00            |
\par   |   192   |  1100XXXX  |  12288  |  $3000            |
\par   |   208   |  1101XXXX  |  13312  |  $3400            |
\par   |   224   |  1110XXXX  |  14336  |  $3800            |
\par   |   240   |  1111XXXX  |  15360  |  $3C00            |
\par   +---------+------------+---------+-------------------+
\par   +-----------------------------------------------------------------------+
\par   | * Remember that the BANK ADDRESS of the VIC-II chip must be added in. |
\par   | You must also tell the KERNAL'S screen editor where the screen is as  |
\par   | follows: POKE 648, page (where page = address/256, e.g., 1024/256= 4, |
\par   | so POKE 648,4).                                                       |
\par   +-----------------------------------------------------------------------+
\par 
\par   COLOR MEMORY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Color memory can NOT move. It is always located at locations 55296
\par   ($D800) through 56295 ($DBE7). Screen memory (the 1000 locations starting
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  at 1024) and color memory are used differently in the different graphics
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  modes. A picture created in one mode will often look completely different
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  when displayed in another graphics mode.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   CHARACTER MEMORY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Exactly where the VIC-II gets it character information is important to
\par   graphic programming. Normally, the chip gets the shapes of the characters
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   103
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   you want to be displayed from the CHARACTER GENERATOR ROM. In this chip
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  are stored the patterns which make up the various letters, numbers,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  punctuation symbols, and the other things that you see on the keyboard.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  One of the features of the Commodore 64 is the ability to use patterns
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  located in RAM memory. These RAM patterns are created by you, and that
\par   means that you can have an almost infinite set of symbols for games,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  business applications, etc.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    A normal character set contains 256 characters in which each character
\par   is defined by 8 bytes of data. Since each character takes up 8 bytes this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  means that a full character set is 256*8=2K bytes of memory. Since the
\par   VIC-II chip looks at 16K of memory at a time, there are 8 possible
\par   locations for a complete character set. Naturally, you are free to use
\par   less than a full character set. However, it must still start at one of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the 8 possible starting locations.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The location of character memory is controlled by 3 bits of the VIC-II
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  control register located at 53272 ($D018 in HEX notation). Bits 3,2, and
\par   1 control where the characters' set is located in 2K blocks. Bit 0 is ig-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  nored. Remember that this is the same register that determines where
\par   screen memory is located so avoid disturbing the screen memory bits. To
\par   change the location of character memory, the following BASIC statement
\par   can be used:
\par 
\par     POKE 53272,(PEEK(53272)AND240)OR A
\par 
\par   Where A is one of the following values:
\par   +-----+----------+------------------------------------------------------+
\par   |VALUE|          |            LOCATION OF CHARACTER MEMORY*             |
\par   | of A|   BITS   +-------+----------------------------------------------+
\par   |     |          |DECIMAL|         HEX                                  |
\par   +-----+----------+-------+----------------------------------------------+
\par   |   0 | XXXX000X |     0 | $0000-$07FF                                  |
\par   |   2 | XXXX001X |  2048 | $0800-$0FFF                                  |
\par   |   4 | XXXX010X |  4096 | $1000-$17FF ROM IMAGE in BANK 0 & 2 (default)|
\par   |   6 | XXXX011X |  6144 | $1800-$1FFF ROM IMAGE in BANK 0 & 2          |
\par   |   8 | XXXX100X |  8192 | $2000-$27FF                                  |
\par   |  10 | XXXX101X | 10240 | $2800-$2FFF                                  |
\par   |  12 | XXXX110X | 12288 | $3000-$37FF                                  |
\par   |  14 | XXXX111X | 14336 | $3800-$3FFF                                  |
\par   +-----+----------+-------+----------------------------------------------+
\par   +-----------------------------------------------------------------------+
\par   | * Remember to add in the BANK address.                                |
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  104   PROGRAMMING GRAPHICS
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The ROM IMAGE in the above table refers to the character generator ROM.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  It appears in place of RAM at the above locations in bank 0. it  also
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  appears in the corresponding RAM at locations 36864-40959 ($9000-$9FFF)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in bank 2. Since the VIC-II chip can only access 16K of memory at a time,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the ROM character patterns appear in the 16K block of memory the VIC-II
\par   chip looks at. Therefore, the system was designed to make the VIC-II chip
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  think that the ROM characters are at 4096-8191 ($1000-$1FFF) when your
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  data is in bank 0, and 36864-40959 ($9000-$9FFF) when your data is in
\par   bank 2, even though the character ROM is actually at location 53248-57343
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ($D000-$DFFF). This imaging only applies to character data as seen by the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VIC-II chip. It can be used for programs, other data, etc., just like any
\par   other RAM memory.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par   | NOTE: If these ROM images got in the way of your own graphics, then   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | set the BANK SELECT BITS to one of the BANKS without the images       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | (BANKS 1 or 3). The ROM patterns won't be there.                      |
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   The location and contents of the character set in ROM are as follows:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----+-------------------+-----------+---------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     |       ADDRESS     |   VIC-II  |                                 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |BLOCK+-------+-----------+   IMAGE   |            CONTENTS             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     |DECIMAL|    HEX    |           |                                 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----+-------+-----------+-----------+---------------------------------+
\par   |  0  | 53248 | D000-D1FF | 1000-11FF | Upper case characters           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     | 53760 | D200-D3FF | 1200-13FF | Graphics characters             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     | 54272 | D400-D5FF | 1400-15FF | Reversed upper case characters  |
\par   |     | 54784 | D600-D7FF | 1600-17FF | Reversed graphics characters    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     |       |           |           |                                 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  1  | 55296 | D800-D9FF | 1800-19FF | Lower case characters           |
\par   |     | 55808 | DA00-DBFF | 1A00-1BFF | Upper case & graphics characters|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     | 56320 | DC00-DDFF | 1C00-1DFF | Reversed lower case characters  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     | 56832 | DE00-DFFF | 1E00-1FFF | Reversed upper case &           |
\par   |     |       |           |           | graphics characters             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----+-------+-----------+-----------+---------------------------------+
\par 
\par     Sharp-eyed readers will have just noticed something. The locations
\par   occupied by the character ROM are the same as the ones occupied by the
\par   VIC-II chip control registers. This is possible because they don't occupy
\par   the same locations at the same time. When the VIC-II chip needs to access
\par 
\par                                                  PROGRAMMING GRAPHICS   105
\par \page 
\par 
\par 
\par   character data the ROM is switched in. It becomes an image in the 16K
\par   bank of memory that the VIC-II chip is looking at. Otherwise, the area is
\par   occupied by the I/O control registers, and the character ROM is only
\par   available to the VIC-II chip.
\par     However, you may need to get to the character ROM if you are going to
\par   use programmable characters and want to copy some of the character ROM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  for some of your character definitions. In this case you must switch out
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the I/O register, switch in the character ROM, and do your copying. When
\par   you're finished, you must switch the 1/0 registers back in again. During
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the copying process (when I/O is switched out) no interrupts can be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  allowed to take place. This is because the I/O registers are needed to
\par   service the interrupts. If you forget and perform an interrupt, really
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  strange things happen. The keyboard should not be read during the copying
\par   process. To turn off the keyboard and other normal interrupts that occur
\par   with your Commodore 64, the following POKE should be used:
\par 
\par     POKE 56334,PEEK(56334)AND254   (TURNS INTERRUPTS OFF)
\par 
\par 
\par     After you are finished getting characters from the character ROM, and
\par   are ready to continue with your program, you must turn the keyboard scan
\par   back on by the following POKE:
\par 
\par     POKE 56334,PEEK(56334)OR1      (TURNS INTERRUPTS ON)
\par 
\par 
\par     The following POKE will switch out 1/0 and switch the CHARACTER ROM in:
\par 
\par     POKE 1,PEEK(1)AND251
\par 
\par 
\par     The character ROM is now in the locations from 53248-57343 ($D000-
\par   $DFFF).
\par     To switch I/O back into $D000 for normal operation use the following
\par   POKE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 1,PEEK(1)OR 4
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   106   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STANDARD CHARACTER MODE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Standard character mode is the mode the Commodore 64 is in when you
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  first turn it on. It is the mode you will generally program in.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Characters can be taken from ROM or from RAM, but normally they are
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  taken from ROM. When you want special graphics characters for a program,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  all you have to do is define the new character shapes in RAM, and tell
\par   the VIC-II chip to get its character information from there instead of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the character ROM. This is covered in more detail in the next section.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    In order to display characters on the screen in color, the VIC-II chip
\par   accesses the screen memory to determine the character code for that
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  location on the screen. At the same time, it accesses the color memory to
\par   determine what color you want for the character displayed. The character
\par   code is translated by the VIC-II into the starting address of the 8-byte
\par   block holding your character pattern. The 8-byte block is located in
\par   character memory.
\par     The translation isn't too complicated, but a number of items are com-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  bined to generate the desired address. First the character code you use
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to POKE screen memory is multiplied by 8. Next add the start of char-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  acter memory (see CHARACTER MEMORY section). Then the Bank Select Bits
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  are taken into account by adding in the base address (see VIDEO BANK
\par   SELECTION section). Below is a simple formula to illustrate what happens:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CHARACTER ADDRESS = SCREEN CODE*8+(CHARACTER SET*2048)+(BANK*16384)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   CHARACTER DEFINITIONS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Each character is formed in an 8 by 8 grid of dots, where each dot may
\par   be either on or off. The Commodore 64 character images are stored in the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Character Generator ROM chip. The characters are stored as a set of 8
\par   bytes for each character, with each byte representing the dot pattern of
\par   a row in the character, and each bit representing a dot. A zero bit means
\par   that dot is off, and a one bit means the dot is on.
\par     The character memory in ROM begins at location 53248 (when the I/O
\par   is switched off). The first 8 bytes from location 53248 ($D000) to 53255
\par   ($D007) contain the pattern for the @ sign, which has a character code
\par   value of zero in the screen memory. The next 8 bytes, from location
\par 
\par 
\par 
\par 
\par 
\par                                                  PROGRAMMING GRAPHICS   107
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  53256 ($D008) to 53263 ($D00F), contain the information for forming the
\par   letter A.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       IMAGE     BINARY       PEEK
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        **      00011000       24
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       ****     00111100       60
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      **  **    01100110      102
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      ******    01111110      126
\par       **  **    01100110      102
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      **  **    01100110      102
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      **  **    01100110      102
\par \tab \tab 00000000\tab 0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Each complete character set takes up 2K (2048 bits) of memory, 8 bytes
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  per character and 256 characters. Since there are two character sets, one
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  for upper case and graphics and the other with upper and lower case, the
\par   character generator ROM takes up a total of 4K locations.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   PROGRAMMABLE CHARACTERS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Since the characters are stored in ROM, it would seem that there is no
\par   way to change them for customizing characters. However, the memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  location that tells the VIC-II chip where to find the characters is a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  programmable register which can be changed to point to many sections of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  memory. By changing the character memory pointer to point to RAM, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  character set may be programmed for any need.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    If you want your character set to be located in RAM, there are a few
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VERY IMPORTANT things to take into account when you decide to actually
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  program your own character sets. In addition, there are two other
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  important points you must know to create your own special characters:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) It is an all or nothing process. Generally, if you use your own
\par        character set by telling the VIC-II chip to get the character
\par        information from the area you have prepared in RAM, the standard
\par      Commodore 64 characters are unavailable to you. To solve this, you
\par      must copy any letters, numbers, or standard Commodore 64 graphics you
\par      intend to use into your own character memory in RAM. You can pick and
\par      choose, take only the ones you want, and don't even have to keep them
\par      in order!
\par 
\par 
\par   108   PROGRAMMING GRAPHICS
\par \page 
\par 
\par 
\par     2) Your character set takes memory space away from your BASIC program.
\par        Of course, with 38K available for a BASIC program, most applications
\par        won't have problems.
\par 
\par 
\par   +-----------------------------------------------------------------------+
\par   | WARNING: You must be careful to protect the character set from being  |
\par   | overwritten by your BASIC program, which also uses the RAM.           |
\par   +-----------------------------------------------------------------------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    There are two locations in the Commodore 64 to start your character set
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  that should NOT be used with BASIC: location 0 and location 2048. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  first should not be used because the system stores important data on
\par   page 0. The second can't be used because that is where your BASIC program
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  starts! However, there are 6 other starting positions for your custom
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  character set.
\par     The best place to put your character set for use with BASIC while
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  experimenting is beginning at 12288 ($3000 in HEX). This is done by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  POKEing the low 4 bits of location 53272 with 12. Try the POKE now, like
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  this:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     POKE 53272,(PEEK(53272)AND240)+12
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Immediately, all the letters on the screen turn to garbage, This is
\par   because there are no characters set up at location 12288 right now...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  only random bytes. Set the Commodore 64 back to normal by hitting the
\par   <RUN/STOP> key and then the <RESTORE> key.
\par     Now let's begin creating graphics characters. To protect your char-
\par   acter set from BASIC, you should reduce the amount of memory BASIC
\par   thinks it has. The amount of memory in your computer stays the same...
\par   it's just that you've told BASIC not to use some of it. Type:
\par 
\par     PRINT FRE(0)-(SGN(FRE(0))<0)*65535
\par 
\par     The number displayed is the amount of memory space left unused. Now
\par   type the following:
\par 
\par     POKE 52148:POKE56,48:CLR
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Now type:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     PRINT FRE(0)-(SGN(FRE(0))<0)*65535
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   109
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   See the change? BASIC now thinks it has less memory to work with. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  memory you just claimed from BASIC is where you are going to put your
\par   character set, safe from actions of BASIC.
\par     The next step is to put your characters into RAM. When you begin, there
\par   is random data beginning at 12288 ($3000 HEX). You must put character
\par   patterns in RAM (in the same style as the ones in ROM) for the VIC-II
\par   chip to use.
\par     The following program moves 64 characters from ROM to your character
\par   set RAM:
\par 
\par start tok64 page110.prg
\par   5 printchr$(142)               :rem switch to upper case
\par   10 poke52,48:poke 56,48:clr    :rem reserve memory for characters
\par   20 poke56334,peek(56334)and254 :rem turn off keyscan interrupt timer
\par   30 poke1,peek(1)and251         :rem switch in character
\par   40 fori=0to511:pokei+12288,peek(i+53248):next
\par   50 poke1,peek(1)or4            :rem switch in i/o
\par   60 poke56334,peek(56334)or1    :rem restart keyscan interrupt timer
\par   70 end
\par stop tok64
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Now POKE location 53272 with (PEEK(53272)AND240)+12. Nothing happens,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  right? Well, almost nothing. The Commodore 64 is now getting it's
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  character information from your RAM, instead of from ROM. But since we
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  copied the characters from ROM exactly, no difference can be seen... yet.
\par     You can easily change the characters now. Clear the screen and type
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  an @ sign. Move the cursor down a couple of lines, then type:
\par 
\par   FOR I=12288 TO 12288+7:POKE 1,255-PEEK(I):NEXT
\par 
\par   You just created a reversed @ sign!
\par 
\par   +-----------------------------------------------------------------------+
\par   | TIP: Reversed characters are just characters with their bit patterns  |
\par   | in character memory reversed.                                         |
\par   +-----------------------------------------------------------------------+
\par 
\par     Now move the cursor up to the program again and hit <RETURN> again to
\par   re-reverse the character (bring it back to normal). By looking at the
\par   table of screen display codes, you can figure out where in RAM each
\par   character is. Just remember that each character takes eight memory
\par   locations to store. Here's a few examples just to get you started:
\par 
\par   110   PROGRAMMING GRAPHICS
\par \page 
\par 
\par 
\par   +-----------+--------------+--------------------------------------------+
\par   | CHARACTER | DISPLAY CODE |      CURRENT STARTING LOCATION IN RAM      |
\par   +-----------+--------------+--------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     @     |       0      |                    1228                    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     A     |       1      |                   12296                    |
\par   |     !     |      33      |                   12552                    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     >     |      62      |                   12784                    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------+--------------+--------------------------------------------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Remember that we only took the first 64 characters. Something else will
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  have to be done if you want one of the other characters.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    What if you wanted character number 154, a reversed Z? Well, you could
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  make it yourself, by reversing a Z, or you could copy the set of reversed
\par   characters from the ROM, or just take the one character you want from ROM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and replace one of the characters you have in RAM that you don't need.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Suppose you decide that you won't need the > sign. Let's replace the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  > sign with the reversed Z. Type this:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    FOR I=0 TO 7:POKE 12784+I,255-PEEK(I+12496):NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Now type a > sign. It comes up as a reversed Z. No matter how many
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  times you type the >, it comes out as a reversed Z. (This change is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  really an illusion. Though the > sign looks like a reversed Z, it still
\par   acts like a > in a program. Try something that needs a > sign. It will
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  still work fine, only it will look strange.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    A quick review: You can now copy characters from ROM into RAM. You can
\par   even pick and choose only the ones you want. There's only one step left
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in programmable characters (the best step!)... making your own
\par   characters.
\par     Remember how characters are stored in ROM? Each character is stored as
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a group of eight bytes. The bit patterns of the bytes directly control
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the character. If you arrange 8 bytes, one on top of another, and write
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  out each byte as eight binary digits, it forms an eight by eight matrix,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  looking like the characters. When a bit is a one, there is a dot at that
\par   location. When a bit is a zero, there is a space at that location. When
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  creating your own characters, you set up the same kind of table in
\par   memory. Type NEW and then type this program:
\par 
\par     10 FOR I=12448 TO 12455: READ A:POKE I,A:NEXT
\par     20 DATA 60, 66, 165, 129, 165, 153, 66, 60
\par 
\par                                                  PROGRAMMING GRAPHICS   111
\par \page 
\par 
\par 
\par   Now type RUN. The program will replace the letter T with a smile face
\par   character. Type a few T's to see the face. Each of the numbers in the
\par   DATA statement in line 20 is a row in the smile face character. The
\par   matrix for the face looks like this:
\par 
\par 
\par            76543210          BINARY      DECIMAL
\par 
\par           +--------+
\par     ROW 0 |  ****  |        00111100        60
\par         1 | *    * |        01000010        66
\par         2 |* *  * *|        10100101       165
\par         3 |*      *|        10000001       129
\par         4 |* *  * *|        10100101       165
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        5 |*  **  *|        10011001       153
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        6 | *    * |        01000010        66
\par     ROW 7 |  ****  |        00111100        60
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          +--------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                               7 6 5 4 3 2 1 0
\par 
\par                               +-+-+-+-+-+-+-+-+
\par                             0 | | | | | | | | |
\par                               +-+-+-+-+-+-+-+-+
\par                             1 | | | | | | | | |
\par                               +-+-+-+-+-+-+-+-+
\par                             2 | | | | | | | | |
\par                               +-+-+-+-+-+-+-+-+
\par                             3 | | | | | | | | |
\par                               +-+-+-+-+-+-+-+-+
\par                             4 | | | | | | | | |
\par                               +-+-+-+-+-+-+-+-+
\par                             5 | | | | | | | | |
\par                               +-+-+-+-+-+-+-+-+
\par                             6 | | | | | | | | |
\par                               +-+-+-+-+-+-+-+-+
\par                             7 | | | | | | | | |
\par                               +-+-+-+-+-+-+-+-+
\par 
\par                  Figure 3-1. Programmable Character Worksheet.
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  112   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The Programmable Character Worksheet (Figure 3-1) will help you design
\par   your own characters. There is an 8 by 8 matrix on the sheet, with row
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  numbers, and numbers at the top of each column. (if you view each row as
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a binary word, the numbers are the value of that bit position. Each is a
\par   power of 2. The leftmost bit is equal to 128 or 2 to the 7th power, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  next is equal to 64 or 2 to the 6th, and so on, until you reach the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  rightmost bit (bit 0) which is equal to 1 or 2 to the 0 power.)
\par     Place an X on the matrix at every location where you want a dot to be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in your character. When your character is ready you can create the DATA
\par   statement for your character.
\par     Begin with the first row. Wherever you placed an X, take the number at
\par   the top of the column (the power-of-2 number, as explained above) and
\par   write it down. When you have the numbers for every column of the first
\par   row, add them together. \\Mite this number down, next to the row. This is
\par   the number that you will put into the DATA statement to draw this row.
\par     Do the same thing with all of the other rows (1-7). When you are
\par   finished you should have 8 numbers between 0 and 255. If any of your
\par   numbers are not within range, recheck your addition. The numbers must be
\par   in this range to be correct! If you have less than 8 numbers, you missed
\par   a row. It's OK if some are 0. The 0 rows are just as important as the
\par   other numbers.
\par     Replace the numbers in the DATA statement in line 20 with the numbers
\par   you just calculated, and RUN the program. Then type a T. Every time you
\par   type it, you'll see your own character!
\par     If you don't like the way the character turned out, just change the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  numbers in the DATA statement and re-RUN the program until you are happy
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  with your character.
\par     That's all there is to it!
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par   | HINT: For best results, always make any vertical lines in your        |
\par   | characters at least 2 dots (bits) wide. This helps prevent CHROMA     |
\par   | noise (color distortion) on your characters when they are displayed   |
\par   | on a TV screen.                                                       |
\par   +-----------------------------------------------------------------------+
\par 
\par 
\par 
\par 
\par 
\par 
\par                                                  PROGRAMMING GRAPHICS   113
\par \page 
\par 
\par 
\par     Here is an example of a program using standard programmable characters:
\par 
\par 
\par 
\par start tok64 page114.prg
\par   10 rem * example 1 *
\par   20 rem creating programmable characters
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  31 poke 56334,peek(56334)and254: rem turn off kb
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  32 poke 1,peek(1)and251: rem turn off i/o
\par   35 for i=0to63: rem character range to be copied
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  36 for j=0to7: rem copy all 8 bytes per character
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  37 poke 12288+I*8+j,peek(53248+i*8+j): rem copy a byte
\par   38 next j:next i: rem goto next byte or character
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  39 poke 1,peek(1)or4:poke 56334,peek(56334)or1: rem turn on i/O and kb
\par   40 poke 53272,(peek(53272)and240)+12: rem set char pointer to mem. 12288
\par   60 for char=60to63: rem program characters 60 thru 63
\par   80 for byte=0to7: rem do all 8 bytes of a character
\par   100 read number: rem read in 1/8th of character data
\par   120 poke 12288+(8*char)+byte,number: rem store the data in memory
\par   140 next byte:next char: rem also could be next byte, char
\par   150 print chr$(147)tab(255)chr$(60);
\par   155 print chr$(61)tab(55)chr$(62)chr$(63)
\par   160 rem line 150 puts the newly defined characters on the screen
\par   170 get a$: rem wait for user to press a key
\par   180 if a$=""then goto170: rem if no keys were pressed, try again!
\par   190 poke 53272,21: rem return to normal characters
\par   200 data 4,6,7,5,7,7,3,3: rem data for character 60
\par   210 data 32,96,224,160,224,224,192,192: rem data for character 61
\par   220 data 7,7,7,31,31,95,143,127: rem data for character 62
\par   230 data 224,224,224,248,248,248,240,224: rem data for character 63
\par   240 end
\par stop tok64
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  114   PROGRAMMING GRAPHICS
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   MULTI-COLOR MODE GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Standard high-resolution graphics give you control of very small dots
\par   on the screen. Each dot in character memory can have 2 possible values,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  1 for on and 0 for off. When a dot is off, the color of the screen is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  used in the space reserved for that dot. If the dot is on, the dot is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  colored with the character color you have chosen for that screen posi-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  tion. When you're using standard high-resolution graphics, all the dots
\par   within each 8X8 character can either have background color or foreground
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  color. In some ways this limits the color resolution within that space.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  For example, problems may occur when two different colored lines cross.
\par     Multi-color mode gives you a solution to this problem. Each dot in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  multi-color mode can be one of 4 colors: screen color (background color
\par   register #0), the color in background register #1, the color in back-
\par   ground color register #2, or character color. The only sacrifice is in
\par   the horizontal resolution, because each multi-color mode dot is twice as
\par   wide as a high-resolution dot. This minimal loss of resolution is more
\par   than compensated for by the extra abilities of multi-color mode.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  MULTI-COLOR MODE BIT
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    To turn on multi-color character mode, set bit 4 of the VIC-II control
\par   register at 53270 ($D016) to a 1 by using the following POKE:
\par 
\par     POKE 53270,PEEK(53270)OR 16
\par 
\par     To turn off multi-color character mode, set bit 4 of location 53270 to
\par   a 0 by the following POKE:
\par 
\par     POKE 53270,PEEK(53270)AND 239
\par 
\par     Multi-color mode is set on or off for each space on the screen, so that
\par   multi-color graphics can be mixed with high-resolution (hi-res) graphics.
\par   This is controlled by bit 3 in color memory. Color memory begins at
\par   location 55296 ($D800 in HEX). If the number in color memory is less than
\par   8 (0-7) the corresponding space on the video screen will be standard
\par   hi-res, in the color (0-7) you've chosen. If the number located in color
\par   memory is greater or equal to 8 (from 8 to 15), then that space will be
\par   displayed in multi-color mode.
\par 
\par 
\par 
\par 
\par                                                  PROGRAMMING GRAPHICS   115
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    By POKEing a number into color memory, you can change the color of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  character in that position on the screen. POKEing a number from 0 to 7
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  gives the normal character colors. POKEing a number between 8 and 15 puts
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the space into multi-color mode. In other words, turning BIT 3 ON in
\par   color memory, sets MULTI-COLOR MODE. Turning BIT 3 OFF in color memory,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sets the normal, HIGH-RESOLUTION mode.
\par     Once multi-color mode is set in a space, the bits in the character
\par   determine which colors are displayed for the dots. For example, here is
\par   a picture of the letter A, and its bit pattern:
\par 
\par                           IMAGE    BIT PATTERN
\par 
\par                             **       00011000
\par                            ****      00111100
\par                           **  **     01100110
\par                           ******     01111110
\par                           **  **     01100110
\par                           **  **     01100110
\par                           **  **     01100110
\par                                      00000000
\par 
\par     In normal or high-resolution mode, the screen color is displayed
\par   everywhere there is a 0 bit, and the character color is displayed where
\par   the bit is a 1. Multi-color mode uses the bits in pairs, like so:
\par 
\par                           IMAGE    BIT PATTERN
\par 
\par                            AABB      00011000
\par                            CCCC      00111100
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         AABBAABB    01100110
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         AACCCCBB    01111110
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         AABBAABB    01100110
\par                          AABBAABB    01100110
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         AABBAABB    01100110
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     00000000
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    In the image area above, the spaces marked AA are drawn in the
\par   background #1 color, the spaces marked BB use the background #2 color,
\par   and the spaces marked CC use the character color. The bit pairs determine
\par   this, according to the following chart:
\par 
\par 
\par 
\par   116   PROGRAMMING GRAPHICS
\par \page 
\par 
\par 
\par   +----------+--------------------------------------+---------------------+
\par   | BIT PAIR |          COLOR REGISTER              |       LOCATION      |
\par   +----------+--------------------------------------+---------------------+
\par   |    00    |  Background #0 color (screen color)  |   53281 ($D021)     |
\par   |    01    |  Background #l color                 |   53282 ($D022)     |
\par   |    10    |  Background #2 color                 |   53283 ($D023)     |
\par   |    11    |  Color specified by the              |   color RAM         |
\par   |          |  lower 3 bits in color memory        |                     |
\par   +----------+--------------------------------------+---------------------+
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Type NEW and then type this demonstration program:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par start tok64 page117.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 poke 53281,1: rem set background color #0 to white
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  110 poke 53282,3: rem set background color #1 to cyan
\par   120 poke 53282,8: rem set background color #2 to orange
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  130 poke 53270,peek(53270)or16: rem turn on multicolor mode
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  140 c=13*4096+8*256: rem set c to point to color memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  150 printchr$(147)"aaaaaaaaaa"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  160 forl=0to9
\par   170 pokec+l,8: rem use multi black
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  180 next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {stop tok64
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The screen color is white, the character color is black, one color
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  register is cyan (greenish blue), the other is orange. You're not really
\par   putting color codes in the space for character color, you're actually
\par   using references to the registers associated with those colors. This
\par   conserves memory, since 2 bits can be used to pick 16 colors (background)
\par   or 8 colors (character). This also makes some neat tricks possible.
\par   Simply changing one of the indirect registers will change every dot drawn
\par   in that color. Therefore everything drawn in the screen and background
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   117
\par \page 
\par 
\par 
\par   colors can be changed on the whole screen instantly. Here is an example
\par   of changing background color register #1:
\par 
\par start tok64 page118.prg
\par   100 poke53270,peek(53270)or16: rem turn on multicolor mode
\par   110 print chr$(147)chr$(18);
\par   120 print"\{orange*2\}";: rem type c= & 1 for orange or multicolor black bg
\par   130 forl=1to22:printchr$(65);:next
\par   135 fort=1to500:next
\par   140 print"\{blue*2\}";: rem type ctrl & 7 for blue color change
\par   145 fort=1to500:next
\par   150 print"\{black\}hit a key"
\par   160 get a$:if a$=""then160
\par   170 x=int(rnd(1)*16)
\par   180 poke 53282,x
\par   190 goto 160
\par stop tok64
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    By using the <C=> key and the COLOR keys the characters can be changed
\par   to any color, including multi-color characters. For example, type this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  command:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     POKE 53270,PEEK(53270)OR 16:PRINT"<CTRL+3>";: rem lt.red/ multi-color
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  red
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The word READY and anything else you type will be displayed in multi-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  color mode. Another color control can set you back to regular text.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   118   PROGRAMMING GRAPHICS
\par \page 
\par 
\par 
\par     Here is an example of a program using multi-color programmable
\par   characters:
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {start tok64 page119.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 rem * example 2 *
\par   20 rem creating multi color programmable characters
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  31 poke 56334,peek(56334)and254:poke1,peek(1)and251
\par   35 fori=0to63:rem character range to be copied from rom
\par   36 forj=0to7:rem copy all 8 bytes per character
\par   37 poke 12288+i*8+j,peek(53248+i*8+j):rem copy a byte
\par   38 next j,i:rem goto next byte or character
\par   39 poke 1,peek(1)or4:poke 56334,peek(56334)or1:rem turn on i/o and kb
\par   40 poke 53272,(peek(53272)and240)+12:rem set char pointer to mem. 12288
\par   50 poke 53270,peek(53270)or16
\par   51 poke 53281,0:rem set background color #0 to black
\par   52 poke 53282,2:rem set background color #1 to red
\par   53 poke 53283,7:rem set background color #2 to yellow
\par   60 for char=60to63:rem program characters 60 thru 63
\par   80 for byte=0to7:rem do all 8 bytes of a character
\par   100 read number:rem read 1/8th of the character data
\par   120 poke 12288+(8*char)+byte,number:rem store the data in memory
\par   140 next byte,char
\par   150 print"\{clear\}"tab(255)chr$(60)chr$(61)tab(55)chr$(62)chr$(63)
\par   160 rem line 150 puts the newly defined characters on the screen
\par   170 get a$:rem wait for user to press a key
\par   180 if a$=""then170:rem if no keys were pressed, try again
\par   190 poke53272,21:poke53270,peek(53270)and239:rem return to normal chars
\par   200 data129,37,21,29,93,85,85,85: rem data for character 60
\par   210 data66,72,84,116,117,85,85,85: rem data for character 61
\par   220 data87,87,85,21,8,8,40,0: rem data for character 62
\par   230 data213,213,85,84,32,32,40,0: rem data for character 63
\par   240 end
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {stop tok64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   119
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXTENDED BACKGROUND COLOR MODE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Extended background color mode gives you control over the background
\par   color of each individual character, as well as over the foreground color.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  For example, in this mode you could display a blue character with a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  yellow background on a white screen.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    There are 4 registers available for extended background color mode.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Each of the registers can be set to any of the 16 colors.
\par     Color memory is used to hold the foreground color in extended back-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ground mode. It is used the same as in standard character mode.
\par     Extended character mode places a limit on the number of different
\par   characters you can display, however. When extended color mode is on, only
\par   the first 64 characters in the character ROM (or the first 64 characters
\par   in your programmable character set) can be used. This is because two of
\par   the bits of the character code are used to select the background color.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  It might work something like this:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The character code (the number you would POKE to the screen) of the
\par   letter "A" is a 1. When extended color mode is on, if you POKED a 1 to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the screen, an "A" would appear. If you POKED a 65 to the screen
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  normally, you would expect the character with character code (CHR$) 129
\par   to appear, which is a reversed "A." This does NOT happen in extended
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  color mode. Instead you get the same unreversed "A" as before, but on a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  different background color. The following chart gives the codes:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------+---------------------------+
\par   |     CHARACTER CODE     | BACKGROUND COLOR REGISTER |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------+---------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  RANGE   BIT 7   BIT 6 |  NUMBER       ADDRESS     |
\par   +------------------------+---------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   0- 63   0       0    |    0       53281 ($D021)  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  64-127   0       1    |    1       53282 ($D022)  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 128-191   1       0    |    2       53283 ($D023)  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 192-255   1       1    |    3       53284 ($D024)  |
\par   +------------------------+---------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Extended color mode is turned ON by setting bit 6 of the VIC-II regis-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ter to a 1 at location 53265 ($D011 in HEX). The following POKE does it:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     POKE 53265,PEEK(53265)OR 64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   120   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Extended color mode is turned OFF by setting bit 6 of the VIC-II regis-
\par   ter to a 0 at location 53265 ($D011). The following statement will do
\par   this:
\par 
\par     POKE 53265,PEEK(53265)AND 191
\par 
\par 
\par   BIT MAPPED GRAPHICS
\par 
\par     When writing games, plotting charts for business applications, or other
\par   types of programs, sooner or later you get to the point where you want
\par   high-resolution displays.
\par     The Commodore 64 has been designed to do just that: high resolution is
\par   available through bit mapping of the screen. Bit mapping is the method in
\par   which each possible dot (pixel) of resolution on the screen is assigned
\par   its own bit (location) in memory. If that memory bit is a one, the dot it
\par   is assigned to is on. If the bit is set to zero, the dot is off.
\par     High-resolution graphic design has a couple of drawbacks, which is why
\par   it is not used all the time. First of all, it takes lots of memory to bit
\par   map the entire screen. This is because every pixel must have a memory bit
\par   to control it. You are going to need one bit of memory for each pixel
\par   (or one byte for 8 pixels). Since each character is 8 by 8, and there are
\par   40 lines with 25 characters in each line, the resolution is 320 pixels
\par   (dots) by 200 pixels for the whole screen. That gives you 64000 separate
\par   dots, each of which requires a bit in memory. In other words, 8000 bytes
\par   of memory are needed to map the whole screen.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Generally, high-resolution operations are made of many short, simple,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  repetitive routines. Unfortunately, this kind of thing is usually rather
\par   slow if you are trying to write high-resolution routines in BASIC. How-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ever, short, simple, repetitive routines are exactly what machine lan-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  guage does best. The solution is to either write your programs entirely
\par   in machine language, or call machine language, high-resolution sub-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  routines from your BASIC program using the SYS command from BASIC. That
\par   way you get both the ease of writing in BASIC, and the speed of machine
\par   language for graphics. The VSP cartridge is also available to add high-
\par   resolution commands to COMMODORE 64 BASIC.
\par     All of the examples given in this section will be in BASIC to make them
\par   clear. Now to the technical details.
\par 
\par     BIT MAPPING is one of the most popular graphics techniques in the
\par   computer world. It is used to create highly detailed pictures. Basically,
\par   when the Commodore 64 goes into bit map mode, it directly displays an
\par 
\par                                                  PROGRAMMING GRAPHICS   121
\par \page 
\par 
\par 
\par   8K section of memory on the TV screen. When in bit map mode, you can
\par   directly control whether an individual dot on the screen is on or off.
\par     There are two types of bit mapping available on the Commodore 64.
\par   They are:
\par 
\par     1) Standard (high-resolution) bit mapped mode (320-dot by 200-dot
\par        resolution)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) Multi-color bit mapped mode (160-dot by 200-dot resolution)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Each is very similar to the character type it is named for: standard
\par   has greater resolution, but fewer color selections. On the other hand,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  multi-color bit mapping trades horizontal resolution for a greater number
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of colors in an 8-dot by 8-dot square.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STANDARD HIGH-RESOLUTION BIT MAP MODE
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Standard bit map mode gives you a 320 horizontal dot by 200 vertical
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  dot resolution, with a choice of 2 colors in each 8-dot by 8-dot section.
\par   Bit map mode is selected (turned ON) by setting bit 5 of the VIC-II
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  control register to a 1 at location 53265 ($D011 in HEX). The following
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  POKE will do this:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 53265,PEEK(53265)OR 32
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Bit map mode is turned OFF by setting bit 5 of the VIC-II control
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  register to 0 at location 53265 ($D011), like this:
\par 
\par     POKE 53265,PEEK(53265)AND 223
\par 
\par     Before we get into the details of the bit map mode, there is one more
\par   issue to tackle, and that is where to locate the bit map area.
\par 
\par   HOW IT WORKS
\par 
\par     If you remember the PROGRAMMABLE CHARACTERS section you will recall
\par   that you were able to set the bit pattern of a character stored in RAM to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  almost anything you wanted. If at the same time you change the character
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  that is displayed on the screen, you would be able to change a single
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  dot, and watch it happen. This is the basis of bit-mapping. The entire
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  122   PROGRAMMING GRAPHICS
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   screen is filled with programmable characters, and you make your changes
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  directly into the memory that the programmable characters get their
\par   patterns from.
\par     Each of the locations in screen memory that were used to control what
\par   character was displayed, are now used for color information. For example,
\par   instead of POKEing a I in location 1024 to make an "A" appear in the top
\par   left hand corner of the screen, location 1024 now controls the colors of
\par   the bits in that top left space.
\par     Colors of squares in bit map mode do not come from color memory, as
\par   they do in the character modes. Instead, colors are taken from screen
\par   memory. The upper 4 bits of screen memory become the color of any bit
\par   that is set to 1 in the 8 by 8 area controlled by that screen memory
\par   location. The lower 4 bits become the color of any bit that is set to
\par   a 0.
\par 
\par   EXAMPLE: Type the following:
\par 
\par 
\par   5 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 POKE53265,PEEK(53265)OR32:REM ENTER BIT MAP MODE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Now RUN the program.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Garbage appears on the screen, right? Just like the normal screen mode,
\par   you have to clear the HIGH-RESOLUTION (HI-RES) screen before you use it.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Unfortunately, printing a CLR won't work in this case. Instead you have
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to clear out the section of memory that you're using for your
\par   programmable characters. Hit the <RUN/STOP> and <RESTORE> keys, then add
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the following lines to your program to clear the HI-RES screen:
\par 
\par 
\par 
\par   20 FORI=BASETOBASE+7999:POKEI,0:NEXT:REM CLEAR BIT
\par   30 FORI=1024TO2023:POKEI,3:NEXT:REM SET COLOR TO CYAN AND BLACK
\par 
\par 
\par 
\par 
\par     Now RUN the program again. You should see the screen clearing, then the
\par   greenish blue color, cyan, should cover the whole screen. What we want to
\par   do now is to turn the dots on and off on the HI-RES screen.
\par 
\par 
\par                                                  PROGRAMMING GRAPHICS   123
\par \page 
\par 
\par 
\par     To SET a dot (turn a dot ON) or UNSET a dot (turn a dot OFF) you must
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  know how to find the correct bit in the character memory that you have to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  set to a 1. In other words, you have to find the character you need to
\par   change, the row of the character, and which bit of the row that you
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  have to change. You need a formula to calculate this.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    We will use X and Y to stand for the horizontal and vertical positions
\par   of a dot, The dot where X=0 and Y=0 is at the upper-left of the display.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Dots to the right have higher X values, and the dots toward the bottom
\par   have higher Y values. The best way to use bit mapping is to arrange the
\par   bit map display something like this:
\par 
\par 
\par 
\par   0. . . . . . . . . . . . . . . . . .X. . . . . . . . . . . . . . . . .319
\par 
\par   .                                                                      .
\par 
\par   .                                                                      .
\par 
\par   .                                                                      .
\par 
\par   .                                                                      .
\par 
\par   Y                                                                      .
\par 
\par   .                                                                      .
\par 
\par   .                                                                      .
\par 
\par   .                                                                      .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  .                                                                      .
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  199. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Each dot will have an X and a Y coordinate. With this format it is easy
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to control any dot on the screen.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   124   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     However, what you actually have is something like this:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ----- BYTE 0   BYTE 8   BYTE 16    BYTE 24 ..................... BYTE 312
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        BYTE 1   BYTE 9      .          .                          BYTE 313
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        BYTE 2   BYTE 10     .          .                          BYTE 314
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        BYTE 3   BYTE 11     .          .                          BYTE 315
\par         BYTE 4   BYTE 12     .          .                          BYTE 316
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        BYTE 5   BYTE 13     .          .                          BYTE 317
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        BYTE 6   BYTE 14     .          .                          BYTE 318
\par   ----- BYTE 7   BYTE 15     .          .                          BYTE 319
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ----- BYTE 320 BYTE 328 BYTE 336 BYTE 344....................... BYTE 632
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        BYTE 321 BYTE 329    .          .                          BYTE 633
\par         BYTE 322 BYTE 330    .          .                          BYTE 634
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        BYTE 323 BYTE 331    .          .                          BYTE 635
\par         BYTE 324 BYTE 332    .          .                          BYTE 636
\par         BYTE 325 BYTE 333    .          .                          BYTE 637
\par         BYTE 326 BYTE 334    .          .                          BYTE 638
\par   ----- BYTE 327 BYTE 335    .          .                          BYTE 639
\par 
\par 
\par     The programmable characters which make up the bit map are arranged in
\par   25 rows of 40 columns each. While this is a good method of organization
\par   for text, it makes bit mapping somewhat difficult. (There is a good
\par   reason for this method. See the section on MIXED MODES.)
\par     The following formula will make it easier to control a dot on the bit
\par   map screen:
\par     The start of the display memory area is known as the BASE, The row
\par   number (from 0 to 24) of your dot is:
\par 
\par     ROW = INT(Y/8) (There are 320 bytes per line.)
\par 
\par   The character position on that line (from 0 to 39) is:
\par 
\par     CHAR = INT(X/8) (There are 8 bytes per character.)
\par 
\par   The line of that character position (from 0 to 7) is:
\par 
\par     LINE = Y AND 7
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                  PROGRAMMING GRAPHICS   125
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The bit of that byte is:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     BIT = 7-(X AND 7)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Now we put these formulas together. The byte in which character memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  dot (X,Y) is located is calculated by:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     BYTE = BASE + ROW*320+ CHAR*8 + LINE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     To turn on any bit on the grid with coordinates (X,Y), use this line:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  POKE BYTE, PEEK(BYTE) OR 2^BIT
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Let's add these calculations to the program. In the following example,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the COMMODORE 64 will plot a sine curve:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   50 FORX=0TO319STEP.5:REM WAVE WILL FILL THE SCREEN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60 Y=INT(90+80*SIN(X/10))
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 CH=INT(X/8)
\par   80 RO=INT(Y/8)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  85 LN=YAND7
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 BY=BASE+RO*320+8*CH+LN
\par   100 BI=7-(XAND7)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  110 POKEBY,PEEK(BY)OR(2^BI)
\par   120 NEXTX
\par   125 POKE1024,16
\par   130 GOTO130
\par 
\par 
\par     The calculation in line 60 will change the values for the sine function
\par   from a range of +1 to -1 to a range of 10 to 170. Lines 70 to 100
\par   calculate the character, row, byte, and bit being affected, using the
\par   formulae as shown above. Line 125 signals the program is finished by
\par   changing the color of the top left corner of the screen. Line 130 freezes
\par   the program by putting it into an infinite loop. When you have finished
\par   looking at the display, just hold down <RUN/STOP> and hit <RESTORE>.
\par 
\par 
\par 
\par 
\par   126   PROGRAMMING GRAPHICS
\par \page 
\par 
\par 
\par     As a further example, you can modify the sine curve program to display
\par   a semicircle. Here are the lines to type to make the changes:
\par 
\par 
\par   50 FORX=0TO160:REM DO HALF THE SCREEN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  55 Y1=100+SQR(160*X-X*X)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  56 Y2=100-SQR(160*X-X*X)
\par   60 FORY=Y1TOY2STEPY1-Y2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 CH=INT(X/()
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  80 RO=INT(Y/X)
\par   85 LNYAND7
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 BY=BASE+RO*320+8*CH+LN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 BI=7-(XAND7)
\par   110 POKEBY,PEEK(BY)OR(2^BI)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  114 NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   This will create a semicircle in the HI-RES area of the screen.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par   | WARNING: BASIC variables can overlay your high-resolution screen. If  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | you need more memory space you must move the bottom of BASIC above the|
\par   | high-resolution screen area. Or, you must move your high-resolution   |
\par   | screen area. This problem will NOT occur in machine language. It ONLY |
\par   | happens when you're writing programs in BASIC.                        |
\par   +-----------------------------------------------------------------------+
\par 
\par   MULTI-COLOR BET MAP MODE
\par 
\par     Like multi-color mode characters, multi-color bit map mode allows you
\par   to display up to four different colors in each 8 by 8 section of bit map.
\par   And as in multi-character mode, there is a sacrifice of horizontal
\par   resolution (from 320 dots to 160 dots).
\par     Multi-color bit map mode uses an 8K section of memory for the bit map.
\par   You select your colors for multi-color bit map mode from (1) the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  background color register 0, (the screen background color), (2) the video
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  matrix (the upper 4 bits give one possible color, the lower 4 bits an-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  other), and (3) color memory.
\par     Multi-color bit mapped mode is turned ON by setting bit 5 of 53265
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ($D011) and bit 4 at location 53270 ($D016) to a 1. The following POKE
\par   does this:
\par 
\par     POKE 53265,PEEK(53625)OR 32: POKE 53270,PEEK(53270)OR 16
\par 
\par                                                  PROGRAMMING GRAPHICS   127
\par \page 
\par 
\par 
\par     Multi-color bit mapped mode is turned OFF by setting bit 5 of 53265
\par   ($D011) and bit 4 at location 53270 ($D016) to a 0. The following POKE
\par   does this:
\par 
\par     POKE 53265,PEEK(53265)AND 223: POKE 53270,PEEK(53270)AND 239
\par 
\par 
\par     As in standard (HI-RES) bit mapped mode, there is a one to one cor-
\par   respondence between the 8K section of memory being used for the display,
\par   and what is shown on the screen. However, the horizontal dots are two
\par   bits wide. Each 2 bits in the display memory area form a dot, which can
\par   have one of 4 colors.
\par 
\par 
\par 
\par     BITS    COLOR INFORMATION COMES FROM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     00     Background color #0 (screen color)
\par      01     Upper 4 bits of screen memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     10     Lower 4 bits of screen memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     11     Color nybble (nybble = 1/2 byte = 4 bits)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SMOOTH SCROLLING
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The VIC-II chip supports smooth scrolling in both the horizontal and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  vertical directions. Smooth scrolling is a one pixel movement of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  entire screen in one direction. It can move either UP, or down, or left,
\par   or right. It is used to move new information smoothly onto the screen,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  while smoothly removing characters from the other side.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    While the VIC-II chip does much of the task for you, the actual scroll-
\par   ing must be done by a machine language program. The VIC-II chip features
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the ability to place the video screen in any of 8 horizontal positions,
\par   and 8 vertical positions. Positioning is controlled by the VIC-II
\par   scrolling registers. The VIC-II chip also has a 38 column mode, and a 24
\par   row mode. the smaller screen sizes are used to give you a place for your
\par   new data to scroll on from.
\par 
\par   The following are the steps for SMOOTH SCROLLING:
\par 
\par 
\par 
\par   128   PROGRAMMING GRAPHICS
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   1) Shrink the screen (the border will expand).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  2) Set the scrolling register to maximum (or minimum value depending upon
\par      the direction of your scroll).
\par   3) Place the new data on the proper (covered) portion of the screen.
\par   4) Increment (or decrement) the scrolling register until it reaches the
\par      maximum (or minimum) value.
\par   5) At this point, use your machine language routine to shift the entire
\par      screen one entire character in the direction of the scroll.
\par   6) Go back to step 2.
\par 
\par     To go into 38 column mode, bit 3 of location 53270 ($D016) must be set
\par   to a 0. The following POKE does this:
\par 
\par     POKE 53270,PEEK(53270)AND 247
\par 
\par     To return to 40 column mode, set bit 3 of location 53270 ($D016) to a
\par   1.The following POKE does this:
\par 
\par     POKE 53270,PEEK(53270)OR 8
\par 
\par     To go into 24 row mode, bit 3 of location 53265 ($D011) must be set to
\par   a 0. The following POKE will do this:
\par 
\par     POKE 53265,PEEK(53265)AND 247
\par 
\par     To return to 25 row mode, set bit 3 of location 53265 ($D011) to a 1.
\par   The following POKE does this:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 53265,PEEK(53265)OR 8
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When scrolling in the X direction, it is necessary to place the VIC-II
\par   chip into 38 column mode. This gives new data a place to scroll from.
\par   When scrolling LEFT, the new data should be placed on the right. When
\par   scrolling RIGHT the new data should be placed on the left. Please note
\par   that there are still 40 columns to screen memory, but only 38 are
\par   visible.
\par     When scrolling in the Y direction, it is necessary to place the VIC-II
\par   chip into 24 row mode. When scrolling UP, place the new data in the LAST
\par   row. When scrolling DOWN, place the new data on the FIRST row. Unlike X
\par   scrolling, where there are covered areas on each side of the screen,
\par   there is only one covered area in Y scrolling. When the Y scrolling
\par 
\par 
\par                                                  PROGRAMMING GRAPHICS   129
\par \page 
\par 
\par 
\par   register is set to 0, the first line is covered, ready for new data. When
\par   the Y scrolling register is set to 7 the last row is covered.
\par     For scrolling in the X direction, the scroll register is located in
\par   bits 2 to 0 of the VIC-II control register at location 53270 ($D016 in
\par   HEX). As always, it is important to affect only those bits. The following
\par   POKE does this:
\par 
\par     POKE 53270,(PEEK(53270)AND 248)+X
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  where X is the X position of the screen from 0 to 7.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    For scrolling in the Y direction, the scroll register is located in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  bits 2 to 0 of the VIC-II control register at location 53265 ($D011 in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  HEX). As always, it is important to affect only those bits. The following
\par   POKE does this:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 53265,(PEEK(53265)AND 248)+Y
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  where Y is the Y position of the screen from 0 to 7.
\par     To scroll text onto the screen from the bottom, you would step the low-
\par   order 3 bits of location 53265 from 0-7, put more data on the covered
\par   line at the bottom of the screen, and then repeat the process. To scroll
\par   characters onto the screen from left to right, you would step the low-
\par   order 3 bits of location 53270 from 0 to 7, print or POKE another column
\par   of new data into column 0 of the screen, then repeat the process.
\par     If you step the scroll bits by -1, your text will move in the opposite
\par   direction.
\par 
\par   EXAMPLE: Text scrolling onto the bottom of the screen:
\par 
\par start tok64 page130.prg
\par   10 poke53265,peek(53265)and247        :rem go into 24 row mode
\par   20 printchr$(147)                     :rem clear the screen
\par   30 forx=1to24:printchr$(17);:next     :rem move the cursor to the bottom
\par   40 poke53265,(peek(53265)and248)+7:print :rem position for 1st scroll
\par   50 print"     hello";
\par   60 forp=6to0step-1
\par   70 poke53265,(peek(53265)and248)+p
\par   80 forx=1to50:next                    :rem delay loop
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 next:goto40
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {stop tok64
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   130   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SPRITES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     A SPRITE is a special type of user definable character which can be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  displayed anywhere on the screen. Sprites are maintained directly by the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VIC-II chip. And all you have to do is tell a sprite "what to look like,"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  "what color to be," and "where to appear." The VIC-II chip will do the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  rest! Sprites can be any of the 16 colors available.
\par     Sprites can be used with ANY of the other graphics modes, bit mapped,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  character, multi-color, etc., and they'll keep their shape in all of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  them. The sprite carries its own color definition, its own mode (HI-RES
\par   or multi-colored), and its own shape.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Up to 8 sprites at a time can be maintained by the VIC-II chip auto-
\par   matically. More sprites can be displayed using RASTER INTERRUPT
\par   techniques.
\par 
\par     The features of SPRITES include:
\par 
\par     1) 24 horizontal dot by 21 vertical dot size.
\par     2) Individual color control for each sprite.
\par     3) Sprite multi-color mode.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    4) Magnification (2x) in horizontal, vertical, or both directions.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    5) Selectable sprite to background priority.
\par     6) Fixed sprite to sprite priorities.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    7) Sprite to sprite collision detection.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    8) Sprite to background collision detection.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    These special sprite abilities make it simple to program many arcade
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  style games. Because the sprites are maintained by hardware, it is even
\par   possible to write a good quality game in BASIC!
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    There are 8 sprites supported directly by the VIC-II chip. They are
\par   numbered from 0 to 7. Each of the sprites has it own definition location,
\par   position registers and color register, and has its own bits for enable
\par   and collision detection.
\par 
\par 
\par   DEFINING A SPRITE
\par 
\par     Sprites are defined like programmable characters are defined. However,
\par   since the size of the sprite is larger, more bytes are needed. A sprite
\par   is 24 by 21 dots, or 504 dots. This works out to 63 bytes (504/8 bits)
\par 
\par                                                  PROGRAMMING GRAPHICS   131
\par \page 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          [THE PICTURE IS MISSING!]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    Figure 3-2. Sprite Definition Block.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  132   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  needed to define a sprite. The 63 bytes are arranged in 21 rows of 3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  bytes each. A sprite definition looks like this.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                           BYTE 0  BYTE 1  BYTE 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          BYTE 3  BYTE 4  BYTE 5
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          BYTE 6  BYTE 7  BYTE 8
\par                             ..      ..      ..
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            ..      ..      ..
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            ..      ..      ..
\par                           BYTE 60 BYTE 61 BYTE 62
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Another way to view how a sprite is created is to take a look at the
\par   sprite definition block on the bit level. It would look something like
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Figure 3-2.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    In a standard (HI-RES) sprite, each bit set to I is displayed in that
\par   sprite's foreground color. Each bit set to 0 is transparent and will
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  display whatever data is behind it. This is similar to a standard
\par   character.
\par     Multi-color sprites are similar to multi-color characters. Horizontal
\par   resolution is traded for extra color resolution. The resolution of the
\par   sprite becomes 12 horizontal dots by 21 vertical dots. Each dot in the
\par   sprite becomes twice as wide, but the number of colors displayable in the
\par   sprite is increased to 4.
\par 
\par 
\par   SPRITE POINTERS
\par 
\par     Even though each sprite takes only 63 bytes to define, one more byte
\par   is needed as a place holder at the end of each sprite. Each sprite, then,
\par   takes up 64 bytes. This makes it easy to calculate where in memory your
\par   sprite definition is, since 64 bytes is an even number and in binary it's
\par   an even power.
\par     Each of the 8 sprites has a byte associated with it called the SPRITE
\par   POINTER. The sprite pointers control where each sprite definition is lo-
\par   cated in memory. These 8 bytes are always located as the lost 8 bytes
\par   of the 1K chunk of screen memory. Normally, on the Commodore 64, this
\par   means they begin at location 2040 ($07F8 in HEX). However, if you move
\par   the screen, the location of your sprite pointers will also move.
\par     Each sprite pointer can hold a number from 0 to 255. This number points
\par   to the definition for that sprite. Since each sprite definition takes
\par   64 bytes, that means that the pointer can "see" anywhere in the 16K
\par   block of memory that the VIC-II chip can access (since 256*64=16K).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   133
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     If sprite pointer #0, at location 2040, contains the number 14, for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  example, this means that sprite 0 will be displayed using the 64 bytes
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  beginning at location 14*64 = 896 which is in the cassette buffer. The
\par   following formula makes this clear:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LOCATION = (BANK * 16384) + (SPRITE POINTER VALUE * 64)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Where BANK is the 16K segment of memory that the VIC-II chip is looking
\par   at and is from 0 to 3.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The above formula gives the start of the 64 bytes of the sprite
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  definition block.
\par     When the VIC-II chip is looking at BANK 0 or BANK 2, there is a ROM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  IMAGE of the character set present in certain locations, as mentioned
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  before. Sprite definitions can NOT be placed there. If for some reason
\par   you need more than 128 different sprite definitions, you should use one
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of the banks without the ROM IMAGE, 1 or 3.
\par 
\par 
\par   TURNING SPRITES ON
\par 
\par     The VIC-II control register at location 53269 ($D015 in HEX) is known
\par   as the SPRITE ENABLE register. Each of the sprites has a bit in this
\par   register which controls whether that sprite is ON or OFF. The register
\par   looks like this:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     $D015  7 6 5 4 3 2 1 0
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    To turn on sprite 1, for example, it is necessary to turn that bit to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a 1. The following POKE does this:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 53269.PEEK(53269)OR 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   A more general statement would be the following:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 53269,PEEK(53269)OR (2^SN)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  where SN is the sprite number, from 0 to 7.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTE: A sprite must be turned ON before it can be seen.               |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   134   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TURNING SPRITES OFF
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     A sprite is turned off by setting its bit in the VIC-II control
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  register at 53269 ($D015 in HEX) to a 0. The following POKE will do this:
\par 
\par     POKE 53269,PEEK(53269)AND(255-2^SN)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  where SN is the sprite number from 0 to 7.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  COLORS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    A sprite can be any of the 16 colors generated by the VIC-II chip. Each
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of the sprites has its own sprite color register. These are the memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  locations of the color registers:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par             ADDRESS         |          DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  --------------------------+----------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        53287   ($D027)     |    SPRITE 0 COLOR REGISTER
\par         53288   ($D028)     |    SPRITE 1 COLOR REGISTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        53289   ($D029)     |    SPRITE 2 COLOR REGISTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        53290   ($D02A)     |    SPRITE 3 COLOR REGISTER
\par         53291   ($D02B)     |    SPRITE 4 COLOR REGISTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        53292   ($D02C)     |    SPRITE 5 COLOR REGISTER
\par         53293   ($D02D)     |    SPRITE 6 COLOR REGISTER
\par         53294   ($D02E)     |    SPRITE 7 COLOR REGISTER
\par 
\par     All dots in the sprite will be displayed in the color contained in the
\par   sprite color register. The rest of the sprite will be transparent, and
\par   will show whatever is behind the sprite.
\par 
\par 
\par   MULTI-COLOR MODE
\par 
\par     Multi-color mode allows you to have up to 4 different colors in each
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sprite. However, just like other multi-color modes, horizontal resolution
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is cut in half. In other words, when you're working with sprite multi-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  color mode (like in multi-color character mode), instead of 24 dots
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  across the sprite, there are 12 pairs of dots. Each pair of dots is
\par   called a BIT PAIR. Think of each bit pair (pair of dots) as a single dot
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in your overall sprite when it comes to choosing colors for the dots in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  your sprites. The table below gives you the bit pair values needed to
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   135
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  turn ON each of the four colors you've chosen for your sprite:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    BIT PAIR                           DESCRIPTION
\par   -------------------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      00        TRANSPARENT, SCREEN COLOR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      01        SPRITE MULTI-COLOR REGISTER #0 (53285) ($D025)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      10        SPRITE COLOR REGISTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      11        SPRITE MULTI-COLOR REGISTER #I (53286) ($D026)
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTE: The sprite foreground color is a 10. The character foreground   |
\par   | is a 11.                                                              |
\par   +-----------------------------------------------------------------------+
\par 
\par   SETTING A SPRITE TO MULTI-COLOR MODE
\par 
\par     To switch a sprite into multi-color mode you must turn ON the VIC-II
\par   control register at location 53276 ($D01C). The following POKE does this:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 53276,PEEK(53276)OR(2^SN)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  where SN is the sprite number (0 to 7).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    To switch a sprite out of multi-color mode you must turn OFF the VIC-II
\par   control register at location 53276 ($D01C). The following POKE does this:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 53276,PEEK(53276)AND(255-2^SN)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  where SN is the sprite number (0 to 7).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXPANDED SPRITES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The VIC-II chip has the ability to expand a sprite in the vertical
\par   direction, the horizontal direction, or both at once. When expanded, each
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  dot in the sprite is twice as wide or twice as tall. Resolution doesn't
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  actually increase... the sprite just gets bigger.
\par     To expand a sprite in the horizontal direction, the corresponding bit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in the VIC-II control register at location 53277 ($D01D in HEX) must be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  turned ON (set to a 1). The following POKE expands a sprite in the X
\par   direction:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 53277,PEEK(53277)OR(2^SN)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  where SN is the sprite number from 0 to 7.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   136   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    To unexpand a sprite in the horizontal direction, the corresponding bit
\par   in the VIC-II control register at location 53277 ($D01D in HEX) must be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  turned OFF (set to a 0). The following POKE "unexpands" a sprite in the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  X direction:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 53277,PEEK(53277)AND (255-2^SN)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  where SN is the sprite number from 0 to 7.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    To expand a sprite in the vertical direction, the corresponding bit in
\par   the VIC-II control register at location 53271 ($D017 in HEX) must be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  turned ON (set to a 1). The following POKE expands a sprite in the Y
\par   direction:
\par 
\par     POKE 53271,PEEK(53271)OR(2^SN)
\par 
\par   where SN is the sprite number from 0 to 7.
\par 
\par     To unexpand a sprite in the vertical direction, the corresponding bit
\par   in the VIC-II control register at location 53271 ($D017 in HEX) must be
\par   turned OFF (set to a 0). The following POKE "unexpands" a sprite in the
\par   Y direction:
\par 
\par     POKE 53271,PEEK(53271)AND (255-2^SN)
\par 
\par   where SN is the sprite number from 0 to 7.
\par 
\par   SPRITE POSITIONING
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Once you've made a sprite you want to be able to move it around the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  screen. To do this, your Commodore 64 uses three positioning registers:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     1) SPRITE X POSITION REGISTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) SPRITE Y POSITION REGISTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) MOST SIGNIFICANT BIT X POSITION REGISTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Each sprite has an X position register, a Y position register, and a
\par   bit in the X most significant bit register. This lets you position your
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sprites very accurately. You can place your sprite in 512 possible X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  positions and 256 possible Y positions.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The X and Y position registers work together, in pairs, as a team. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  locations of the X and Y registers appear in the memory map as follows:
\par   First is the X register for sprite 0, then the Y register for sprite 0.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   137
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Next comes the X register for sprite 1, the Y register for sprite 1, and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  so on. After all 16 X and Y registers comes the most significant bit in
\par   the X position (X MSB) located in its own register.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The chart below lists the locations of each sprite position register.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  You use the locations at their appropriate time through POKE statements:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------------------+---------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     LOCATION      |                                                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+---------+                   DESCRIPTION                     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | DECIMAL |   HEX   |                                                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+---------+---------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  53248  | ($D000) |     SPRITE 0 X POSITION REGISTER                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  53249  | ($D001) |     SPRITE 0 Y POSITION REGISTER                  |
\par   |  53250  | ($D002) |     SPRITE 1 X POSITION REGISTER                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  53251  | ($D003) |     SPRITE 1 Y POSITION REGISTER                  |
\par   |  53252  | ($D004) |     SPRITE 2 X POSITION REGISTER                  |
\par   |  53253  | ($D005) |     SPRITE 2 Y POSITION REGISTER                  |
\par   |  53254  | ($D006) |     SPRITE 3 X POSITION REGISTER                  |
\par   |  53255  | ($D007) |     SPRITE 3 Y POSITION REGISTER                  |
\par   |  53256  | ($D008) |     SPRITE 4 X POSITION REGISTER                  |
\par   |  53257  | ($D009) |     SPRITE 4 Y POSITION REGISTER                  |
\par   |  53258  | ($D00A) |     SPRITE 5 X POSITION REGISTER                  |
\par   |  53259  | ($D00B) |     SPRITE 5 Y POSITION REGISTER                  |
\par   |  53260  | ($D00C) |     SPRITE 6 X POSITION REGISTER                  |
\par   |  53261  | ($D00D) |     SPRITE 6 Y POSITION REGISTER                  |
\par   |  53262  | ($D00E) |     SPRITE 7 X POSITION REGISTER                  |
\par   |  53263  | ($D00F) |     SPRITE 7 Y POSITION REGISTER                  |
\par   |  53264  | ($D010) |     SPRITE X MSB REGISTER                         |
\par   +---------+---------+---------------------------------------------------+
\par 
\par     The position of a sprite is calculated from the TOP LEFT corner of the
\par   24 dot by 21 dot area that your sprite can be designed in. It does NOT
\par   matter how many or how few dots you use to make up a sprite. Even if only
\par   one dot is used as a sprite, and you happen to want it in the middle of
\par   the screen, you must still calculate the exact positioning by starting at
\par   the top left corner location.
\par 
\par   VERTICAL POSITIONING
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Setting up positions in the horizontal direction is a little more
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  difficult than vertical positioning, so we'll discuss vertical (Y)
\par   positioning first.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  138   PROGRAMMING GRAPHICS
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     There are 200 different dot positions that can be individually pro-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  grammed onto your TV screen in the Y direction. The sprite Y position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  registers can handle numbers up to 255. This means that you have more
\par   than enough register locations to handle moving a sprite up and down. You
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  also want to be able to smoothly move a sprite on and off the screen.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  More than 200 values are needed for this.
\par     The first on-screen value from the top of the screen, and in the Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  direction for an unexpanded sprite is 30. For a sprite expanded in the Y
\par   direction it would be 9. (Since each dot is twice as tall, this makes a
\par   certain amount of sense, as the initial position is STILL calculated from
\par   the top left corner of the sprite.)
\par     The first Y value in which a sprite (expanded or not) is fully on the
\par   screen (all 21 possible lines displayed) is 50.
\par     The last Y value in which an unexpanded sprite is fully on the screen
\par   is 229. The last Y value in which an expanded sprite is fully on the
\par   screen is 208.
\par     The first Y value in which a sprite is fully off the screen is 250.
\par 
\par   EXAMPLE:
\par 
\par start tok64 page139.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 print"\{clear\}"                :rem clear screen
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  20 poke 2040,13                  :rem get sprite 0 data from block 13
\par   30 fori=0to62:poke832+i,129:next :rem poke sprite data into block 13
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  40 v=53248                       :rem set beginning of video chip
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  50 pokev+21,1                    :rem enable sprite 0
\par   60 pokev+39,1                    :rem set sprite 0 color
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 pokev+1,100                   :rem set sprite 0 y position
\par   80 pokev+16,0:pokev,100          :rem set sprite 0 x position
\par stop tok64
\par 
\par   HORIZONTAL POSITIONING
\par 
\par     Positioning in the horizontal direction is more complicated because
\par   there are more than, 256 positions. This means that an extra bit, or 9th
\par   bit is used to control the X position. By adding the extra bit when
\par   necessary a sprite now has 512 possible positions in the left/right, X,
\par   direction. This makes more possible combinations than can be seen on the
\par   visible part of the screen. Each sprite can have a position from 0 to
\par   511. However, only those values between 24 and 343 are visible on the
\par   screen. If the X position of a sprite is greater than 255 (on the right
\par   side of the screen), the bit in the X MOST SIGNIFICANT BIT POSITION
\par 
\par                                                  PROGRAMMING GRAPHICS   139
\par \page 
\par 
\par 
\par         0 ($00)  24 ($18)                     296 ($128)    344 ($158)
\par                                                        |    |
\par               |  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              |  |                                     +----+ 8 ($08)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              |                                        |    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     29 ($1D) |  +--+                                  |    |
\par               |  |  |                                  |    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 |  |                                  |    |
\par      50 ($32) +--+-------------------------------------+----+----+ 50 ($32)
\par               |  |  |                                  |    |    |
\par               |  |  |                                  |    |    |
\par               +--+--+                                  |    |    |
\par                  |                                     |    |    |
\par                  |                                     +----+----+
\par                  |                                          |
\par                  |           VISIBLE VIEWING AREA           |
\par                  |                                          |
\par                  |                                          |
\par                  |                                          |
\par                  |                                          |
\par                  |                                          |
\par                  |                                          |
\par                  |                                          |
\par                  |               NTSC*                      |
\par                  |               40 COLUMNS                 |
\par                  |               25 ROWS                    |
\par   208 ($D0) +----+----+                                     |
\par             |    |    |                                     |
\par             |    |    |                                  +--+--+ 299 ($E5)
\par             |    |    |                                  |  |  |
\par             |    |    |                                  |  |  |
\par   250 ($FA) +----+----+----------------------------------+--+--+ 250 ($FA)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 |    |                                  |  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {            |    |    |                                  |  |
\par             |    |    |                                  +--+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {            |    |    |
\par                  +----+                                  |  |
\par     488 ($1E8)
\par                  |                              320 ($140)  344 ($158)
\par                  24 ($18)
\par 
\par     *North American television transmission standards for your home TV.
\par 
\par   140   PROGRAMMING GRAPHICS
\par \page 
\par 
\par 
\par         7 ($07)  31 ($1F)                     287 ($11F)    335 ($14F)
\par                                                        |    |
\par               |  |
\par               |  |                                     +----+ 12 ($0C)
\par               |                                        |    |
\par      33 ($21) |  +--+                                  |    |
\par               |  |  |                                  |    |
\par                  |  |                                  |    |
\par      54 ($36) +--+-------------------------------------+----+----+ 54 ($36)
\par               |  |  |                                  |    |    |
\par               |  |  |                                  |    |    |
\par               +--+--+                                  |    |    |
\par                  |                                     |    |    |
\par                  |                                     +----+----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 |                                          |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 |           VISIBLE VIEWING AREA           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 |                                          |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 |                                          |
\par                  |                                          |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 |                                          |
\par                  |                                          |
\par                  |                                          |
\par                  |                                          |
\par                  |               NTSC*                      |
\par                  |               38 COLUMNS                 |
\par                  |               24 ROWS                    |
\par   204 ($CC) +----+----+                                     |
\par             |    |    |                                     |
\par             |    |    |                                  +--+--+ 225 ($E1)
\par             |    |    |                                  |  |  |
\par             |    |    |                                  |  |  |
\par   246 ($F6) +----+----+----------------------------------+--+--+ 246 ($F6)
\par                  |    |                                  |  |
\par             |    |    |                                  |  |
\par             |    |    |                                  +--+
\par             |    |    |
\par                  +----+                                  |  |
\par     480 ($1E0)
\par                  |                              311 ($137)  335 ($14F)
\par                  31 ($1F)
\par 
\par     *North American television transmission standards for your home TV.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   141
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  register must be set to a 1 (turned ON). If the X position of a sprite is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  less than 256 (on the left side of the screen), then the X MSB of that
\par   sprite must be 0 (turned OFF). Bits 0 to 7 of the X MSB register
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  correspond to sprites 0 to 7, respectively.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The following program moves a sprite across the screen:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par start tok64 p142_1.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 print"\{clear\}"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  20 poke2040,13
\par   30 fori=0to62:poke832+i,129:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  40 v=53248
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  50 pokev+21,1
\par   60 pokev+39,1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 pokev+1,100
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  80 forj=0to347
\par   90 hx=int(j/256):lx=j-256*hx
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 pokev,lx:pokev+16,hx:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {stop tok64
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When moving expanded sprites onto the left side of the screen in the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  X direction, you have to start the sprite OFF SCREEN on the RIGHT SIDE.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  This is because an expanded sprite is larger than the amount of space
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  available on the left side of the screen.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {start tok64 p142_2.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 print"\{clear\}"
\par   20 poke2040,13
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  30 fori=0to62:poke832+i,129:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  40 v=53248
\par   50 pokev+21,1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60 pokev+39,1:pokev+23,1:pokev+29,1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 pokev+1,100
\par   80 j=488
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 hx=int(j/256):lx=j-256*hx
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 pokev,lx:pokev+16,hx
\par   110 j=j+1:ifj>511thenj=0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  120 ifj>488orj<348goto90
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {stop tok64
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  142   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The charts in Figure 3-3 explain sprite positioning.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    By using these values, you can position each sprite anywhere. By moving
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the sprite a single dot position at a time, very smooth movement is easy
\par   to achieve.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SPRITE POSITIONING SUMMARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Unexpanded sprites are at least partially visible in the 40 column, by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  25 row mode within the following parameters:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                             1 < X < 343
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           30 < Y < 249
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  In the 38 column mode, the X parameters change to she following:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                            8 <= X <= 334
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  In the 24 row mode, the Y parameters change to the following:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          34 <= Y <= 245
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Expanded sprites are at least partially visible in the 40 column, by 25
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  row mode within the following parameters:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                          489 >= X <= 343
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           9 >= Y <= 249
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   In the 38 column mode, the X parameters change to the following:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         496 >= X <= 334
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  In the 24 row mode, the Y parameters change to the following:
\par 
\par                           13 <= Y <= 245
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   143
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SPRITE DISPLAY PRIORITIES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Sprites have the ability to cross each other's paths, as well as cross
\par   in front of, or behind other objects on the screen. This can give you a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  truly three dimensional effect for games.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Sprite to sprite priority is fixed. That means that sprite 0 has the
\par   highest priority, sprite 1 has the next priority, and so on, until we get
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to sprite 7, which has the lowest priority. In other words, if sprite 1
\par   and sprite 6 are positioned so that they cross each other, sprite 1 will
\par   be in front of sprite 6.
\par     So when you're planning which sprites will appear to be in the fore-
\par   ground of the picture, they must be assigned lower sprite numbers than
\par   those sprites you want to put towards the back of the scene. Those
\par   sprites will be given higher sprite numbers,
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE: A "window" effect is possible. If a sprite with higher priority |
\par   | has "holes" in it (areas where the dots are not set to 1 and thus     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | turned ON), the sprite with the lower priority will show through. This|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | also happens with sprite and background data.                         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Sprite to background priority is controllable by the SPRITE-BACK-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  GROUND priority register located at 53275 ($D01B). Each sprite has a bit
\par   in this register. If that bit is 0, that sprite has a higher priority
\par   than the background on the screen. In other words, the sprite appears in
\par   front of background data. If that bit is a 1, that sprite has a lower
\par   priority than the background. Then the sprite appears behind the back-
\par   ground data.
\par 
\par 
\par   COLLISION DETECTS
\par 
\par     One of the more interesting aspects of the VIC-II chip is its collision
\par   detection abilities. Collisions can be detected between sprites, or be-
\par   tween sprites and background data. A collision occurs when a non-zero
\par   part of a sprite overlaps a non-zero portion of another sprite or char-
\par   acters on the screen.
\par 
\par 
\par 
\par 
\par 
\par   144   PROGRAMMING GRAPHICS
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SPRITE TO SPRITE COLLISIONS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Sprite to sprite collisions are recognized by the computer, or flagged,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in the sprite to sprite collision register at location 53278 ($D01E in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  HEX) in the VIC-II chip control register. Each sprite has a bit in this
\par   register. If that bit is a 1, then that sprite is involved in a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  collision. The bits in this register will remain set until read (PEEKed).
\par   Once read, the register is automatically cleared, so it is a good idea to
\par   save the value in a variable until you are finished with it.
\par 
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE: Collisions can take place even when the sprites are off screen. |
\par   +-----------------------------------------------------------------------+
\par 
\par 
\par   SPRITE TO DATA COLLISIONS
\par 
\par     Sprite to data collisions are detected in the sprite to data collision
\par   register at location 53279 ($D01F in HEX) of the VIC-II chip control
\par   register.
\par     Each sprite has a bit in this register. If that bit is a 1 , then that
\par   sprite is involved in a collision. The bits in this register remain set
\par   until read (PEEKed). Once read, the register is automatically cleared, so
\par   it is a good idea to save the value in a variable until you are finished
\par   with it.
\par 
\par 
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTE: MULTI-COLOR data 01 is considered transparent for collisions,   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | even though it shows up on the screen. When setting up a background   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | screen, it is a good idea to make everything that should not cause a  |
\par   | collision 01 in multi-color mode.                                     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   145
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par start tok64 page146.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 rem sprite example 1... the hot air balloon
\par   30 vic=13*4096:rem this is where the vic registers begin
\par   35 pokevic+21,1:rem enable sprite 0
\par   36 pokevic+33,14:rem set background color to light blue
\par   37 pokevic+23,1:rem expand sprite 0 in y
\par   38 pokevic+29,1:rem expand sprite 0 in x
\par   40 poke2040,192:rem set sprite 0's pointer
\par   180 pokevic+0,100:rem set sprite 0's x position
\par   190 pokevic+1,100:rem set sprite 0's y position
\par   220 pokevic+39,1:rem set sprite 0's color
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  250 fory=0to63:rem byte counter with sprite loop
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  300 reada:rem read in a byte
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  310 poke192*64+y,a:rem store the data in sprite area
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  320 nexty:rem close loop
\par   330 dx=1:dy=1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  340 x=peek(vic):rem look at sprite 0's x position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  350 y=peek(vic+1):rem look at sprite 0's y position
\par   360 ify=50ory=208thendy=-dy:rem if y is on the edge of the...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  370 rem screen, then reverse delta y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  380 ifx=24and(peek(vic+16)and1)=0thendx=-dx:rem if sprite is touching...
\par   390 rem the left edge(x=24 and the msb for sprite 0 is 0), reverse it
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  400 ifx=40and(peek(vic+16)and1)=1thendx=-dx:rem if sprite is touching...
\par   410 rem the right edge (x=40 and the msb for sprite 0 is 1), reverse it
\par   420 ifx=255anddx=1thenx=-1:side=1
\par   430 rem switch to other side of the screen
\par   440 ifx=0anddx=-1thenx=256:side=0
\par   450 rem switch to other side of the screen
\par   460 x=x+dx:rem add delta x to x
\par   470 x=xand255:rem make sure x is in allowed range
\par   480 y=y+dy:rem add delta y to y
\par   485 pokevic+16,side
\par   490 pokevic,x:rem put new x value into sprite 0's x position
\par   510 pokevic+1,y:rem put new y value into sprite 0's y position
\par   530 goto340
\par   600 rem ***** sprite data *****
\par   610 data0,127,0,1,255,192,3,255,224,3,231,224
\par   620 data7,217,240,7,223,240,7,217,240,3,231,224
\par   630 data3,255,224,3,255,224,2,255,160,1,127,64
\par   640 data1,62,64,0,156,128,0,156,128,0,73,0,0,73,0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  650 data0,62,0,0,62,0,0,62,0,0,28,0,0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {stop tok64
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  146   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {start tok64 page147.prg
\par   10 rem sprite example 2...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  20 rem the hot air balloon again
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  30 vic=13*4096:rem this is where the vic registers begin
\par   35 pokevic+21,63:rem enable sprites 0 thru 5
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  36 pokevic+33,14:rem set background color to light blue
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  37 pokevic+23,3:rem expand sprites 0 and 1 in y
\par   38 pokevic+29,3:rem expand sprites 0 and 1 in x
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  40 poke2040,192:rem set sprite 0's pointer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  50 poke2041,193:rem set sprite 1's pointer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60 poke2042,192:rem set sprite 2's pointer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 poke2043,193:rem set sprite 3's pointer
\par   80 poke2044,192:rem set sprite 4's pointer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 poke2045,193:rem set sprite 5's pointer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 pokevic+4,30:rem set sprite 2's x position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  110 pokevic+5,58:rem set sprite 2's y position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  120 pokevic+6,65:rem set sprite 3's x position
\par   130 pokevic+7,58:rem set sprite 3's y position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  140 pokevic+8,100:rem set sprite 4's x position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  150 pokevic+9,58:rem set sprite 4's y position
\par   160 pokevic+10,100:rem set sprite 5's x position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  170 pokevic+11,58:rem set sprite 5's y position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  175 print"\{white\}\{clear\}"tab(15)"this is two hires sprites";
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  176 printtab(55)"on top of each other"
\par   180 pokevic+0,100:rem set sprite 0's x position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  190 pokevic+1,100:rem set sprite 0's y position
\par   200 pokevic+2,100:rem set sprite 1's x position
\par   210 pokevic+3,100:rem set sprite 1's y position
\par   220 pokevic+39,1:rem set sprite 0's color
\par   230 pokevic+41,1:rem set sprite 2's color
\par   240 pokevic+43,1:rem set sprite 4's color
\par   250 pokevic+40,6:rem set sprite 1's color
\par   260 pokevic+42,6:rem set sprite 3's color
\par   270 pokevic+44,6:rem set sprite 5's color
\par   280 forx=192to193:rem the start of the loop that defines the sprites
\par   290 fory=0to63:rem byte counter with sprite loop
\par   300 reada:rem read in a byte
\par   310 pokex*64+y,a:rem store the data in sprite area
\par   320 nexty,x:rem close loops
\par   330 dx=1:dy=1
\par   340 x=peek(vic):rem look at sprite 0's x position
\par   350 ify=50ory=208thendy=-dy:rem if y is on the edge of the...
\par 
\par 
\par 
\par 
\par 
\par   370 rem screen, then reverse delta y
\par   380 ifx=24and(peek(vic+16)and1)=0thendx=-dx:rem if sprite is...
\par   390 rem touching the left edge, then reverse it
\par   400 ifx=40and(peek(vic+16)and1)=1thendx=-dx:rem if sprite is...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  410 rem touching the right edge, then reverse it
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  420 ifx=255anddx=1thenx=-1:side=3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  430 rem switch to other side of the screen
\par   440 ifx=0anddx=-1thenx=256:side=0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  450 rem switch to other side of the screen
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  460 x=x+dx:rem add delta x to x
\par   470 x=xand255:rem make sure x is in allowed range
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  480 y=y+dy:rem add delta y to y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  485 pokevic+16,side
\par   490 pokevic,x:rem put new x value into sprite 0's x position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  500 pokevic+2,x:rem put new x value into sprite 1's x position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  510 pokevic+1,y:rem put new y value into sprite 0's y position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  520 pokevic+3,y:rem put new y value into sprite 1's y position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  530 goto340
\par   600 rem ***** sprite data *****
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  610 data0,255,0,3,153,192,7,24,224,7,56,224,14,126,112,14,126,112,14,126
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  620 data112,6,126,96,7,56,224,7,56,224,1,56,128,0,153,0,0,90,0,0,56,0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  630 data0,56,0,0,0,0,0,0,0,0,126,0,0,42,0,0,84,0,0,40,0,0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  640 data0,0,0,0,102,0,0,231,0,0,195,0,1,129,128,1,129,128,1,129,128
\par   650 data1,129,128,0,195,0,0,195,0,4,195,32,2,102,64,2,36,64,1,0,128
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  660 data1,0,128,0,153,0,0,153,0,0,0,0,0,84,0,0,42,0,0,20,0,0
\par stop tok64
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {start tok64 page148.prg
\par   10 rem sprite example 3...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  20 rem the hot air gorf
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  30 vic=53248:rem this is where the vic registers begin
\par   35 pokevic+21,1:rem enable sprite 0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  36 pokevic+33,14:rem set background color to light blue
\par   37 pokevic+23,1:rem expand sprite 0 in y
\par   38 pokevic+29,1:rem expand sprite 0 in x
\par 
\par 
\par 
\par 
\par 
\par   40 poke2040,192:rem set sprite 0's pointer
\par   50 pokevic+28,1:rem turn on multicolor
\par   60 pokevic+37,7:rem set multicolor 0
\par   70 pokevic+38,4:rem set multicolor 1
\par   180 pokevic+0,100:rem set sprite 0's x position
\par   190 pokevic+1,100:rem set sprite 0's y position
\par   220 pokevic+39,2:rem set sprite 0's color
\par   290 fory=0to63:rem byte counter with sprite loop
\par   300 reada:rem read in a byte
\par   310 poke12288+y,a:rem store the data in sprite area
\par   320 next y:rem close loop
\par   330 dx=1:dy=1
\par   340 x=peek(vic):rem look at sprite 0's x position
\par   350 y=peek(vic+1):rem look at sprite 0's y position
\par   360 ify=50ory=208then dy=-dy:rem if y is on the edge of the...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  370 rem screen, then reverse delta y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  380 ifx=24and(peek(vic+16)and1)=0thendx=-dx:rem if sprite is...
\par   390 rem touching the left edge, then reverse it
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  400 ifx=40and(peek(vic+16)and1)=1thendx=-dx:rem if sprite is...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  410 rem touching the right edge, then reverse it
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  420 ifx=255anddx=1thenx=-1:side=1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  430 rem switch to other side of the screen
\par   440 ifx=0anddx=-1thenx=256:side=0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  450 rem switch to other side of the screen
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  460 x=x+dx:rem add delta x to x
\par   470 x=xand255:rem make sure that x is in allowed range
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  480 y=y+dy:rem add delta y to y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  485 pokevic+16,side
\par   490 pokevic,x:rem put new x value into sprite 0's x position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  510 pokevic+1,y:rem put new y value into sprite 0's y position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  520 geta$:rem get a key from the keyboard
\par   521 ifa$="m"thenpokevic+28,1:rem user selected multicolor
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  522 ifa$="h"thenpokevic+28,0:rem user selected high resolution
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  530 goto340
\par   600 rem ***** sprite data *****
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  610 data64,0,1,16,170,4,6,170,144,10,170,160,42,170,168,41,105,104,169
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  620 data235,106,169,235,106,169,235,106,170,170,170,170,170,170,170,170
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  630 data170,170,170,170,166,170,154,169,85,106,170,85,170,42,170,168,10
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  640 data170,160,1,0,64,1,0,64,5,0,80,0
\par stop tok64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   149
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  OTHER GRAPHICS FEATURES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SCREEN BLANKING
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Bit 4 of the VIC-II control register controls the screen blanking func-
\par   tion. It is found in the control register at location 53265 ($D011). When
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  it is turned ON (in other words, set to a 1) the screen is normal. When
\par   bit 4 is set to 0 (turned OFF), the entire screen changes to border
\par   color.
\par     The following POKE blanks the screen. No data is lost, it just isn't
\par   displayed.
\par 
\par     POKE 53265,PEEK(53265)AND 239
\par 
\par   To bring back the screen. use the POKE shown below:
\par 
\par     POKE 53265,PEEK(53265)OR 16
\par   +-----------------------------------------------------------------------+
\par   | NOTE: Turning off the screen will speed up the processor slightly.    |
\par   | This means that program RUNning is also sped up.                     |
\par   +-----------------------------------------------------------------------+
\par 
\par   RASTER REGISTER
\par 
\par     The raster register is found in the VIC-II chip at location 53266
\par   ($D012). The raster register is a dual purpose register. When you read
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  this register it returns the lower 8 bits of the current raster position.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The raster position of the most significant bit is in register location
\par   53265 ($D011). You use the raster register to set up timing changes in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  your display so that you can get rid of screen flicker. The changes on
\par   your screen should be mode when the raster is not in the visible display
\par   area, which is when your dot positions fall between 51 and 251.
\par     When the raster register is written to (including the MSB) the number
\par   written to is saved for use with the raster compare function. When the
\par   actual raster value becomes the same as the number written to the raster
\par   register, a bit in the VIC-II chip interrupt register 53273 ($D019) is
\par   turned ON by setting it to 1.
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE: If the proper interrupt bit is enabled (turned on), an interrupt|
\par   | (IRQ) will occur.                                                     |
\par   +-----------------------------------------------------------------------+
\par 
\par   150   PROGRAMMING GRAPHICS
\par \page 
\par 
\par 
\par   INTERRUPT STATUS REGISTER
\par 
\par     The interrupt status register shows the current status of any interrupt
\par   source. The current status of bit 2 of the interrupt register will be a 1
\par   when two sprites hit each other. The same is true, in a corresponding 1
\par   to 1 relationship, for bits 0-3 listed in the chart below. Bit 7 is also
\par   set with a 1, whenever an interrupt occurs.
\par     The interrupt status register is located at 53273 ($D019) and is as
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  follows:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     LATCH  BIT#             DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------------------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    IRST    0   Set when current raster count = stored raster count
\par     IMDC    1   Set by SPRITE-DATA collision (1st one only, until reset)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    IMMC    2   Set by SPRITE-SPRITE collision (1st one only, until reset)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     ILP    3   Set by negative transition of light pen (1 per frame)
\par      IRQ    7   Set by latch set and enabled
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------------------------------------------------------------------------
\par     Once an interrupt bit has been set, it's "latched" in and must be
\par   cleared by writing a 1 to that bit in the interrupt register when you're
\par   ready to handle it. This allows selective interrupt handling, without
\par   having to store the other interrupt bits.
\par     The INTERRUPT ENABLE REGISTER is located at 53274 ($D01A). It has the
\par   same format as the interrupt status register. Unless the corresponding
\par   bit in the interrupt enable register is set to a 1, no interrupt from
\par   that source will take place. The interrupt status register can still be
\par   polled for information, but no interrupts will be generated.
\par     To enable an interrupt request the corresponding interrupt enable bit
\par   (as shown in the chart above) must be set to a 1.
\par     This powerful interrupt structure lets you use split screen modes. For
\par   instance you can have half of the screen bit mapped, half text, more than
\par   8 sprites at a time, etc. The secret is to use interrupts properly. For
\par   example, if you want the top half of the screen to be bit mapped and the
\par   bottom to be text, just set the raster compare register (as explained
\par   previously) for halfway down the screen. When the interrupt occurs, tell
\par   the VIC-II chip to get characters from ROM, then set the raster compare
\par   register to interrupt at the top of the screen. When the interrupt occurs
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  at the top of the screen, tell the VIC-II chip to get characters from RAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (bit map mode).
\par     You can also display more than 8 sprites in the same way. Unfortunately
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BASIC isn't fast enough to do this very well. So if you want to start
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  using display interrupts, you should work in machine language.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   151
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SUGGESTED SCREEN AND CHARACTER COLOR COMBINATIONS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Color TV sets are limited in their ability to place certain colors next
\par   to each other on the same line. Certain combinations of screen and char-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  acter colors produce blurred images. This chart shows which color com-
\par   binations to avoid, and which work especially well together.
\par 
\par                           CHARACTER COLOR
\par             0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
\par           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par          0| x| o| x| o| o| /| x| o| o| x| o| o| o| o| o| o|
\par           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par          1| o| x| o| x| o| o| o| x| /| o| /| o| o| x| o| o|
\par           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par          2| x| o| x| x| /| x| x| o| o| x| o| x| x| x| x| /|
\par           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par          3| o| x| x| x| x| /| o| x| x| x| x| /| x| x| /| x|
\par           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par          4| o| /| x| x| x| x| x| x| x| x| x| x| x| x| x| /|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         5| o| /| x| /| x| x| x| x| x| x| x| /| x| o| x| /|
\par           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SCREEN 6| /| o| x| o| x| x| x| x| x| x| x| x| x| /| o| o|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  COLOR   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         7| o| x| o| x| x| x| /| x| /| o| /| o| o| x| x| x|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par          8| /| o| o| x| x| x| x| o| x| o| x| x| x| x| x| /|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par          9| x| o| x| x| x| x| x| o| o| x| o| x| x| x| x| o|
\par           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par         10| /| /| o| x| x| x| x| /| x| o| x| x| x| x| x| /|   o = EXCELLENT
\par           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par         11| o| o| x| /| x| x| x| o| x| x| x| x| o| o| /| o|   / = FAIR
\par           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par         12| o| o| /| x| x| x| /| x| x| /| x| o| x| x| x| o|   x = POOR
\par           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par         13| o| x| x| x| x| o| /| x| x| x| x| o| x| x| x| x|
\par           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par         14| o| o| x| o| x| x| o| x| x| x| x| /| x| x| x| /|
\par           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par         15| o| o| o| x| /| /| o| x| x| /| /| o| o| x| /| x|
\par           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\par 
\par   152   PROGRAMMING GRAPHICS
\par \page 
\par 
\par 
\par   PROGRAMMING SPRITES - ANOTHER LOOK
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    For those of you having trouble with graphics, this section has been
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  designed as a more elementary tutorial approach to sprites.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   MAKING SPRITES IN BASIC - A SHORT PROGRAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    There are at least three different BASIC programming techniques which
\par   let you create graphic images and cartoon animations on the Commodore 64.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  You can use the computer's built-in graphics character set (see Page
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  376). You can program your own characters (see Page 108) or... best of
\par   all... you can use the computer's built-in "sprite graphics. To
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  illustrate how easy it is, here's one of the shortest spritemaking
\par   programs you can write in BASIC:
\par 
\par start tok64 page153.prg
\par   10 print"\{clear\}"
\par   20 poke2040,13
\par   30 fors=832to832+62:pokes,255:next
\par   40 v=53248
\par   50 pokev+21,1
\par   60 pokev+39,1
\par   70 pokev,24
\par   80 pokev+1,100
\par stop tok64
\par 
\par     This program includes the key "ingredients" you need to create any
\par   sprite. The POKE numbers come from the SPRITEMAKING CHART on Page 176.
\par   This program defines the first sprite... sprite 0... as a solid white
\par   square on the screen. Here's a line-by-line explanation of the program:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LINE 10 clears the screen.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LINE 20 sets the "sprite pointer" to where the Commodore 64 will read
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  its sprite data from. Sprite 0 is set at 2040, sprite 1 at 2041, sprite
\par   2 at 2042, and so on up to sprite 7 at 2047. You can set all 8 sprite
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  pointers to 13 by using this line in place of line 20:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     20 FOR SP=2040TO2047:POKE SP,13:NEXT SP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LINE 30 puts the first sprite (sprite 0) into 63 bytes of the Commodore
\par   64's RAM memory starting at location 832 (each sprite requires 63 bytes
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   153
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   of memory). The first sprite (sprite 0) is "addressed" at memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  locations 832 to 894.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     LINE 40 sets the variable "V" equal to 53248, the starting address of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the VIDEO CHIP. This entry lets us use the form (V+number) for sprite
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  settings. 're using the form (V+number) when POKEing sprite settings
\par   because this format conserves memory and lets us work with smaller
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  numbers. For example, in line 50 we typed POKE V+21. This is the same as
\par   typing POKE 53248+21 or POKE 53269... but V+21 requires less space than
\par   53269, and is easier to remember.
\par 
\par     LINE 50 enables or "turns on" sprite 0. There are 8 sprites, numbered
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  from 0 to 7. To turn on an individual sprite, or a combination of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sprites, all you have to do is POKE V+21 followed by a number from 0
\par   (turn all sprites off) to 255 (turn all 8 sprites on). You can turn on
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  one or more sprites by POKEing the following numbers:
\par   +------+------+------+------+------+------+------+------+------+-------+
\par   |ALL ON|SPRT 0|SPRT 1|SPRT 2|SPRT 3|SPRT 4|SPRT 5|SPRT 6|SPRT 7|ALL OFF|
\par   |  255 |   1  |   2  |   4  |   8  |  16  |  32  |  64  |  128 |   0   |
\par   +------+------+------+------+------+------+------+------+------+-------+
\par 
\par     POKE V+21,1 turns on sprite 0. POKE V+21,128 turns on sprite 7. You
\par   can also turn on combinations of sprites. For example, POKE V+21,129
\par   turns on both sprite 0 and sprite 7 by adding the two "turn on" numbers
\par   (1+128) together. (See SPRITEMAKING CHART, Page 176.)
\par 
\par     LINE 60 sets the COLOR of sprite 0. There are 16 possible sprite
\par   colors, numbered from 0 (black) to 15 (grey). Each sprite requires a
\par   different POKE to set its color, from V+39 to V+46. POKE V+39,1 colors
\par   sprite 0 white. POKE V+46,15 colors sprite 7 grey. (See the SPRITEMAKING
\par   CHART for more information.)
\par     When you create a sprite, as you just did, the sprite will STAY IN
\par   MEMORY until you POKE it off, redefine it, or turn off your computer.
\par   This lets you change the color, position and even shape of the sprite in
\par   DIRECT or IMMEDIATE mode, which is useful for editing purposes. As an
\par   example, RUN the program above, then type this line in DIRECT mode
\par   (without a line number) and hit the <RETURN> key:
\par 
\par     POKE V+39,8
\par 
\par     The sprite on the screen is now ORANGE. Try POKEing some other numbers
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  from 0 to 15 to see the other sprite colors. Because you did this in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   154   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  DIRECT mode, if you RUN your program the sprite will return to its origi-
\par   nal color (white).
\par 
\par     LINE 70, determines the HORIZONTAL or "X" POSITION of the sprite on the
\par   screen. This number represents the location of the UPPER LEFT CORNER of
\par   the sprite. The farthest left horizontal (X) position which you can see
\par   on your television screen is position number 24, although you can move
\par   the sprite OFF THE SCREEN to position number 0.
\par 
\par     LINE 80 determines the VERTICAL or "Y" POSITION of the sprite. In this
\par   program, we placed the sprite at X (horizontal) position 24, and Y
\par   (vertical) position 100. To try another location, type this POKE in
\par   DIRECT mode and hit <RETURN>:
\par 
\par     POKE V,24:POKE V+1,50
\par 
\par     This places the sprite at the upper left corner of the screen. To move
\par   the sprite to the lower left corner, type this:
\par 
\par     POKE V,24:POKE V+1,229
\par 
\par     Each number from 832 to 895 in our sprite 0 address represents one
\par   block of 8 pixels, with three 8-pixel blocks in each horizontal row of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the sprite. The loop in line 80 tells the computer to POKE 832,255 which
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  makes the first 8 pixels solid . . . then POKE 833,255 to make the second
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  8 pixels solid, and so on to location 894 which is the last group of 8
\par   pixels in the bottom right corner of the sprite. To better see how this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  works, try typing the following in DIRECT r-node, and notice that the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  second group of 8 pixels is erased:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE 833,0 (to put it back type POKE 833,255 or RUN your program)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The following line, which you can add to your program. erases the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  blocks in the MIDDLE of the sprite you created:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     90 FOR A=836 TO 891 STEP 3:POKE A,O:NEXT A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Remember, the pixels that make up the sprite are grouped in blocks of
\par   eight. This line erases the 5th group of eight pixels (block 836) and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  every third block up to block 890. Try POKEing any of the other numbers
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  from 832 to 894 with either a 255 to make them solid or 0 to make them
\par   blank.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   155
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | CRUNCHING YOUR SPRITE PROGRAMS                                        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |                                                                       |
\par   | Here's a helpful "crunching" tip: The program described above is      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | already short, but it can be made even shorter by "crunching" it      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | smaller. In our example we list the key sprite settings on separate   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | program lines so you can see what's happening in the program. In      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | actual practice, a good programmer would probably write this program  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | as a TWO LINE PROGRAM... by "crunching" it as follows:                |
\par   |                                                                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 10 PRINTCHR$(147):V=53248:POKEV+21,1:POKE2040.13:POKEV+39,1           |
\par   | 20 FORS=832TO894:POKES,255:NEXT:POKEV,24:POKEV+1,100                  |
\par   |                                                                       |
\par   | For more tips on how to crunch your programs so they fit in less      |
\par   | memory and run more efficiently, see the "crunching guide" on Page 24.|
\par   +-----------------------------------------------------------------------+
\par 
\par                                   TV SCREEN
\par             +---------------------------------------------------+
\par             |        ^                                          |
\par             |        |                                          |
\par             |<-------+---- X POSITION = HORIZONTAL ------------>|
\par             |        |                                          |
\par             |        |                                          |
\par             |        |                                          |
\par             |        |                                          |
\par             |        |                                          |
\par             |        |                          +-+             |
\par             |        |                          | |             |
\par             |        |                          +-+             |
\par             |        |                          /               |
\par             |        |                         /                |
\par             |        |                        /                 |
\par             |        |                       /                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {            +-------------------------------/-------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                           /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    A sprite located here must have both its X-position (horizontal) and
\par     Y-position (vertical) set so it can be displayed on the screen.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Figure 3-4. The display screen is divided into a grid of X and Y coor-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  dinates.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  156   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  POSITIONING SPRITES ON THE SCREEN
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The entire display screen is divided into a grid of X and Y coordi-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  nates, like a graph. The X COORDINATE is the HORIZONTAL position across
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the screen and the Y COORDINATE is the VERTICAL position up and down (see
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Figure 3-4).
\par     To position any sprite on the screen, you must POKE TWO SETTINGS...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the X position and the Y position... these tell the computer where to
\par   display the UPPER LEFT HAND CORNER of the sprite. Remember that a sprite
\par   consists of 504 individual pixels, 24 across by 21 down... so if you POKE
\par   a sprite onto the upper left corner of your screen, the sprite will be
\par   displayed as a graphic image 24 pixels ACROSS and 21 pixels DOWN starting
\par   at the X-Y position you defined. The sprite will be displayed based on
\par   the upper left corner of the entire sprite, even if you define the sprite
\par   using only a small part of the 24X21-pixel sprite area.
\par     To understand how X-Y positioning works, study the following diagram
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (Figure 3-5), which shows the X and Y numbers in relation to your display
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  screen. Note that the GREY AREA in the diagram shows your television
\par   viewing area... the white area represents positions which are OFF your
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  viewing screen...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                          [THE PICTURE IS MISSING!]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   157
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     To display a sprite in a given location, You must POKE the X and Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  settings for each SPRITE... remembering that every sprite has its own
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  unique X POKE and Y POKE. The X and Y settings for ail 8 sprites are
\par   shown here:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  POKE THESE VALUES TO SET X-Y SPRITE POSITIONS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------+-------+-------+-------+-------+-------+-------+-------+--------+
\par   |      |SPRT 0 |SPRT 1 |SPRT 2 |SPRT 3 |SPRT 4 |SPRT 5 |SPRT 6 |SPRT 7  |
\par   +------+-------+-------+-------+-------+-------+-------+-------+--------+
\par   |SET X |V,X    |V+2,X  |V+4,X  |V+6,X  |V+8,X  |V+10,X |V+12,X |V+14,X  |
\par   |SET Y |V+1,Y  |V+3,Y  |V+5,Y  |V+7,Y  |V+9,Y  |V+11,Y |V+13,Y |V+15,Y  |
\par   |RIGHTX|V+16,1 |V+16,2 |V+16,4 |V+16,8 |V+16,16|V+16,32|V+16,64|V+16,128|
\par   +------+-------+-------+-------+-------+-------+-------+-------+--------+
\par 
\par     POKEING AN X POSITION: The possible values of X are 0 to 255, counting
\par   from left to right. Values 0 to 23 place all or part of the sprite OUT OF
\par   THE VIEWING AREA off the left side of the screen... values 24 to 255
\par   place the sprite IN THE VIEWING AREA up to the 255th position (see next
\par   paragraph for settings beyond the 255th X position). To place the sprite
\par   at one of these positions, just type the X-POSITION POKE for the sprite
\par   you're using. For example, to POKE sprite I at the farthest left X
\par   position IN THE VIEWING AREA, type: POKE V+2,24.
\par 
\par     X VALUES BEYOND THE 255TH POSITION: To get beyond the 255th position
\par   across the screen, you need to make a SECOND POKE using the numbers in
\par   the "RIGHT X" row of the chart (Figure 3-5). Normally, the horizontal (X)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  numbering would continue past the 255th position to 256, 257, etc., but
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  because registers only contain 8 bits we must use a "second register" to
\par   access the RIGHT SIDE of the screen and start our X numbering over again
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  at 0. So to get beyond X position 255, you must POKE V+16 and a number
\par   (depending on the sprite). This gives you 65 additional X positions
\par   (renumbered from 0 to 65) in the viewing area on the RIGHT side of the
\par   viewing screen. (You can actually POKE the right side X value as high as
\par   255, which takes you off the right edge of the viewing screen.)
\par 
\par     POKEING A Y POSITION: The possible values of Y are 0 to 255, counting
\par   from top to bottom. Values 0 to 49 place all or part of the sprite OUT
\par   OF THE VIEWING AREA off the TOP of the screen. Values 50 to 229 place the
\par   sprite IN THE VIEWING AREA. Values 230 to 255 place all or part of the
\par   sprite OUT OF THE VIEWING AREA off the BOTTOM of the screen.
\par 
\par 
\par   158   PROGRAMMING GRAPHICS
\par \page 
\par 
\par 
\par     Let's see how this X-Y positioning works, using sprite 1. Type this
\par   program:
\par start tok64 page159.prg
\par   10 print"\{clear\}":v=53248:pokev+21,2:poke2041,13
\par   20 fors=832to895:pokes,255:next:pokev+40,7
\par   30 pokev+2,24
\par   40 pokev+3,50
\par stop tok64
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  This simple program establishes sprite 1 as a solid box and positions it
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  at the upper left corner of the screen. Now change line 40 to read:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     40 POKE V+3,229
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  This moves the sprite to the bottom left corner of the screen. Now let's
\par   test the RIGHT X LIMIT of the sprite. Change line 30 as shown:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 POKE V+2,255
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  This moves the sprite to the RIGHT but reaches the RIGHT X LIMIT, which
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is 255. At this point, the "most significant bit" in register 16 must be
\par   SET. In other words, you must type POKE V+ 16 and the number shown in the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  "RIGHT X" column in the X-Y POKE CHART above to RESTART the X position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  counter at the 256th pixel/position on the screen. Change line 30 as
\par   follows:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    30 POKE V+16,PEEK(V+16)OR 2:POKE V+2,0
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  POKE V+16,2 sets the most significant bit of the X position for sprite 1
\par   and restarts it at the 256th pixel/position on the screen. POKE V+2,0
\par   displays the sprite at the NEW POSITION ZERO, which is now reset to the
\par   256th pixel.
\par     To get back to the left side of the screen, you must reset the most
\par   significant bit of the X position counter to 0 by typing (for sprite 1):
\par 
\par     POKE V+16, PEEK(V+16)AND 253
\par 
\par     TO SUMMARIZE how the X positioning works... POKE the X POSITION for any
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sprite with a number from 0 to 255. To access a position beyond the 255th
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  position/pixel across the screen, you must use an additional POKE (V+16)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  which sets the most significant bit of the X position and start counting
\par   from 0 again at the 256th pixel across the screen.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   159
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  This POKE starts the X numbering over again from 0 at the 256th position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (Example: POKE V+16,PEEK(V+16)OR 1 and POKE V,1 must be included to place
\par   sprite 0 at the 257th pixel across the screen.) To get back to the left
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  side X positions you have to TURN OFF the control setting by typing
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  POKE V+16,PEEK(V+16)AND 254.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  POSITIONING MULTIPLE SPRITES ON THE SCREEN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Here's a program which defines THREE DIFFERENT SPRITES (0, 1 and 2) in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  different colors and places them in different positions on the screen:
\par 
\par start tok64 page160.prg
\par   10 print"\{clear\}":v=53248:fors=832to895:pokes,255:next
\par   20 form=2040to2042:pokem,13:next
\par   30 pokev+21,7
\par   40 pokev+39,1:pokev+40,7:pokev+41,8
\par   50 pokev,24:pokev+1,50
\par   60 pokev+2,12:pokev+3,229
\par   70 pokev+4,255:pokev+5,50
\par stop tok64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    For convenience, all 3 sprites have been defined as solid squares,
\par   getting their data from the same place. The important lesson here is how
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the 3 sprites are positioned. The white sprite 0 is at the top lefthand
\par   corner. The yellow sprite 1 is at the bottom lefthand corner but HALF the
\par   sprite is OFF THE SCREEN (remember, 24 is the leftmost X position in the
\par   viewing area... an X position less than 24 puts all or part of the sprite
\par   off the screen and we used an X position 12 here which put the sprite
\par   halfway off the screen). Finally, the orange sprite 2 is at the RIGHT X
\par   LIMIT (position 255)... but what if you want to display a sprite in the
\par   area to the RIGHT of X position 255?
\par 
\par   DISPLAYING A SPRITE BEYOND THE 255TH X-POSITION
\par 
\par     Displaying a sprite beyond the 255th X position requires a special POKE
\par   which SETS the most significant bit of the X position and starts over at
\par   the 256th pixel position across the screen. Here's how it works...
\par     First, you POKE V+16 with the number for the sprite you're using (check
\par   the "RIGHT X" row in the X-Y chart... we'll use sprite 0). Now we assign
\par   an X position, keeping in mind that the X counter starts over from 0 at
\par   the 256th position on the screen. Change line 50 to read as follows:
\par     50 POKE V+16,1:POKE V,24:POKE V+1,75
\par 
\par   160   PROGRAMMING GRAPHICS
\par \page 
\par 
\par 
\par   This line POKEs V+ 16 with the number required to "open up" the right
\par   side of the screen... the new X position 24 for sprite 0 now begins 24
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  pixels to the RIGHT of position 255. To check the right edge of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  screen, change line 60 to:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    60 POKE V+16,1:POKE V,65:POKE V+1,75
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Some experimentation with the settings in the sprite chart will give
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  you the settings you need to position and move sprites on the left and
\par   right sides of the screen. The section on "moving sprites" will also
\par   increase your understanding of how sprite positioning works.
\par 
\par   SPRITE PRIORITIES
\par 
\par     You can actually make different sprites seem to move IN FRONT OF or
\par   BEHIND each other on the screen. This incredible three dimensional illu-
\par   sion is achieved by the built-in SPRITE PRIORITIES which determine which
\par   sprites have priority over the others when 2 or more sprites OVERLAP on
\par   the screen.
\par     The rule is "first come, first served" which means lower-numbered
\par   sprites AUTOMATICALLY have priority over higher-numbered sprites. For
\par   example, if you display sprite 0 and sprite 1 so they overlap on the
\par   screen, sprite 0 will appear to be IN FRONT OF sprite 1. Actually, sprite
\par   0 always supersedes all the other sprites because it's the lowest num-
\par   bered sprite. In comparison, sprite 1 has priority over sprites 2-7;
\par   sprite 2 has priority over sprites 3-7, etc. Sprite 7 (the last sprite)
\par   has LESS PRIORITY than any of the other sprites, and will always appear
\par   to be displayed "BEHIND" any other sprites which overlap its position.
\par     To illustrate how priorities work, change lines 50, 60, and 70 in the
\par   program above to the following:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  50 POKEV,24:POKEV+1,50:POKEV+16,0
\par   60 POKEV+2,34:POKEV+3,60
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 POKEV+4,44:POKEV+5,70
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  You should see a white sprite on top of a yellow sprite on top of an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  orange sprite. Of course, now that you see how priorities work, you can
\par   also MOVE SPRITES and take advantage of these priorities in your ani-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  mation.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   161
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  DRAWING A SPRITE
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Drawing a Commodore sprite is like coloring the empty spaces in a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  coloring book. Every sprite consists of tiny dots called pixels. To draw
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a sprite, all you have to do is "color in" some of the pixels.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Look at the spritemaking grid in Figure 3-6. This is what a blank
\par   sprite looks like:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                         [THE PICTURE IS MISSING!]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      Figure 3-6. Spritemaking grid.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Each little "square" represents one pixel in the sprite. There are 24
\par   pixels across and 21 pixels up and down, or 504 pixels in the entire
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sprite. To make the sprite look like something, you have to color in
\par   these pixels using a special PROGRAM... but how can you control over 500
\par   individual pixels? That's where computer programming can help you. In-
\par   stead of typing 504 separate numbers, you only have to type 63 numbers
\par   for each sprite. Here's how it works...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  162   PROGRAMMING GRAPHICS
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   CREATING A SPRITE... STEP BY STEP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    To make this as easy as possible for you, we've put together this
\par   simple step by step guide to help you draw your own sprites.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STEP 1:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Write the spritemaking program shown here ON A PIECE OF PAPER... note
\par   that line 100 starts a special DATA section of your program which will
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  contain the 63 numbers you need to create your sprite.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        [THE PICTURE IS MISSING!]
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STEP 2:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Color in the pixels on the spritemaking grid on Page 162 (or use a piece
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of graph paper... remember, a sprite has 24 squares across and 21 squares
\par   down). We suggest you use a pencil and draw lightly so you can reuse this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  grid. You can create any image you like, but for our example we'll draw
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a simple box.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STEP 3:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Look at the first EIGHT pixels. Each column of pixels has a number (128,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  64, 32, 16, 8, 4, 2, 1). The special type of addition we are going to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  show you is a type of BINARY ARITHMETIC which is used by most computers
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                  PROGRAMMING GRAPHICS   163
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  as a special way of counting. Here's a close-up view of the first eight
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  pixels in the top left hand corner of the sprite:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       |128| 64| 32| 16|  8|  4|  2|  1|
\par        +---+---+---+---+---+---+---+---+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       |@@@|@@@|@@@|@@@|@@@|@@@|@@@|@@@|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       |@@@|@@@|@@@|@@@|@@@|@@@|@@@|@@@|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       +---+---+---+---+---+---+---+---+
\par   STEP 4:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Add up the numbers of the SOLID pixels. This first group of eight pixels
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is completely solid, so the total number is 255.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   STEP 5:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Enter that number as the FIRST DATA STATEMENT in line 100 of the
\par   Spritemaking Program below. Enter 255 for the second and third groups
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of eight.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   STEP 6:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Look at the FIRST EIGHT PIXELS IN THE SECOND ROW of the sprite. Add up
\par   the values of the solid pixels. Since only one of these pixels is solid,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the total value is 128. Enter this as the first DATA number in line 101.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par        |128| 64| 32| 16|  8|  4|  2|  1|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       +---+---+---+---+---+---+---+---+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       |@@@|   |   |   |   |   |   |   |
\par        |@@@|   |   |   |   |   |   |   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       +---+---+---+---+---+---+---+---+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STEP 7:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Add up the values of the next group of eight pixels (which is 0 because
\par   they're all BLANK) and enter in line 101. Now move to the next group of
\par   pixels and repeat the process for each GROUP OF EIGHT PIXELS (there are
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  3 groups across each row, and 21 rows). This will give you a total of 63
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  numbers. Each number represents ONE group of 8 pixels, and 63 groups of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  eight equals 504 total individual pixels. Perhaps a better way of looking
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  at the program is like this... each line in the program represents ONE
\par   ROW in the sprite. Each of the 3 numbers in each row represents ONE GROUP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  OF EIGHT PIXELS. And each number tells the computer which pixels to make
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SOLID and which pixels to leave blank.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  164   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STEP 8:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CRUNCH YOUR PROGRAM INTO A SMALLER SPACE BY RUNNING TOGETHER ALL THE DATA
\par   STATEMENTS, AS SHOWN IN THE SAMPLE PROGRAM BELOW. Note that we asked you
\par   to write your sprite program on a piece of paper. We did this for a good
\par   reason. The DATA STATEMENT LINES 100-120 in the program in STEP 1 are
\par   only there to help you see which numbers relate to which groups of pixels
\par   in your sprite. Your final program should be "crunched" like this:
\par 
\par start tok64 page165.prg
\par   10 print"\{clear\}":poke53280,5:poke53281,6
\par   20 v=53248:pokev+34,3
\par   30 poke 53269,4:poke2042,13
\par   40 forn=0to62:readq:poke832+n,q:next
\par   100 data255,255,255,128,0,1,128,0,1,128,0,1,144,0,1,144,0,1,144,0,1,144,0
\par   101 data1,144,0,1,144,0,1,144,0,1,144,0,1,144,0,1,144,0,1,128,0,1,128,0,1
\par   102 data128,0,1,128,0,1,128,0,1,128,0,1,255,255,255
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  200 x=200:y=100:poke53252,x:poke53253,y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {stop tok64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   MOVING YOUR SPRITE ON THE SCREEN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Now that you've created your sprite, let's do some interesting things
\par   with it. To move your sprite smoothly across the screen, add these two
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  lines to your program:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     50 POKE V+5,100:FOR X=24TO255:POKE V+4,X:NEXT:POKE V+16,4
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    55 FOR X=0TO65:POKE V+4,X:NEXT X:POKE V+16,0:GOTO 50
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     LINE 50 POKEs the Y POSITION at 100 (try 50 or 229 instead for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  variety). Then it sets up a FOR... NEXT loop which POKEs the sprite into
\par   X position 0 to X position 255, in order. When it reaches the 255th
\par   position, it POKEs the RIGHT X POSITION (POKE V+16,4) which is required
\par   to cross to the right side of the screen.
\par 
\par     LINE 55 has a FOR... NEXT loop which continues to POKE the sprite in
\par   the last 65 positions on the screen. Note that the X value was reset to
\par   zero but because you used the RIGHT X setting (POKE V+16,2) X starts over
\par   on the right side of the screen.
\par     This line keeps going back to itself (GOTO 50). If you just want the
\par   sprite to move ONCE across the screen and disappear, then take out
\par   GOTO50.
\par 
\par                                                  PROGRAMMING GRAPHICS   165
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Here's a line which moves the sprite BACK AND FORTH:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    50 POKE V+5,100:FOR X=24TO255:POKE V+4,X:NEXT:POKE V+16,4:
\par        FOR X=0TO65: POKE V+4,X: NEXT X
\par     55 FOR X=65TO0 STEP-1:POKE V+4,X:NEXT:POKE V+16,0: FOR
\par        X=255TO24 STEP-1: POKE V+4,X:NEXT
\par     60 GOTO 50
\par 
\par   Do you see how these programs work? This program is the same as the
\par   previous one, except when it reaches the end of the right side of the
\par   screen, it REVERSES ITSELF and goes back in the other direction. That is
\par   what the STEP-1 accomplishes... it tells the program to POKE the sprite
\par   into X values from 65 to 0 on the right side of the screen, then from 255
\par   to 0 on the left side of the screen, STEPping backwards minus-1 position
\par   at a time.
\par 
\par   VERTICAL SCROLLING
\par 
\par     This type of sprite movement is called "scrolling." To scroll your
\par   sprite up or down in the Y position, you only have to use ONE LINE. ERASE
\par   LINES 50 and 55 by typing the line numbers by themselves and hitting
\par   <RETURN> like this:
\par 
\par     50 <RETURN>
\par     60 <RETURN>
\par 
\par   Now enter LINE 50 again as follows:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    50 POKE V+4,24:FOR Y=0TO255:POKE V+5,Y:NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  THE DANCING MOUSE-A SPRITE PROGRAM EXAMPLE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Sometimes the techniques described in a programmer's reference manual
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  are difficult to understand, so we've put together a fun sprite program
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  called "Michael's Dancing Mouse." This program uses three different
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sprites in a cute animation with sound effects-and to help you understand
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  how it works we've included an explanation of EACH COMMAND so you can see
\par   exactly how the program is constructed:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  166   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {start tok64 page167.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  5 s=54272:pokes+24,15:pokes,220:pokes+1,68:pokes+5,15:pokes+6,215
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 pokes+7,120:pokes+8,100:pokes+12,15:pokes+13,215
\par   15 print"\{clear\}":v=53248:pokev+21,1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  20 fors1=12288to12350:readq1:pokes1,q1:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  25 fors2=12352to12414:readq2:pokes2,q2:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  30 fors3=12416to12478:readq3:pokes3,q3:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  35 pokev+39,15:pokev+1,68
\par   40 printtab(160)"\{white\}i am the dancing mouse!\{light blue\}"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  45 p=192
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  50 forx=0to347step3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  55 rx=int(x/256):lx=x-rx*256
\par   60 pokev,lx:pokev+16,rx
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 ifp=192thengosub200
\par   75 ifp=193thengosub300
\par   80 poke2040,p:fort=1to60:next
\par   85 p=p+1:ifp>194thenp=192
\par   90 next
\par   95 end
\par   100 data30,0,120,63,0,252,127,129,254,127,129,254,127,189,254,127,255,254
\par   101 data63,255,252,31,187,248,3,187,192,1,255,128,3,189,192,1,231,128,1,
\par   102 data255,0,31,255,0,0,124,0,0,254,0,1,199,32,3,131,224,7,1,192,1,192,0
\par   103 data3,192,0,30,0,120,63,0,252,127,129,254,127,129,254,127,189,254,127
\par   104 data255,254,63,255,252,31,221,248,3,221,192,1,255,128,3,255,192,1,195
\par   105 data128,1,231,3,31,255,255,0,124,0,0,254,0,1,199,0,7,1,128,7,0,204,1
\par   106 data128,124,7,128,5630,0,120,63,0,252,127,129,254,127,129,254,127,189
\par   107 data254,127,255,25463,255,252,31,221,248,3,221,192,1,255,134,3,189
\par   108 data204,1,199,152,1,255,48,1,255,224,1,252,0,3,254,0
\par   109 data7,14,0,204,14,0,248,56,0,112,112,0,0,60,0,-1
\par   200 pokes+4,129:pokes+4,128:return
\par   300 pokes+11,129:pokes+11,128:return
\par stop tok64
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   167
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   LINE 5:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    S=54272             Sets the variable 5 equal to 54272, which is the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        beginning memory location of the SOUND CHIP.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        From now on, instead of poking a direct memory
\par                         location, we will POKE S plus a value.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKES+24,15         Same as POKE 54296,15 which sets VOLUME to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        highest level.
\par     POKES,220           Same as POKE 54272,220 which sets Low Fre-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        quency in Voice 1 for a note which approximates
\par                         high C in Octave 6.
\par     POKES+1,68          Same as POKE 54273,68 which sets High Fre-
\par                         quency in Voice I for a note which approximates
\par                         high C in Octave 6.
\par     POKES+5,15          Same as POKE 54277,15 which sets Attack/Decay
\par                         for Voice 1 and in this case consists of the
\par                         maximum DECAY level with no attack, which pro-
\par                         duces the "echo" effect.
\par     POKES+6,215         Same as POKE 54278,215 which sets Sustain/Re-
\par                         lease for Voice 1 (215 represents a combination
\par                         of sustain and release values).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINE 10:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     POKES+7,120         Same as POKE 54279,120 which sets the Low Fre-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        quency for Voice 2.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKES+8,100         Same as POKE 54280,100 which sets the High
\par                         Frequency for Voice 2.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKES+12,15         Same as POKE 54284,15 which sets Attack/Decay
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        for Voice 2 to same level as Voice 1 above.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKES+13,215        Same as POKE 54285,215 which sets Sustain/Re-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        lease for Voice 2 to same level as Voice 1 above.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINE 15:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     PRINT"<SHIFT+CLR/HOME>" Clears the screen when the program begins.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    V=53248             Defines the variable "V" as the starting location
\par                         of the VIC chip which controls sprites. From now
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        on we will define sprite locations as V plus a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        value.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKEV+21,1          Turns on (enables) sprite number 1.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  168   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINE 20:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    FORS1=12288         We are going to use ONE SPRITE (sprite 0) in this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    TO 12350            animation, but we are going to use THREE sets of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        sprite data to define three separate shapes. To
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        get our animation, we will switch the POINTERS
\par                         for sprite 0 to the three places in memory where
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        we have stored the data which defines our three
\par                         different shapes. The same sprite will be rede-
\par                         fined rapidly over and over again as 3 different
\par                         shapes to produce the dancing mouse animation.
\par                         You can define dozens of sprite shapes in DATA
\par                         STATEMENTS, and rotate those shapes through
\par                         one or more sprites. So you see, you don't have to
\par                         limit one sprite to one shape or vice-versa. One
\par                         sprite can have many different shapes, simply by
\par                         changing the POINTER SETTING FOR THAT SPRITE to
\par                         different places in memory where the sprite data
\par                         for different shapes is stored. This line means we
\par                         have put the DATA for "sprite shape 1" at memory
\par                         locations 12288 to 12350.
\par 
\par     READ Q1             Reads 63 numbers in order from the DATA state-
\par                         ments which begin at line 100. Q1 is an arbitrary
\par                         variable name. It could just as easily be A, Z1 or
\par                         another numeric variable.
\par 
\par     POKES1,Q1           Pokes the first number from the DATA statements
\par                         (the first "Q1" is 30) into the first memory
\par                         location (the first memory location is 12288). This
\par                         is the same as POKE12288,30.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    NEXT                This tells the computer to look BETWEEN the FOR and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        NEXT parts of the loop and perform those in-between
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        commands (READQ1 and POKES1,Q1 using the NEXT
\par                         numbers in order). In other words, the NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        statement makes the computer READ the NEXT Q1 from
\par                         the DATA STATEMENTS, which is 0, and also
\par                         increments S1 by 1 to the next value, which is
\par                         12289. The result is POKE12289,0... the NEXT
\par                         command makes the loop keep going back until the
\par                         last values in the series, which are POKE 12350,0.
\par 
\par                                                  PROGRAMMING GRAPHICS   169
\par \page 
\par 
\par 
\par   LINE 25:
\par 
\par     FORS2=12352         The second shape of sprite zero is defined by the
\par     TO 12414            DATA which is located at locations 12352 to 12414.
\par                         NOTE that location 12351 is SKIPPED... this is the
\par                         64th location which is used in the definition of
\par                         the first sprite group but does not contain any of
\par                         the sprite data numbers. Just remember when
\par                         defining sprites in consecutive locations that you
\par                         will use 64 locations, but only POKE sprite data
\par                         into the first 63 locations.
\par 
\par     READQ2              Reads the 63 numbers which follow the numbers we
\par                         used for the first sprite shape. This READ simply
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        looks for the very next number in the DATA area and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        starts reading 63 numbers, one at a time.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKES2,Q2           Pokes the data (Q2) into the memory locations (S2)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        for our second sprite shape, which begins at
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        location 12352.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     NEXT                Same use as line 20 above.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   LINE 30:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    FORS3=12416         The third shape of sprite zero is defined by the
\par     TO 12478            DATA to be located at locations 12416 to 12478.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    READQ3              Reads last 63 numbers in order as Q3.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKES3,Q3           Pokes those numbers into locations 12416 to 12478.
\par     NEXT                Same as lines 20 and 25.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINE 35:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKEV+39,15         Sets color for sprite 0 to light grey.
\par 
\par     POKEV+1,68          Sets the upper right hand corner of the sprite
\par                         square to vertical (Y) position 68. For the sake of
\par                         comparison, position 50 is the top lefthand corner
\par                         Y position on the viewing screen.
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  170   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINE 40:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    PRINTTAB(160)       Tabs 160 spaces from the top lefthand CHARACTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        SPACE on the screen, which is the same as 4 rows
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        beneath the clear command... this starts your PRINT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        message on the 6th line down on the screen.
\par     "\{white\}            Hold down the <CTRL> key and press the key marked
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        <WHT> at the same time. If you do this inside
\par                         quotation marks, a "reversed E" will appear. This
\par                         sets the color to everything PRINTed from then on
\par                         to WHITE.
\par     I AM THE            This is a simple PRINT statement.
\par     DANCING
\par     MOUSE!
\par 
\par     \{light blue\}        This sets the color back to light blue when the
\par                         PRINT statement ends. Holding down <C=> and <7>
\par                         a at the same time inside quotation marks
\par                         causes a "reversed diamond symbol" to appear.
\par 
\par   LINE 45:
\par 
\par     P=192               Sets the variable P equal to 192. This number 192
\par                         is the pointer you must use, in this case to
\par                         "point" sprite 0 to the memory locations that begin
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        at location 12288. Changing this pointer to the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        locations of the other two sprite shapes is the
\par                         secret of using one sprite to create an animation
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        that is actually three different shapes.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINE 50:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     FORX=0TO347         Steps the movement of your sprite 3 X positions at
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    STEP3               a time (to provide fast movement) from position 0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        to position 347.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   171
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   LINE 55:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    RX=INT(X/256)       RX is the integer of X/256 which means that RX is
\par                         rounded off to 0 when X is less than 256, and RX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        becomes 1 when X reaches position 256. We will
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        use RX in a moment to POKE V+16 with a 0 or 1
\par                         to turn on the "RIGHT SIDE" of the screen.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LX=X-RX*256         When the sprite is at X position 0, the formula
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        looks like this: LX = 0 - (0 times 256) or 0. When
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        the sprite is at X position 1 the formula looks
\par                         like this: LX = 1 - (0 times 256) or 1. When the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        sprite is at X position 256 the formula looks like
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        this: LX = 256 - (1 times 256) or 0 which resets X
\par                         back to 0 which must be done when you start over on
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        the RIGHT SIDE of the screen (POKEV+16,1).
\par 
\par   LINE 60:
\par 
\par     POKEV,LX            You POKE V by itself with a value to set the Hori-
\par                         zontal (X) Position of sprite 0 on the screen. (See
\par                         SPRITEMAKING CHART on Page 176). As shown above,
\par                         the value of LX, which is the horizontal position
\par                         of the sprite, changes from 0 to 255 and when it
\par                         reaches 255 it automatically resets back to zero
\par                         because of the LX equation set up in line 55.
\par 
\par     POKEV+16,RX         POKEV+16 always turns on the "right side" of the
\par                         screen beyond position 256, and resets the
\par                         horizontal positioning coordinates to zero. RX is
\par                         either a 0 or a 1 based on the position of the
\par                         sprite as determined by the RX formula in line 55.
\par 
\par   LINE 70:
\par 
\par     IFP=192THEN         If the sprite pointer is set to 192 (the first
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    GOSUB200            sprite shape) the waveform control for the first
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        sound effect is set to 129 and 128 per line 200.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  172   PROGRAMMING GRAPHICS
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   LINE 75:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    IFP=193THEN         If the sprite pointer is set to 193 (the second
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    GOSUB300            sprite shape) the waveform control for the second
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        sound effect (Voice 2) is set to 129 and 128 per
\par                         line 300.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   LINE 80:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKE2040,P          Sets the SPRITE POINTER to location 192 (remember
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        P=192 in line 45? Here's where we use the P).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     FORT=1TO60:         A simple time delay loop which sets the speed at
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    NEXT                which the mouse dances. (Try a faster or slower
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        speed by increasing/decreasing the number 60.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINE 85:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    P=P+1               Now we increase the value of the pointer by adding
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        1 to the original value of P.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    IFP>194THEN         We only want to point the sprite to 3 memory lo-
\par     P=192               cations. 192 points to locations 12288 to 12350,
\par                         193 points to locations 12352 to 12414, and 194
\par                         points to locations 12416 to 12478. This line tells
\par                         the computer to reset P back to 192 as soon as P
\par                         becomes 195 so P never really becomes 195. P is
\par                         192, 193, 194 and then resets back to 192 and the
\par                         pointer winds up pointing consecutively to the
\par                         three sprite shapes in the three 64-byte groups of
\par                         memory locations containing the DATA.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                                  PROGRAMMING GRAPHICS   173
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINE 90:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     NEXTX               After the sprite has become one of the 3 different
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        shapes defined by the DATA, only then is it allowed
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        to move across the screen. It will jump 3 X
\par                         positions at a time (instead of scrolling smoothly
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        one position at a time, which is also possible).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        STEPping 3 positions at a time makes the mouse
\par                         "dance" faster across the screen. NEXT X matches
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        the FOR... X position loop in line 50.
\par 
\par   LINE 95
\par 
\par     END                 ENDs the program, which occurs when the sprite
\par                         moves off the screen.
\par 
\par   LINES 100-109
\par 
\par     DATA                The sprite shapes are read from the data numbers,
\par                         in order. First the 63 numbers which comprise
\par                         sprite shape 1 are read, then the 63 numbers for
\par                         sprite shape 2, and then sprite shape 3. This data
\par                         is permanently read into the 3 memory locations and
\par                         after it is read into these locations, all the
\par                         program has to do is point sprite 0 at the 3 memory
\par                         locations and the sprite automatically takes the
\par                         shape of the data in those locations. We are
\par                         pointing the sprite at 3 locations one at a time
\par                         which produces the "animation" effect. If you want
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        to see how these numbers affect each sprite, try
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        changing the first 3 numbers in LINE 100 to 255,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        255, 255. See the section on defining sprite shapes
\par                         for more information.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  174   PROGRAMMING GRAPHICS
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   LINE 200:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKES+4,129         Waveform control set to 129 turns on the sound
\par                         effect.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKES+4,128         Waveform control set to 128 turns off the sound
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        effect.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    RETURN              Sends program back to end of line 70 after
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        waveform control settings are changed, to resume
\par                         program.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINE 300:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKES+11,129        Waveform control set to 129 turns on the sound
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        effect.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    POKES+11,128        Waveform control set to 128 turns off the sound
\par                         effect.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    RETURN              Sends program back to end of line 75 to resume.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   175
\par \page 
\par 
\par 
\par   EASY SPRITEMAKING CHART
\par   +----------+------+------+------+------+-------+-------+-------+--------+
\par   |          |SPRT 0|SPRT 1|SPRT 2|SPRT 3|SPRT 4 |SPRT 5 |SPRT 6 | SPRT 7 |
\par   +----------+------+------+------+------+-------+-------+-------+--------+
\par   |Turn on   |V+21,1|V+21,2|V+21,4|V+21,8|V+21,16|V+21,32|V+21,64|V+21,128|
\par   +----------+------+------+------+------+-------+-------+-------+--------+
\par   |Put in mem| 2040,| 2041,| 2042,| 2043,| 2044, | 2045, | 2046, | 2047,  |
\par   |set point.|  192 |  193 |  194 |  195 |  196  |  197  |  198  |  199   |
\par   +----------+------+------+------+------+-------+-------+-------+--------+
\par   |Locations | 12288| 12352| 12416| 12480| 12544 | 12608 | 12672 | 12736  |
\par   |for Sprite|  to  |  to  |  to  |  to  |  to   |  to   |  to   |  to    |
\par   |Pixel     | 12350| 12414| 12478| 12542| 12606 | 12670 | 12734 | 12798  |
\par   +----------+------+------+------+------+-------+-------+-------+--------+
\par   |Color     |V+39,C|V+40,C|V+41,C|V+42,C|V+43,C |V+44,C |V+45,C |V+46,C  |
\par   +----------+------+------+------+------+-------+-------+-------+--------+
\par   |Set LEFT X| V+0,X| V+2,X| V+4,X| V+6,X| V+8,X |V+10,X |V+12,X |V+14,X  |
\par   +----------+------+------+------+------+-------+-------+-------+--------+
\par   |Set RIGHT |V+16,1|V+16,2|V+16,4|V+16,8|V+16,16|V+16,32|V+16,64|V+16,128|
\par   |X position| V+0,X| V+2,X| V+4,X| V+6,X| V+8,X |V+10,X |V+12,X |V+14,X  |
\par   +----------+------+------+------+------+-------+-------+-------+--------+
\par   |Set Y pos.| V+1,Y| V+3,Y| V+5,Y| V+7,Y| V+9,Y |V+11,Y |V+13,Y |V+15,Y  |
\par   +----------+------+------+------+------+-------+-------+-------+--------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |Exp. Horiz|V+29,1|V+29,2|V+29,4|V+29,8|V+29,16|V+29,32|V+29,64|V+29,128|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------+------+------+------+------+-------+-------+-------+--------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |Exp. Vert.|V+23,1|V+23,2|V+23,4|V+23,8|V+23,16|V+23,32|V+23,64|V+23,128|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------+------+------+------+------+-------+-------+-------+--------+
\par   |Multi-Col.|V+28,1|V+28,2|V+28,4|V+28,8|V+28,16|V+28,32|V+28,64|V+28,128|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------+------+------+------+------+-------+-------+-------+--------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |M-Color 1 |V+37,C|V+37,C|V+37,C|V+37,C|V+37,C |V+37,C |V+37,C |V+37,C  |
\par   +----------+------+------+------+------+-------+-------+-------+--------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |M-Color 2 |V+38,C|V+38,C|V+38,C|V+38,C|V+38,C |V+38,C |V+38,C |V+38,C  |
\par   +----------+------+------+------+------+-------+-------+-------+--------+
\par   |Priority  | The rule is that lower numbered sprites always have display|
\par   |of sprites| priority over higher numbered sprites. For example, sprite |
\par   |          | 0 has priority over ALL other sprites, sprite 7 has last   |
\par   |          | priority. This means lower numbered sprites always appear  |
\par   |          | to move IN FRONT OF or ON TOP OF higher numbered sprites.  |
\par   +----------+------------------------------------------------------------+
\par   |S-S Collis| V+30   IF PEEK(V+30)ANDX=X THEN [action]                   |
\par   +----------+------------------------------------------------------------+
\par   |S-B Collis| V+31   IF PEEK(V+31)ANDX=X THEN [action]                   |
\par   +----------+------------------------------------------------------------+
\par 
\par   176   PROGRAMMING GRAPHICS
\par \page 
\par 
\par 
\par   SPRITEMAKING NOTES
\par 
\par             Alternative Sprite Memory Pointers and Memory Locations
\par                             Using Cassette Buffer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------------+-------+-------+-------+-------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Put in Memory |SPRT 0 |SPRT 1 |SPRT 2 | If you're using 1 to 3 sprites|
\par   | (Set pointers)|2040,13|2041,14|2042,15| you can use these memory      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------------+-------+-------+-------+ locations in the cassette     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Sprite Pixel  | 832   | 896   | 960   | buffer (832 to 1023) but for  |
\par   | Locations for | to 894| to 958|to 1022| more than 3 sprites we suggest|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Blocks 13-15  |       |       |       | using locations from 12288 to |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------------+-------+-------+-------+ 12798 (see chart).            |
\par   TURNING ON SPRITES:                     +-------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    You can turn on any individual sprite by using POKE V+21 and the number
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  from the chart... BUT... turning on just ONE sprite will turn OFF any
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  others. To turn on TWO OR MORE sprites, ADD TOGETHER the numbers of the
\par   sprites you want to turn on (Example: POKE V+21, 6 turns on sprites 1 and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  2). Here is a method you can use to turn one sprite off and on without
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  affecting any of the others (useful for animation).
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     To turn off just sprite 0 type: POKE V+21,PEEK V+21AND(255-1). Change
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the number 1 in (255-1) to 1,2,4,8,16,32,64, or 128 (for sprites 0-7). To
\par   re-enable the sprite and not affect the other sprites currently turned
\par   on, POKE V+21, PEEK(V+21)OR 1 and change the OR 1 to OR 2 (sprite 2), OR
\par   4 (sprite 3), etc.
\par 
\par   X POSITION VALUES BEYOND 255:
\par 
\par     X positions run from 0 to 255... and then START OVER from 0 to 255. To
\par   put a sprite beyond X position 255 on the far right side of the screen,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  you must first POKE V+ 16 as shown, THEN POKE a new X valve from 0 to 63,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  which will place the sprite in one of the X positions at the right side
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of the screen. To get back to positions 0-255, POKE V+16,0 and POKE in an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  X value from 0 to 255.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Y POSITION VALUES:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Y positions run from 0 to 255, including 0 to 49 off the TOP of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  viewing area, 50 to 229 IN the,viewing area, and 230 to 255 off the
\par   BOTTOM of the viewing area.
\par                                                  PROGRAMMING GRAPHICS   177
\par \page 
\par 
\par 
\par   SPRITE COLORS:
\par 
\par     To make sprite 0 WHITE, type: POKE V+39,1 (use COLOR POKE SETTING shown
\par   in chart, and INDIVIDUAL COLOR CODES shown below):
\par 
\par     0-BLACK     4-PURPLE        8-ORANGE        12-MED. GREY
\par     1-WHITE     5-GREEN         9-BROWN         13-LT. GREEN
\par     2-RED       6-BLUE          10-LT. RED      14-LT. BLUE
\par     3-CYAN      7-YELLOW        11-DARK GREY    15-LT. GREY
\par 
\par   MEMORY LOCATION:
\par 
\par     You must "reserve" a separate 64-BYTE BLOCK of numbers in the
\par   computer's memory for each sprite of which 63 BYTES will be used for
\par   sprite data. The memory settings shown below are recommended for the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  "sprite pointer" settings in the chart above. Each sprite will be unique
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and you'll have to define it as you wish. To make all sprites exactly the
\par   same, point the sprites you want to look the same to the same register
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  for sprites.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   DIFFERENT SPRITE POINTER SETTINGS:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    These sprite pointer settings are RECOMMENDATIONS ONLY.
\par     Caution: you can set your sprite pointers anywhere in RAM memory but if
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  you set them too "low" in memory a long BASIC program may overwrite your
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sprite data, or vice versa. To protect an especially LONG BASIC PROGRAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  from overwriting sprite data, you may want to set the sprites at a higher
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  area of memory (for example, 2040,192 for sprite 0 at locations 12288 to
\par   12350... 2041,193 at locations 12352 to 12414 for sprite 1 and so on...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  by adjusting the memory locations from which sprites get their "data,"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  you can define as many as 64 different sprites plus a sizable BASIC
\par   program. To do this, define several sprite "shapes" in your DATA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  statements and then redefine a particular sprite by changing the
\par   "pointer" so the sprite you are using is "pointed" at different areas of
\par   memory containing different sprite picture data. See the "Dancing Mouse"
\par   to see how this works. If you want two or more sprites to have THE SAME
\par   SHAPE (you can still change position and color of each sprite), use the
\par   same sprite pointer and memory location for the sprites you want to match
\par   (for example, you can point sprites 0 and 1 to the same location by using
\par   POKE 2040,192 and POKE 2041, 192).
\par 
\par 
\par 
\par   178   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PRIORITY:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Priority means one sprite will appear to move "in front of" or "behind"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  another sprite on the display screen. Sprites with more priority always
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  appear to move "in front of" or "on top of" sprites with less priority.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The rule is that lower numbered sprites have priority over higher
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  numbered sprites. Sprite 0 has priority over all other sprites. Sprite 7
\par   has no priority in relation to the other sprites. Sprite 1 has priority
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  over sprites 2-7, etc. If you put two sprites in the some position, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sprite with the higher priority will appear IN FRONT OF the sprite with
\par   the lower priority. The sprite with lower priority will either be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  obscured, or will "show through" (from "behind") the sprite with higher
\par   priority.
\par 
\par   USING MULTI-COLOR:
\par 
\par     You can create multi-colored sprites although using multi-color mode
\par   requires that you use PAIRS of pixels instead of individual pixels in
\par   your sprite picture (in other words each colored "dot" or "block" in the
\par   sprite will consist of two pixels side by side). You have 4 colors to
\par   choose from: Sprite Color (chart,above), Multi-Color 1, Multi-Color 2 and
\par   "Background Color" (background is achieved by using zero settings which
\par   let the background color "show through"). Consider one horizontal 8-pixel
\par   block in a sprite picture. The color of each PAIR of pixels is determined
\par   according to whether the left, right, or both pixels are solid, like
\par   this:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-+-+
\par   | | | BACKGROUND      (Making BOTH PIXELS BLANK (zero) lets the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-+-+                  INNER SCREEN COLOR (background)show through.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-+-+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | |@| MULTI-COLOR 1   (Making the RIGHT PIXEL SOLID in a pair of pixels
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-+-+                  sets BOTH PIXELS to Multi-Color 1.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-+-+
\par   |@| | SPRITE COLOR    (Making the LEFT PIXEL SOLID in a pair of pixels
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-+-+                  sets BOTH PIXELS to Sprite Color.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-+-+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |@|@| MULTI-COLOR 2   (Making BOTH PIXELS SOLID in a pair of pixels
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-+-+                  sets BOTH PIXELS to Multi-Color 2.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   179
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Look at the horizontal 8-pixel row shown below. This block sets the first
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  two pixels to background color, the second two pixels to Multi-Color 1,
\par   the third two pixels to Sprite Color and the fourth two pixels to Multi-
\par   Color 2. The color of each PAIR of pixels depends on which bits in each
\par   pair are solid and which are blank, according to the illustration above.
\par   After you determine which colors you want in each pair of pixels, the
\par   next step is to add the values of the solid pixels in the 8-pixel block,
\par   and POKE that number into the proper memory location. For example, if the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  8-pixel row shown below is the first block in a sprite which begins at
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  memory location 832, the value of the solid pixels is 16+8+2+1 27, so you
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  would POKE 832,27.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     |128| 64| 32| 16|  8|  4|  2|  1|   16+8+2+1 = 27
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     +---+---+---+---+---+---+---+---+
\par                      |   |   |   |@@@|@@@|   |@@@|@@@|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     |   |   |   |@@@|@@@|   |@@@|@@@|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     +---+---+---+---+---+---+---+---+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         LOOKS LIKE THIS IN SPRITE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                      +-------+-------+-------+-------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     |BACKGR.|MULTI- |SPRITE |MULTI- |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     | COLOR |COLOR 1| COLOR |COLOR 2|
\par                      +-------+-------+-------+-------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  COLLISION:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     You can detect whether a sprite has collided with another sprite by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  using this line: IF PEEK(V+30)ANDX=XTHEN [insert action here]. This line
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  checks to see if a particular sprite has collided with ANY OTHER SPRITE,
\par   where X equals 1 for sprite 0, 2 for sprite 1, 4 for sprite 2, 8 for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sprite 3, 16 for sprite 4, 32 for sprite 5, 64 for sprite 6, and 128 for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sprite 7. To check to see if the sprite has collided with a "BACKGROUND
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CHARACTER" use this line: IF PEEK(V+31)ANDX=XTHEN [insert action here].
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  180   PROGRAMMING GRAPHICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  USING GRAPHIC CHARACTERS IN DATA STATEMENTS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The following program allows you to create a sprite using blanks and
\par   solid circles <SHIFT+Q> in DATA statements. The sprite and the numbers
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  POKED into the sprite data registers are displayed.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {start tok64 page181.prg
\par   10 print"\{clear\}":fori=0to63:poke832+i,0:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  20 gosub60000
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  999 end
\par   60000 data"         QQQQQQQ        "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60001 data"       QQQQQQQQQQQ      "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60002 data"      QQQQQQQQQQQQQ     "
\par   60003 data"      QQQQQ   QQQQQ     "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60004 data"     QQQQQ QQQ  QQQQ    "
\par   60005 data"     QQQQQ QQQ QQQQQ    "
\par   60006 data"     QQQQQ QQQ  QQQQ    "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60007 data"      QQQQQ   QQQQQ     "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60008 data"      QQQQQQQQQQQQQ     "
\par   60009 data"      QQQQQQQQQQQQQ     "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60010 data"      Q QQQQQQQQQ Q     "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60011 data"       Q QQQQQQQ Q      "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60012 data"       Q  QQQQQ  Q      "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60013 data"        Q  QQQ  Q       "
\par   60014 data"        Q  QQQ  Q       "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60015 data"         Q  Q  Q        "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60016 data"         Q  Q  Q        "
\par   60017 data"          QQQQQ         "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60018 data"          QQQQQ         "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60019 data"          QQQQQ         "
\par   60020 data"           QQQ          "
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60100 v=53248:pokev,200:pokev+1,100:pokev+21,1:pokev+39,14:poke2040,13
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60105 pokev+23,1:pokev+29,1
\par   60110 fori=0to20:reada$:fork=0to2:t=0:forj=0to7:b=0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60140 ifmid$(a$,j+k*8+1,1)="Q"thenb=1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60150 t=t+b*2^(7-j):next:printt;:poke832+i*3+k,t:next:print:next
\par   60200 return
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {stop tok64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 PROGRAMMING GRAPHICS   181
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 CHAPTER 4
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                               PROGRAMMING
\par                                                  SOUND AND
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                             MUSIC ON YOUR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                              COMMODORE 64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Introduction
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                               Volume Control
\par                                Frequencies of Sound Waves
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Using Multiple Voices
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Changing Waveforms
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o The Envelope Generator
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Filtering
\par                            o Advanced Techniques
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Synchronization and Ring
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                             Modulation
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     183
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   INTRODUCTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Your Commodore computer is equipped with one of the most sophisticated
\par   electronic music synthesizers available on any computer. It comes
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  complete with three voices, totally addressable, ATTACK/DECAY/SUSTAIN/
\par   RELEASE (ADSR), filtering, modulation, and "white noise." All of these
\par   capabilities are directly available for you through a few easy to use
\par   BASIC and/or assembly language statements and functions. This means that
\par   you can make very complex sounds and songs using programs that are
\par   relatively simple to design.
\par     This section of your Programmer's Reference Guide has been created to
\par   help you explore all the capabilities of the 6581 "SID" chip, the sound
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and music synthesizer inside your Commodore computer. We'll explain both
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the theory behind musical ideas and the practical aspects of turning
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  those ideas into real finished songs on your Commodore computer.
\par     You need not be an experienced programmer nor a music expert to achieve
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  exciting results from the music synthesizer. This section is full of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  programming examples with complete explanations to get you started.
\par     You get to the sound generator by POKEing into specified memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  locations. A full list of the locations used is provided in Appendix O.
\par   We will go through each concept, step by step. By the end you should be
\par   able to create an almost infinite variety of sounds, and be ready to
\par   perform experiments with sound on your own.
\par     Each section of this chapter begins by giving you an example and a full
\par   line-by-line description of each program, which will show you how to use
\par   the characteristic being discussed. The technical explanation is for you
\par   to read whenever you are curious about what is actually going on. The
\par   workhorse of your sound programs is the POKE statement. POKE sets the
\par   indicated memory location (MEM) equal to a specified value (NUM).
\par 
\par     POKE MEM,NUM
\par 
\par 
\par     The memory locations (MEM) used for music synthesis start at 54272
\par   ($D400) in the Commodore 64. The memory locations 54272 to 54296
\par   inclusive are the POKE locations you need to remember when you're using
\par   the 6581 (SID) chip register map. Another way to use the locations above
\par   is to remember only location 54272 and then add a number from 0 through
\par   24 to it. By doing this you can POKE all the locations from 54272 to
\par   54296 that you need from the SID chip. The numbers (NUM) that you use in
\par   your POKE statement must be between 0 and 255, inclusive.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   184   PROGRAMMING SOUND AND MUSIC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When you've had a little more practice with making music, then you can
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  get a little more involved, by using the PEEK function. PEEK is a
\par   function that is equal to the value currently in the indicated memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  location.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    X=PEEK(MEM)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The value of the variable X is set equal to the current contents of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  memory location MEM.
\par     Of course, your programs include other BASIC commands, but for a full
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  explanation of them, refer to the BASIC Statements section of this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  manual.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Let's jump right in and try a simple program using only one of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  three voices. Computer ready? Type NEW, then type in this program, and
\par   save it on your Commodore DATASSETTE(TM) or disk. Then, RUN it.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE PROGRAM 1:
\par start tok64 page185.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  5 s=54272
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 forl=stos+24:pokel,0:next:rem clear sound chip
\par   20 pokes+5,9:pokes+6,0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  30 pokes+24,15              :rem set volume to maximum
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  40 readhf,lf,dr
\par   50 ifhf<0thenend
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60 pokes+1,hf:pokes,lf
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 pokes+4,33
\par   80 fort=1todr:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 pokes+4,32:fort=1to50:next
\par   100 goto40
\par   110 data25,177,250,28,214,250
\par   120 data25,177,250,25,177,250
\par   130 data25,177,125,28,214,125
\par   140 data32,94,750,25,177,250
\par   150 data28,214,250,19,63,250
\par   160 data19,63,250,19,63,250
\par   170 data21,154,63,24,63,63
\par   180 data25,177,250,24,63,125
\par   190 data19,63,250,-1,-1,-1
\par stop tok64
\par 
\par     Here's a line-by-line description of the program you've just typed in.
\par   Refer to it whenever you feel the need to investigate parts of the pro-
\par   gram that you don't understand completely.
\par 
\par                                           PROGRAMMING SOUND AND MUSIC   185
\par \page 
\par 
\par 
\par   LINE-BY-LINE EXPLANATION OF EXAMPLE PROGRAM 1:
\par 
\par   +--------+--------------------------------------------------------------+
\par   | Line(s)|                         Description                          |
\par   +--------+--------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 5      | Set S to start of sound chip.                                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 10     | Clear all sound chip registers.                              |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 20     | Set Attack/Decay for voice 1 (A=O,D=9).                      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |        | Set Sustain/Release for voice 1 (S=O,R=O),                   |
\par   | 30     | Set volume at maximum.                                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 40     | Read high frequency, low frequency, duration of note.        |
\par   | 50     | When high frequency less than zero, song is over.            |
\par   | 60     | Poke high and low frequency of voice 1.                      |
\par   | 70     | Gate sawtooth waveform for voice 1.                          |
\par   | 80     | Timing loop for duration of note.                            |
\par   | 90     | Release sawtooth waveform for voice 1.                       |
\par   | 100    | Return for next note.                                        |
\par   | 110-180| Data for song: high frequency, low frequency, duration       |
\par   |        | (number of counts) for each note.                            |
\par   | 190    | Last note of song and negative Is signaling end of song.     |
\par   +--------+--------------------------------------------------------------+
\par 
\par   VOLUME CONTROL
\par 
\par     Chip register 24 contains the overall volume control. The volume can be
\par   set anywhere between 0 and 15. The other four bits are used for purposes
\par   we'll get into later. For now it is enough to know volume is 0 to 15.
\par   Look at line 30 to see how it's set in Example Program 1.
\par 
\par   FREQUENCIES OF SOUND WAVES
\par 
\par     Sound is created by the movement of air in waves. Think of throwing a
\par   stone into a pool and seeing the waves radiate outward. When similar
\par   waves are created in air, we hear it. If we measure the time between one
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  peak of a wave and the next, we find the number of seconds for one cycle
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of the wave (n = number of seconds). The reciprocal of this number (1/n)
\par   gives you the cycles per second. Cycles per second are more commonly
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  known as the frequency. The highness or lowness of a sound (pitch) is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  determined by the frequency of the sound waves produced.
\par     The sound generator in your Commodore computer uses two locations to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  determine the frequency. Appendix E gives you the frequency values you
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  need to reproduce a full eight octaves of musical notes. To create a
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  186   PROGRAMMING SOUND AND MUSIC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  frequency other than the ones listed in the note table use "Fout" (fre-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  quency output) and the following formula to represent the frequency (Fn)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of the sound you want to create. Remember that each note requires both a
\par   high and a low frequency number.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {             Fn = Fout/.06097
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Once you've figured out what Fn is for your "new" note the next step is
\par   to create the high and low frequency values for that note. To do this you
\par   must first round off Fn so that any numbers to the right of the decimal
\par   point are left off. You are now left with an integer value. Now you can
\par   set the high frequency location (Fhi) by using the formula
\par   Fhi=INT(Fn/256) and the low frequency location (Flo) should be
\par   Flo=Fn-(256*Fhi).
\par     At this point you have already played with one voice of your computer.
\par   If you wanted to stop here you could find a copy of your favorite tune
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and become the maestro conducting your own computer orchestra in your "at
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  home" concert hall.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  USING MULTIPLE VOICES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Your Commodore computer has three independently controlled voices
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (oscillators). Our first example program used only one of them. later on,
\par   you'll learn how to change the quality of the sound made by the voices.
\par   But right now, let's get all three voices singing.
\par     This example program shows you one way to translate sheet music for
\par   your computer orchestra. Try typing it in, and then SAVE it on your
\par   DATASSETTE(TM) or disk. Don't forget to type NEW before typing in this
\par   program.
\par 
\par   EXAMPLE PROGRAM 2:
\par 
\par start tok64 page187.prg
\par   10 s=54272:forl=stos+24:pokel,0:next
\par   20 dimh(2,200),l(2,200),c(2,200)
\par   30 dimfq(11)
\par   40 v(0)=17:v(1)=65:v(2)=33
\par   50 pokes+10,8:pokes+22,128:pokes+23,244
\par   60 fori=0to11:readfq(i):next
\par   100 fork=0to2
\par   110 i=0
\par   120 readnm
\par 
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  130 ifnm=0then250
\par   140 wa=v(k):wb=wa-1:ifnm<0thennm=-nm:wa=0:wb=0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  150 dr%nm/128:oc%=(nm-128*dr%)/16
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  160 nt=nm-128*dr%-16*oc%
\par   170 fr=fq(nt)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  180 ifoc%=7then200
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  190 forj=6tooc%step-1:fr=fr/2:next
\par   200 hf%=fr/256:lf%=fr-256*hf%
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  210 ifdr%=1thenh(k,i)=hf%:l(k,i)=lf%:c(k,i)=wa:i=i+1:goto120
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  220 forj=1todr%-1:h(k,i)=hf%:l(k,i)=lf%:c(k,i)=wa:i=i+1:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  230 h(k,i)=hf%:l(k,i)=lf%:c(k,i)=wb
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  240 i=i+1:goto120
\par   250 ifi>imthenim=i
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  260 next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  500 pokes+5,0:pokes+6,240
\par   510 pokes+12,85:pokes+13,133
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  520 pokes+19,10:pokes+20,197
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  530 pokes+24,31
\par   540 fori=0toim
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  550 pokes,l(0,i):pokes+7,l(1,i):pokes+14,l(2,i)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  560 pokes+1,h(0,i):pokes+8,h(1,i):pokes+15,h(2,i)
\par   570 pokes+4,c(0,i):pokes+11,c(1,i):pokes+18,c(2,i)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  580 fort=1to80:next:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  590 fort=1to200:next:pokes+24,0
\par   600 data34334,36376,38539,40830
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  610 data43258,45830,48556,51443
\par   620 data54502,57743,61176,64814
\par   1000 data594,594,594,596,596,1618,587,592,587.585,331,336
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  1010 data1097,583,585,585,585,587,587,1609,585,331,337,594,594,593
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  1020 data1618,594,596,594,592,587,1616,587,585,331,336,841,327
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  1999 data1607,0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  2000 data583,585,583,583,327,329,1611,583,585,578,578,578
\par   2010 data196,198,583,326,578,326,327,329,327,329,326,578,583
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  2020 data1606,582,322,324,582,587,329,327,1606,583,327,329,587,331,329
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  2999 data329,328,1609,578,834,324,322,327,585,1602,0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  3000 data567,566,567,304,306,308,310,1591,567,311,310,567
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  3010 data306,304,299,308,304,171,176,306,291,551,306,308
\par   3020 data310,308,310,306,295,297,299,304,1586,562,567,310,315,311
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  3030 data308,313,297,1586,567,560,311,309,308,309,306,308
\par   3999 data1577,299,295,306,310,311,304,562,546,1575,0
\par stop tok64
\par 
\par 
\par 
\par   188   PROGRAMMING SOUND AND MUSIC
\par \page 
\par 
\par 
\par     Here is a line,-by-line explanation of Example Program 2. For now, we
\par   are interested in how the three voices are controlled.
\par 
\par   LINE-BY-LINE EXPLANATION OF EXAMPLE PROGRAM 2:
\par 
\par   +---------+-------------------------------------------------------------+
\par   | Line(s) |                       Description                           |
\par   +---------+-------------------------------------------------------------+
\par   | 10      | Set S equal to start of sound chip and clear all sound      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         | chip registers.                                             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 20      | Dimension arrays to contain activity of song, 1/16th of a   |
\par   |         | measure per location.                                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 30      | Dimension array to contain base frequency for each note.    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 40      | Store waveform control byte for each voice.                 |
\par   | 50      | Set high pulse width for voice 2.                           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         | Set high frequency for filter cutoff.                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         | Set resonance for filter and filter voice 3.                |
\par   | 60      | Read in base frequency for each note.                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 100     | Begin decoding loop for each voice.                         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 110     | Initialize pointer to activity array.                       |
\par   | 120     | Read coded note.                                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 130     | If coded note is zero, then next voice.                     |
\par   | 140     | Set waveform controls to proper voice.                      |
\par   |         | If silence, set waveform controls to 0.                     |
\par   | 150     | Decode duration and octave.                                 |
\par   | 160     | Decode note.                                                |
\par   | 170     | Get base frequency for this note.                           |
\par   | 180     | If highest octave, skip division loop.                      |
\par   | 190     | Divide base frequency by 2 appropriate number of times.     |
\par   | 200     | Get high and low frequency bytes.                           |
\par   | 210     | If sixteenth note, set activity array: high frequency, low  |
\par   |         | frequency, and waveform control (voice on).                 |
\par   | 220     | For all but last beat of note, set activity array: high     |
\par   |         | frequency, low frequency, waveform control (voice on).      |
\par   | 230     | For last beat of note, set activity array: high frequency,  |
\par   |         | low frequency, waveform control (voice off).                |
\par   | 240     | Increment pointer to activity array. Get next note.         |
\par   | 250     | If longer than before, reset number of activities.          |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 260     | Go back for next voice.                                     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 500     | Set Attack/Decay for voice 1 (A=0, D=0).                    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         | Set Sustain/Release for voice 1 (S=15, R=0).                |
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                          PROGRAMMING SOUND AND MUSIC   189
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Line(s) |                       Description                           |
\par   +---------+-------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 510     | Set Attack/Decay for voice 2 (A=5, D=5).                    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         | Set Sustain/Release for voice 2 (S=8, R=5).                 |
\par   | 520     | Set Attack/Decay for voice 3 (A=O, D=10).                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         | Set Sustain/Release for voice 3 (S=12, R=5).                |
\par   | 530     | Set volume 15, low-pass filtering.                          |
\par   | 540     | Start loop for every 1/16th of a measure.                   |
\par   | 550     | POKE low frequency from activity array for all voices.      |
\par   | 560     | POKE high frequency from activity array for all voices.     |
\par   | 570     | POKE waveform control from activity array for all voices.   |
\par   | 580     | Timing loop for 1/16th of a measure and back for next       |
\par   |         | 1/16th measure.                                             |
\par   | 590     | Pause, then turn off volume.                                |
\par   | 600-620 | Base frequency data.                                        |
\par   |1000-1999| Voice 1 data.                                               |
\par   |2000-2999| Voice 2 data.                                               |
\par   |3000-3999| Voice 3 data.                                               |
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The values used in the data statements were found by using the note
\par   table in Appendix E and the chart below:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                     +-----------------+------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    |   NOTE TYPE     |  DURATION  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    +-----------------+------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    |        1/16     |     128    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    |        1/8      |     256    |
\par                     | DOTTED 1/8      |     384    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    |        1/4      |     512    |
\par                     |    1/4+1/16     |     640    |
\par                     | DOTTED 1/4      |     768    |
\par                     |        1/2      |    1024    |
\par                     |    1/2+1/16     |    1152    |
\par                     |    1/2+1/8      |    1280    |
\par                     | DOTTED 1/2      |    1536    |
\par                     |  WHOLE          |    2048    |
\par                     +-----------------+------------+
\par 
\par 
\par 
\par   190   PROGRAMMING SOUND AND MUSIC
\par \page 
\par 
\par 
\par     The note number from the note table is added to the duration above.
\par   Then each note can be entered using only one number which is decoded by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  your program. This is only one method of coding note values. You may be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  able to come up with one with which you are more comfortable. The formula
\par   used here for encoding a note is as follows:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) The duration (number of 1/16ths of a measure) is multiplied by 8.
\par     2) The result of step 1 is added to the octave you've chosen (0-7).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) The result of step 2 is then multiplied by 16.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    4) Add your note choice (0-11) to the result of the operation in step
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       3.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   In other words:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            ((((D*8)+O)*16)+N)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Where D = duration, O = octave, and N = note
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    A silence is obtained by using the negative of the duration number
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (number of 1/16ths of a measure * 128).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   CONTROLLING MULTIPLE VOICES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Once you have gotten used to using more than one voice, you will find
\par   that the timing of the three voices needs to be coordinated. This is ac-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  complished in this program by:
\par 
\par     1) Divide each musical measure into 16 parts.
\par     2) Store the events that occur in each 1/16th measure interval in three
\par        separate arrays.
\par 
\par     The high and low frequency bytes are calculated by dividing the fre-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  quencies of the highest octave by two (lines 180 and 190). The waveform
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  control byte is a start signal for beginning a note or continuing a note
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  that is already playing. It is a stop signal to end a note. The waveform
\par   choice is made once for each voice in line 40.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Again, this is only one way to control multiple voices. You may come
\par   up with your own methods. However, you should now be able to take any
\par   piece of sheet music and figure out the notes for all three voices.
\par 
\par 
\par 
\par 
\par 
\par                                           PROGRAMMING SOUND AND MUSIC   191
\par \page 
\par 
\par 
\par   CHANGING WAVEFORMS
\par 
\par     The tonal quality of a sound is called the timbre. The timbre of a
\par   sound is determined primarily by its "waveform." If you remember the
\par   example of throwing a pebble into the water you know that the waves
\par   ripple evenly across the pond. These waves almost look like the first
\par   sound wave we're going to talk about, the sinusoidal wave, or sine wave
\par   for short (shown below).
\par 
\par 
\par                               +               +
\par                             +   +           +   +
\par                            /     \\         /     \\
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         ./.......\\......./.......\\.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                   \\     /
\par                                     +   +
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      +
\par 
\par 
\par     To make what we're talking about a bit more practical, let's go back to
\par   the first example program to investigate different waveforms. The reason
\par   for this is that you can hear the changes more easily using only one
\par   voice. LOAD the first music program that you typed in earlier, from your
\par   DATASSETTE(TM) or disk, and RUN it again. That program is using the
\par   sawtooth waveform (shown here)
\par 
\par 
\par                               +       +       +
\par                              /|      /|      /|
\par                             / |     / |     / |
\par                            /  |    /  |    /  |
\par                          ./...|.../...|.../...|.....
\par                               |  /    |  /    |  /
\par                               | /     | /     | /
\par                               |/      |/      |/
\par                               +       +       +
\par 
\par 
\par   from the 6581 SID chip's sound generating device. Try changing the note
\par   start number in line 70 from 33 to 17 and the note stop number in line 90
\par   from 32 to 16. Your program should now look like this:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  192   PROGRAMMING SOUND AND MUSIC
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLE PROGRAM 3 (EXAMPLE 1 MODIFIED):
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {start tok64 page193.prg
\par   5 s=54272
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 forl=stos+24:pokel,0:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  20 pokes+5,9:pokes+6,0
\par   30 pokes+24,15
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  40 readhf,lf,dr
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  50 ifhf<0thenend
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60 pokes+1,hf:pokes,lf
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 pokes+4,17
\par   80 fort=1todr:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 pokes+4,16:fort=1to50:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 goto40
\par   110 data25,177,250,28,214,250
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  120 data25,177,250,25,177,250
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  130 data25,177,125,28,214,125
\par   140 data32,94,750,25,177,250
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  150 data28,214,250,19,63,250
\par   160 data19,63,250,19,63,250
\par   170 data21,154,63,24,63,63
\par   180 data25,177,250,24,63,125
\par   190 data19,63,250,-1,-1,-1
\par stop tok64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Now RUN the program.
\par     Notice how the sound quality is different, less twangy, more hollow.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  That's because we changed the sawtooth waveform into a triangular
\par   waveform (shown left). The third musical waveform is called a variable
\par   pulse wave (shown right).
\par 
\par               +               +          +----+  +----+  +----+  |
\par              / \\             / \\         |    |  |    |  |    |  |
\par             /   \\           /   \\        |    |  |    |  |    |  |
\par            /     \\         /     \\       |    |  |    |  |    |  |
\par          ./.......\\......./.......\\.    .|....|..|....|..|....|..|.
\par                    \\     /               |    |  |    |  |    |  |
\par                     \\   /                |    |  |    |  |    |  |
\par                      \\ /                 |    |  |    |  |    |  |
\par                       +                  |    +--+    +--+    +--+
\par                                                   <-->
\par                                               PULSE WIDTH
\par 
\par                                           PROGRAMMING SOUND AND MUSIC   193
\par \page 
\par 
\par 
\par     It is a rectangular wave and you determine the length of the pulse
\par   cycle by defining the proportion of the wave which will be high. This is
\par   accomplished for voice 1 by using registers 2 and 3: Register 2 is the
\par   low byte of the pulse width (Lpw = 0 through 255). Register 3 is the high
\par   4 bits (Hpw = 0 through 15).
\par     Together these registers specify a 12-bit number for your pulse width,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  which you can determine by using the following formula:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                         PWn = Hpw*256 + Lpw
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The pulse width is determined by the following equation:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       PWout = (PWn/40.95) %
\par 
\par     When PWn has a value of 2048, it will give you a square wave. That
\par   means that register 2 (Lpw) = 0 and register 3 (Hpw) = 8.
\par     Now try adding this line to your program:
\par 
\par     15 POKES+3,8:POKES+2,0
\par 
\par   Then change the start number in line 70 to 65 and the stop number in fine
\par   90 to 64, and RUN the program. Now change the high pulse width (register
\par   3 in line 15) from an 8 to a 1. Notice how dramatic the difference in
\par   sound quality is?
\par     The last waveform available to you is white noise (shown here).
\par 
\par                                    .   .       .
\par                           .     . .          .   .
\par                            .  .     .       .
\par                          ...........................
\par                              . . .        .
\par                                       .  . .  .
\par                             .                   . .
\par 
\par   It is used mostly for sound effects and such. To hear how it sounds, try
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  changing the start number in line 70 to 129 and the stop number in line
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 to 128.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   UNDERSTANDING WAVEFORMS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When a note is played, it consists of a sine wave oscillating at the
\par   fundamental frequency and the harmonics of that wave.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  194   PROGRAMMING SOUND AND MUSIC
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The fundamental frequency defines the overall pitch of the note.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Harmonics are sine waves having frequencies which are integer multiples
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of the fundamental frequency. A sound wave is the fundamental frequency
\par   and all of the harmonics it takes to make up that sound.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                        [THE PICTURE IS MISSING!]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    In musical theory let's say that the fundamental frequency is harmonic
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  number 1. The second harmonic has a frequency twice the fundamental
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  frequency, the third harmonic is three times the fundamental frequency,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and so on. The amounts of each harmonic present in a note give it its
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  timbre.
\par     An acoustic instrument, like a guitar or a violin, has a very compli-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cated harmonic structure. In fact, the harmonic structure may vary as a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   single note is played. You have already played with the waveforms
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  available in your Commodore music synthesizer. Now let's talk about how
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the harmonics work with the triangular, sawtooth, and rectangular waves.
\par     A triangular wave contains only odd harmonics. The amount of each
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  harmonic present is proportional to the reciprocal of the square of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  harmonic number. In other words harmonic number 3 is 1/9 quieter than
\par   harmonic number 1, because the harmonic 3 squared is 9 (3 X 3) and the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  reciprocal of 9 is 1/9.
\par     As you can see, there is a similarity in shape of a triangular wave to
\par   a sine wave oscillating at the fundamental frequency.
\par     Sawtooth waves contain all the harmonics. The amount of each harmonic
\par   present is proportional to the reciprocal of the harmonic number. For
\par   example, harmonic number 2 is 1/2 as loud as harmonic number 1.
\par     The square wave contains odd harmonics in proportion to the reciprocal
\par   of the harmonic number. Other rectangular waves have varying harmonic
\par   content. By changing the pulse width, the timbre of the sound of a
\par   rectangular wave can be varied tremendously.
\par 
\par 
\par 
\par                                           PROGRAMMING SOUND AND MUSIC   195
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    By choosing carefully the waveform used, you can start with a harmonic
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  structure that looks somewhat like the sound you want. To refine the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sound, you can add another aspect of sound quality available on your
\par   Commodore 64 called filtering, which we'll discuss later in this section.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   THE ENVELOPE GENERATOR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The volume of a musical tone changes from the moment you first hear it,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  all the way through until it dies out and you can't hear it anymore. When
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a note is first struck, it rises from zero volume to its peak volume. The
\par   rate at which this happens is called the ATTACK. Then, it fails from the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  peak to some middle-ranged volume. The rate at which the fall of the note
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  occurs is called the DECAY. The mid-ranged volume itself is called the
\par   SUSTAIN level. And finally, when the note stops playing, it fails from
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the SUSTAIN level to zero volume. The rate at which it fails is called
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the RELEASE. Here is a sketch of the four phases of a note:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                              +
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                             / \\
\par                             /   \\
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           /     \\
\par          SUSTAIN LEVEL . ./. . . .+--------+
\par                          /                  \\
\par                         /                    \\
\par                        /                      \\
\par 
\par                        |      |   |        |   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       |   A  | D |    S   | R |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Each of the items mentioned above give certain qualities and restric-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  tions to a note. The bounds are called parameters.
\par     The parameters ATTACK/DECAY/SUSTAIN/RELEASE and collectively called
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ADSR, can be controlled by your use of another set of locations in the
\par   sound generator chip. LOAD your first example program again. RUN it again
\par   and remember how it sounds. Then, changing line 20 so the program is like
\par   this:
\par 
\par 
\par 
\par 
\par 
\par   196   PROGRAMMING SOUND AND MUSIC
\par \page 
\par 
\par 
\par   EXAMPLE PRO6RAM 4 (EXAMPLE 1 MODIFIED):
\par 
\par start tok64 page197.prg
\par   5 s=54272
\par   10 forl=stos+24:pokel,0:next
\par   20 pokes+5,88:pokes+6,195
\par   30 pokes+24,15
\par   40 readhf,lf,dr
\par   50 ifhf<0thenend
\par   60 pokes+1,hf:pokes,lf
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 pokes+4,33
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  80 fort=1todr:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 pokes+4,32:fort=1to50:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 goto40
\par   110 data25,177,250,28,214,250
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  120 data25,177,250,25,177,250
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  130 data25,177,125,28,214,125
\par   140 data32,94,750,25,177,250
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  150 data28,214,250,19,63,250
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  160 data19,63,250,19,63,250
\par   170 data21,154,63,24,63,63
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  180 data25,177,250,24,63,125
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  190 data19,63,250,-1,-1,-1
\par stop tok64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Registers 5 and 6 define the ADSR for voice 1. The ATTACK is the high
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  nybble of register 5. Nybble is half a byte, in other words the lower 4
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  or higher 4 on/off locations (bits) in each register. DECAY is the low
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  nybble. You can pick any number 0 through 15 for ATTACK, multiply it by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  16 and add to any number 0 through 15 for DECAY. The values that
\par   correspond to these numbers are listed below.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    SUSTAIN level is the high nybble of register 6. It can be 0 through 15.
\par   It defines the proportion of the peak volume that the SUSTAIN level will
\par   be. RELEASE rate is the low nybble of register 6.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                          PROGRAMMING SOUND AND MUSIC   197
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Here are the meanings of the values for ATTACK, DECAY, and RELEASE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-----+------------------------+--------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |VALUE|ATTACK RATE (TIME/CYCLE)| DECAY/RELEASE RATE (TIME/CYCLE)|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----+------------------------+--------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  0  |           2 ms         |               6 ms             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  1  |           8 ms         |              24 ms             |
\par   |  2  |          16 ms         |              48 ms             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  3  |          24 ms         |              72 ms             |
\par   |  4  |          38 ms         |             114 ms             |
\par   |  5  |          56 ms         |             168 ms             |
\par   |  6  |          68 ms         |             204 ms             |
\par   |  7  |          80 ms         |             240 ms             |
\par   |  8  |         100 ms         |             300 ms             |
\par   |  9  |         250 ms         |             750 ms             |
\par   | 10  |         500 ms         |             1.5 s              |
\par   | 11  |         800 ms         |             2.4 s              |
\par   | 12  |           1 s          |               3 s              |
\par   | 13  |           3 s          |               9 s              |
\par   | 14  |           5 s          |              15 s              |
\par   | 15  |           8 s          |              24 s              |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----+------------------------+--------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Here are a few sample settings to try in your example program. Try
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  these and a few of your own. The variety of sounds you can produce is
\par   astounding! For a violin type sound, try changing line 20 to read:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 POKES+5,88:POKES+6,89:REM A=5;D=8;S=5;R=9
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Change the waveform to triangle and get a xylophone type sound by using
\par   these lines:
\par 
\par     20 POKES+5,9:POKES+6,9:REM A=0;D=9;S=O;R=9
\par     70 POKES+4,17
\par     90 POKES+4,16:FORT=1TO50:NEXT
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   198   PROGRAMMING SOUND AND MUSIC
\par \page 
\par 
\par 
\par   Change the waveform to square and try a piano type sound with these
\par   lines:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    15 POKES+3,8:POKES+2,0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 POKES+5,9:POKES+6,0: REM A=0;D=9;S=0;R=0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    70 POKES+4,65
\par     90 POKES+4,64:FORT=1TO50:NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The most exciting sounds are those unique to the music synthesizer
\par   itself, ones that do not attempt to mimic acoustic instruments. For
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  example try:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    20 POKES+5,144:POKES+6,243:REM A=9;D=O; S=15;R=3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FILTERING
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The harmonic content of a waveform can be changed by using a filter.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The SID chip is equipped with three types of filtering. They can be used
\par   separately or in combination with one another. Let's go back to the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sample program you've been using to play with a simple example that uses
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a filter. There are several filter controls to set.
\par     You add line 15 in the program to set the cutoff frequency of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  filter. The cutoff frequency is the reference point for the filter. You
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SET the high and low frequency cutoff points in registers 21 and 22. To
\par   turn ON the filter for voice 1, POKE register 23.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Next change line 30 to show that a high-pass filter will be used (see
\par   the SID register map).
\par 
\par 
\par 
\par 
\par 
\par 
\par                                           PROGRAMMING SOUND AND MUSIC   199
\par \page 
\par 
\par 
\par EXAMPLE PROGRAM 5 (EXAMPLE 1 MODIFIED):
\par 
\par start tok64 page200.prg
\par   5 s=54272
\par   10 forl=stos+24:pokel,0:next
\par   15 pokes+22,128:pokes+21,0:pokes+23,1
\par   20 pokes+5,9:pokes+6,0
\par   30 pokes+24,79
\par   40 readhf,lf,dr
\par   50 ifhf<0thenend
\par   60 pokes+1,hf:pokes,lf
\par   70 pokes+4,33
\par   80 fort=1todr:next
\par   90 pokes+4,32:fort=1to50:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 goto40
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  110 data25,177,250,28,214,250
\par   120 data25,177,250,25,177,250
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  130 data25,177,125,28,214,125
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  140 data32,94,750,25,177,250
\par   150 data28,214,250,19,63,250
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  160 data19,63,250,19,63,250
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  170 data21,154,63,24,63,63
\par   180 data25,177,250,24,63,125
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  190 data19,63,250,-1,-1,-1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {stop tok64
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Try RUNning the program now. Notice the lower tones have had their
\par   volume cut down. It makes the overall quality of the note sound tinny.
\par   This is because you are using a high-pass filter which attenuates (cuts
\par   down the level of) frequencies below the specified cutoff frequency.
\par     There are three types of filters in your Commodore computer's SID chip.
\par   We have been using the high-pass filter. It will pass all the frequencies
\par   at or above the cutoff, while attenuating the frequencies below the
\par   cutoff.
\par 
\par                              |
\par                       AMOUNT |      +-----
\par                       PASSED |     /
\par                              |    /
\par                              |   /
\par                              +------|-------
\par                                 FREQUENCY
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  200   PROGRAMMING SOUND AND MUSIC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The SID chip also has a low-pass filter. As its name implies, this
\par   filter will pass the frequencies below cutoff and attenuate those above.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                              |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      AMOUNT | -----+
\par                       PASSED |       \\
\par                              |        \\
\par                              |         \\
\par                              +------|-------
\par                                 FREQUENCY
\par 
\par 
\par     Finally, the chip is equipped with a bandpass filter, which passes a
\par   narrow band of frequencies around the cutoff, and attenuates all others.
\par 
\par 
\par                              |
\par                       AMOUNT |      +
\par                       PASSED |     / \\
\par                              |    /   \\
\par                              |   /     \\
\par                              +------|-------
\par                                 FREQUENCY
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The high- and low-pass filters can be combined to form a notch reject
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  filter which passes frequencies away from the cutoff while attenuating
\par   at the cutoff frequency.
\par 
\par 
\par                              |
\par                       AMOUNT | --+     +---
\par                       PASSED |    \\   /
\par                              |     \\ /
\par                              |      +
\par                              +------|-------
\par                                 FREQUENCY
\par 
\par 
\par 
\par 
\par                                           PROGRAMMING SOUND AND MUSIC   201
\par \page 
\par 
\par 
\par     Register 24 determines which type filter you want to use. This is in
\par   addition to register 24's function as the overall volume control. Bit 6
\par   controls the high-pass filter (0 = off, 1 = on), bit 5 is the bandpass
\par   filter, and bit 4 is the low-pass filter. The low 3 bits of the cutoff
\par   frequency are determined by register 21 (Lcf) (Lcf = 0 through 7). While
\par   the 8 bits of the high cutoff frequency are determined by register 22
\par   (Hcf) (Hcf = 0 through 255).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Through careful use of filtering, you can change the harmonic structure
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of any waveform to get just the sound you want. In addition, changing the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  filtering of a sound as it goes through the ADSR phases of its life can
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  produce interesting effects.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ADVANCED TECHNIQUES
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The SID chip's parameters can be changed dynamically during a note or
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sound to create many interesting and fun effects. In order to make this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  easy to do, digitized outputs from oscillator three and envelope
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  generator three are available for you in registers 27 and 28, respec-
\par   tively.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The output of oscillator 3 (register 27) is directly related to the
\par   waveform selected. If you choose the sawtooth waveform of oscillator 3,
\par   this register will present a series of numbers incremented (increased
\par   step by step) from 0 to 255 at a rate determined by the frequency of
\par   oscillator 3. If you choose the triangle waveform, the output will incre-
\par   ment from 0 up to 255, then decrement (decrease step by step) back down
\par   to 0. If you choose the pulse wave, the output will jump back-and-forth
\par   between 0 and 255. Finally, choosing the noise waveform will give you a
\par   series of random numbers. When oscillator 3 is used for modulation, you
\par   usually do NOT want to hear its output. Setting bit 7 of register 24
\par   turns the audio output of voice 3 off. Register 27 always reflects the
\par   changing output of the oscillator and is not affected in any way by the
\par   envelope (ADSR) generator.
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  202   PROGRAMMING SOUND AND MUSIC
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Register 25 gives you access to the output of the envelope generator
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of oscillator 3. It functions in much the same fashion that the output of
\par   oscillator 3 does. The oscillator must be turned on to produce any output
\par   from this register.
\par     Vibrato (a rapid variation in frequency) can be achieved by adding the
\par   output of oscillator 3 to the frequency of another oscillator. Example
\par   Program 6 illustrates this idea.
\par 
\par 
\par   EXAMPLE PROGRAM 6:
\par 
\par 
\par start tok64 page203.prg
\par   10 s=54272
\par   20 forl=0to24:pokes+l,0:next
\par   30 pokes+3,8
\par   40 pokes+5,41:pokes+6,89
\par   50 pokes+14,117
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60 pokes+18,16
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 pokes+24,143
\par   80 readfr,dr
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 iffr=0thenend
\par   100 pokes+4,65
\par   110 fort=1todr*2
\par   120 fq=fr+peek(s+27)/2
\par   130 hf=int(fq/256):lf=lqand255
\par   140 pokes+0,lf:pokes+1,hf
\par   150 next
\par   160 pokes+4,64
\par   170 goto80
\par   500 data4817,2,5103,2,5407,2
\par   510 data8583,4,5407,2,8583,4
\par   520 data5407,4,8583,12,9634,2
\par   530 data10207,2,10814,2,8583,2
\par   540 data9634,4,10814,2,8583,2
\par   550 data8583,12
\par   560 data0,0
\par stop tok64
\par 
\par 
\par 
\par 
\par 
\par                                           PROGRAMMING SOUND AND MUSIC   203
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINE-BY-LINE EXPLANATION OF EXAMPLE PROGRAM 6:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +----------+------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Lines(s) |                        Description                         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------+------------------------------------------------------------+
\par   | 10       | Set S to beginning of sound chip.                          |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 20       | Clear all sound chip locations.                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 30       | Set high pulse width for voice 1.                          |
\par   | 40       | Set Attack/Decay for voice 1 (A=2, D=9).                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |          | Set Sustain/Release for voice 1 (S=5, R=9).                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 50       | Set low frequency for voice 3.                             |
\par   | 60       | Set triangle waveform for voice 3.                         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 70       | Set volume 15, turn off audio output of voice 3.           |
\par   | 80       | Read frequency and duration of note.                       |
\par   | 90       | If frequency equals zero, stop.                            |
\par   | 100      | POKE start pulse waveform control voice 1.                 |
\par   | 110      | Start timing loop for duration.                            |
\par   | 120      | Get new frequency using oscillator 3 output.               |
\par   | 130      | Get high and low frequency.                                |
\par   | 140      | POKE high and low frequency for voice 1.                   |
\par   | 150      | End of timing loop.                                        |
\par   | 160      | POKE stop pulse waveform control voice 1.                  |
\par   | 170      | Go back for next note.                                     |
\par   | 500-550  | Frequencies and durations for song,                        |
\par   | 560      | Zeros signal end of song.                                  |
\par   +----------+------------------------------------------------------------+
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    A wide variety of sound effects can also be achieved using dynamic
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  effects. For example, the following siren program dynamically changes the
\par   frequency output of oscillator 1 when it's based on the output of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  oscillator 3's triangular wave:
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   204   PROGRAMMING SOUND AND MUSIC
\par \page 
\par 
\par 
\par   EXAMPLE PROGRAM 7:
\par 
\par start tok64 page205.prg
\par   10 s=54272
\par   20 forl=0to24:pokes+l,0:next
\par   30 pokes+14,5
\par   40 pokes+18,16
\par   50 pokes+3,1
\par   60 pokes+24,143
\par   70 pokes+6,240
\par   80 pokes+4,65
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 fr=5389
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 fort=1to200
\par   110 fq=fr+peek(s+27)*3.5
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  120 hf=int(fq/256):lf=fq-hf*256
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  130 pokes+0,lf:pokes+1,hf
\par   140 next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  150 pokes+24,0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {stop tok64
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINE-BY-LINE EXPLANATION OF EXAMPLE PROGRAM 7:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-------------------------------------------------------------+
\par   | Line(s) |                         Description                         |
\par   +---------+-------------------------------------------------------------+
\par   | 10      | Set S to start of sound chip.                               |
\par   | 20      | Clear sound chip registers.                                 |
\par   | 30      | Set low frequency of voice 3.                               |
\par   | 40      | Set triangular waveform voice 3.                            |
\par   | 50      | Set high pulse width for voice 1.                           |
\par   | 60      | Set volume 15, turn off audio output of voice 3.            |
\par   | 70      | Set Sustain/Release for voice I (S=15, R=0).                |
\par   | 80      | POKE start pulse waveform control voice 1.                  |
\par   | 90      | Set lowest frequency for siren.                             |
\par   | 100     | Begin timing loop.                                          |
\par   | 110     | Get new frequency using output of oscillator 3.             |
\par   | 120     | Get high and low frequencies.                               |
\par   | 130     | POKE high.and low frequencies for voice 1.                  |
\par   | 140     | End timing loop.                                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 150     | Turn off volume.                                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                           PROGRAMMING SOUND AND MUSIC   205
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The noise waveform can be used to provide a wide range of sound
\par   effects. This example mimics a hand clap using a filtered noise waveform:
\par 
\par   EXAMPLE PROGRAM 8:
\par 
\par start tok64 page206.prg
\par   10 s=54272
\par   20 forl=0to24:pokes+l,0:next
\par   30 pokes+0,240:pokes+1,33
\par   40 pokes+5,8
\par   50 pokes+22,104
\par   60 pokes+23,1
\par   70 pokes+24,79
\par   80 forn=1to15
\par   90 pokes+4,129
\par   100 fort=1to250:next:pokes+4,128
\par   110 fort=1to30:next:next
\par   120 pokes+24,0
\par stop tok64
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINE-BY-LINE EXPLANATION OF EXAMPLE PROGRAM 8:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +---------+-------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Line(s) |                         Description                         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-------------------------------------------------------------+
\par   |    10   | Set S to start of sound chip.                               |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    20   | Clear all sound chip registers.                             |
\par   |    30   | Set high and low frequencies for voice 1.                   |
\par   |    40   | Set Attack/Decay for voice I (A=0, D=8).                    |
\par   |    50   | Set high cutoff frequency for filter.                       |
\par   |    60   | Turn on filter for voice 1.                                 |
\par   |    70   | Set volume 15, high-pass filter.                            |
\par   |    80   | Count 15 claps.                                             |
\par   |    90   | Set start noise waveform control.                           |
\par   |   100   | Wait, then set stop noise waveform control.                 |
\par   |   110   | Wait, then start next clap-                                 |
\par   |   120   | Turn off volume.                                            |
\par   +---------+-------------------------------------------------------------+
\par 
\par 
\par 
\par   206   PROGRAMMING SOUND AND MUSIC
\par \page 
\par 
\par 
\par   SYNCHRONIZATION AND RING MODULATION
\par 
\par     The 6581 SID chip lets you create more complex harmonic structures
\par   through synchronization or ring modulation of two voices.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The process of synchronization is basically a logical ANDing of two
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  wave forms. When either is zero, the output is zero. The following
\par   example uses this process to create an imitation of a mosquito:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE PROGRAM 9:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {start tok64 page207.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 s=54272
\par   20 forl=0to24:pokes+l,0:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  30 pokes+1,100
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  40 pokes+5,219
\par   50 pokes+15,28
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  60 pokes+24,15
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 pokes+4,19
\par   80 fort=1to5000:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 pokes+4,18
\par   100 fort=1to1000:next:pokes+24,0
\par stop tok64
\par 
\par   LINE-BY-LINE EXPLANATION OF EXAMPLE PROGRAM 9:
\par   +---------+-------------------------------------------------------------+
\par   | Line(s) |                     Description                             |
\par   +---------+-------------------------------------------------------------+
\par   |   10    | Set S to start of sound chip.                               |
\par   |   20    | Clear sound chip registers.                                 |
\par   |   30    | Set high frequency voice 1.                                 |
\par   |   40    | Set Attack/Decay for voice 1 (A=13, D=11).                  |
\par   |   50    | Set high frequency voice 3.                                 |
\par   |   60    | Set volume 15.                                              |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   70    | Set start triangle, sync waveform control for voice 1.      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   80    | Timing loop.                                                |
\par   |   90    | Set stop triangle, sync waveform control for voice 1.       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  100    | Wait, then turn off volume.                                 |
\par   +-----------------------------------------------------------------------+
\par     The synchronization feature is enabled (turned on) in line 70, where
\par   bits 0, 1, and 4 of register 4 are set. Bit 1 enables the syncing
\par   function between voice 1 and voice 3. Bits 0 and 4 have their usual
\par   functions of gating voice 1 and setting the triangular waveform.
\par 
\par                                           PROGRAMMING SOUND AND MUSIC   207
\par \page 
\par 
\par 
\par     Ring modulation (accomplished for voice 1 by setting bit 3 of register
\par   4 in line 70 of the program below) replaces the triangular output of
\par   oscillator I with a "ring modulated" combination of oscillators 1 and 3.
\par   This produces non-harmonic overtone structures for use in mimicking bell
\par   or gong sounds. This program produces a clock chime imitation:
\par 
\par   EXAMPLE PROGRAM 10:
\par start tok64 page208.prg
\par   10 s=54272
\par   20 forl=0to24:pokes+l,0:next
\par   30 pokes+1,130
\par   40 pokes+5,9
\par   50 pokes+15,30
\par   60 pokes+24,15
\par   70 forl=1to12:pokes+4,21
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  80 fort=1to1000:next:pokes+4,20
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 fort=1to1000:next:next
\par stop tok64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINE-BY-LINE EXPLANATION OF EXAMPLE PROGRAM 10:
\par   +---------+-------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Line(s) |                     Description                             |
\par   +---------+-------------------------------------------------------------+
\par   |   10    | Set S to start of sound chip.                               |
\par   |   20    | Clear sound chip registers.                                 |
\par   |   30    | Set high frequency for voice 1.                             |
\par   |   40    | Set Attack/Decay for voice 1 (A=0, D=9).                    |
\par   |   50    | Set high frequency for voice 3.                             |
\par   |   60    | Set volume 15.                                              |
\par   |   70    | Count number of clings, set start triangle, ring mod        |
\par   |         | waveform control voice 1.                                   |
\par   |   80    | Timing loop, set stop triangle, ring mod.                   |
\par   |   90    | Timing loop, next ding.                                     |
\par   +---------+-------------------------------------------------------------+
\par     The effects available through the use of the parameters of your
\par   Commodore 64's SID chip are numerous and varied. Only through ex-
\par   perimentation on your own will you fully appreciate the capabilities of
\par   your machine. The examples in this section of the Programmer's Reference
\par   Guide merely scratch the surface.
\par     Watch for the book MAKING MUSIC ON YOUR COMMODORE COMPUTER for
\par   everything from simple fun and games to professional-type musical
\par   instruction.
\par 
\par   208   PROGRAMMING SOUND AND MUSIC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                  CHAPTER 5
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                  BASIC TO
\par                                                    MACHINE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                  LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o What Is Machine Language?
\par                            o How Do You Write Machine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                             Language Programs?
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Hexadecimal Notation
\par                            o Addressing Modes
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Indexing
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Subroutines
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Useful Tips for the Beginner
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Approaching a Large Task
\par                            o MCS6510 Microprocessor
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                             Instruction Set
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Memory Management on the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                             Commodore 64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o The KERNAL
\par                            o KERNAL Power-Up Activities
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Using Machine Language From
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                             BASIC
\par                            o Commodore 64 Memory Map
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     209
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   WHAT IS MACHINE LANGUAGE?
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    At the heart of every microcomputer, is a central microprocessor. It's
\par   a very special microchip which is the "brain" of the computer. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Commodore 64 is no exception. Every microprocessor understands its own
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  language of instructions. These instructions are called machine language
\par   instructions. To put it more precisely, machine language is the ONLY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  programming language that your Commodore 64 understands. It is the NATIVE
\par   language of the machine.
\par     If machine language is the only language that the Commodore 64
\par   understands, then how does it understand the CBM BASIC programming
\par   language? CBM BASIC is NOT the machine language of the Commodore 64.
\par   What, then, makes the Commodore 64 understand CBM BASIC instructions like
\par   PRINT and GOTO?
\par     To answer this question, you must first see what happens inside your
\par   Commodore 64. Apart from the microprocessor which is the brain of the
\par   Commodore 64, there is a machine language program which is stored in a
\par   special type of memory so that it can't be changed. And, more impor-
\par   tantly, it does not disappear when the Commodore 64 is turned off, unlike
\par   a program that you may have written. This machine language program is
\par   called the OPERATING SYSTEM of the Commodore 64. Your Commodore 64 knows
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  what to do when it's turned on because its OPERATING SYSTEM (program) is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  automatically "RUN."
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  210   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par     The OPERATING SYSTEM is in charge of "organizing" all the memory in
\par   your machine for various tasks. It also looks at what characters you type
\par   on the keyboard and puts them onto the screen, plus a whole number of
\par   other functions. The OPERATING SYSTEM can be thought of as the
\par   "intelligence and personality" of the Commodore 64 (or any computer for
\par   that matter). So when you turn on your Commodore 64, the OPERATING SYSTEM
\par   takes control of your machine, and after it has done its housework, it
\par   then says:
\par 
\par     READY.
\par 
\par 
\par     The OPERATING SYSTEM of the Commodore 64 then allows you to type on the
\par   keyboard, and use the built-in SCREEN EDITOR on the Commodore 64. The
\par   SCREEN EDITOR allows you to move the cursor, DELete, INSert, etc., and
\par   is, in fact, only one part of the operating system that is built in for
\par   your convenience.
\par     All of the commands that are available in CBM BASIC are simply
\par   recognized by another huge machine language program built into your
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Commodore 64. This huge program "RUNS" the appropriate piece of machine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  language depending on which CBM BASIC command is being executed. This
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  program is called the BASIC INTERPRETER, because it interprets each
\par   command, one by one, unless it encounters a command it does not
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  understand, and then the familiar message appears:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     ?SYNTAX ERROR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    READY.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   WHAT DOES MACHINE CODE LOOK LIKE?
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    You should be familiar with the PEEK and POKE commands in the CBM BASIC
\par   language for changing memory locations. You've probably used them for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  graphics on the screen, and for sound effects. Each memory location has
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  its own number which identifies it. This number is known as the "address"
\par   of a memory location. If you imagine the memory in the Commodore 64 as a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  street of buildings, then the number on each door is, of course, the
\par   address. Now let's look at which parts of the street are used for what
\par   purposes.
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   211
\par \page 
\par 
\par 
\par   SIMPLE MEMORY MAP OF THE COMMODORE 64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------------+---------------------------------------------------------+
\par   |   ADDRESS   |                      DESCRIPTION                        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------------+---------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |             |                                                         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    0 & 1    | -6510 Registers.                                        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |             |                                                         |
\par   |     2       | -Start of memory.                                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |             |                                                         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     2-1023  | -Memory used by the operating system.                   |
\par   |             |                                                         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  1024-2039  | -Screen memory.                                         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |             |                                                         |
\par   |  2040-2047  | -SPRITE pointers.                                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |             |                                                         |
\par   |  2048-40959 | -This is YOUR memory. This is where your BASIC or       |
\par   |             |  machine language programs, or both, are stored.        |
\par   |             |                                                         |
\par   | 40960-49151 | -8K CBM BASIC Interpreter.                              |
\par   |             |                                                         |
\par   | 49152-53247 | -Special programs RAM area.                             |
\par   |             |                                                         |
\par   | 53248-53294 | -VIC-II.                                                |
\par   |             |                                                         |
\par   | 54272-55295 | -SID Registers.                                         |
\par   |             |                                                         |
\par   | 55296-56296 | -Color RAM.                                             |
\par   |             |                                                         |
\par   | 56320-57343 | -I/O Registers. (6526's)                                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |             |                                                         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 57344-65535 | -8K CBM KERNAL Operating System.                        |
\par   |             |                                                         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------------+---------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  212   BASIC TO MACHINE LANGUAGE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     If you don't understand what the description of each part of memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  means right now, this will become clear from other parts of this manual.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Machine language programs consist of instructions which may or may not
\par   have operands (parameters) associated with them. Each instruction takes
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  up one memory location, and any operand is contained in one or two
\par   locations following the instruction.
\par     In your BASIC programs, words like PRINT and GOTO do, in fact, only
\par   take up one memory location, rather than one for each character of the
\par   word. The contents of the location that represents a particular BASIC
\par   keyword is called a token. In machine language, there are different
\par   tokens for different instructions, which also take up just one byte (mem-
\par   ory location=byte).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Machine language instructions are very simple. Therefore, each indi-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  vidual instruction cannot achieve a great deal. Machine language in-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  structions either change the contents of a memory location, or change one
\par   of the internal registers (special storage locations) inside the micro-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  processor. The internal registers form the very basis of machine lan-
\par   guage.
\par 
\par 
\par   THE REGISTERS INSIDE THE 6510 MICROPROCESSOR
\par 
\par   THE ACCUMULATOR
\par 
\par     This is THE most important register in the microprocessor. Various ma-
\par   chine language instructions allow you to copy the contents of a memory
\par   location into the accumulator, copy the contents of the accumulator into
\par   a memory location, modify the contents of the accumulator or some other
\par   register directly, without affecting any memory. And the accumulator is
\par   the only register that has instructions for performing math.
\par 
\par 
\par   THE X INDEX REGISTER
\par 
\par     This is a very important register. There are instructions for nearly
\par   all of the transformations you can make to the accumulator. But there are
\par   other instructions for things that only the X register can do. Various
\par   machine language instructions allow you to copy the contents of a memory
\par   location into the X register, copy the contents of the X register into a
\par   memory location, and modify the contents of the X, or some other register
\par   directly.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                             BASIC TO MACHINE LANGUAGE   213
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  THE Y INDEX REGISTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     This is a very important register. There are instructions for nearly
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  all of the transformations you can make to the accumulator, and the X
\par   register. But there are other instructions for things that only the Y
\par   register can do. Various machine language instructions allow you to copy
\par   the contents of a memory location into the Y register, copy the contents
\par   of the Y register into a memory location, and modify the contents of the
\par   Y, or some other register directly.
\par 
\par   THE STATUS REGISTER
\par 
\par     This register consists of eight "flags" (a flag = something that indi-
\par   cates whether something has, or has not occurred).
\par 
\par   THE PROGRAM COUNTER
\par 
\par     This contains the address of the current machine language instruction
\par   being executed. Since the operating system is always "RUN"ning in the
\par   Commodore 64 (or, for that matter, any computer), the program counter is
\par   always changing. It could only be stopped by halting the microprocessor
\par   in some way.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  THE STACK POINTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     This register contains the location of the first empty place on the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  stack. The stack is used for temporary storage by machine language pro-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  grams, and by the computer.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  THE INPUT/OUTPUT PORT
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This register appears at memory locations 0 (for the DATA DIRECTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  REGISTER) and 1 (for the actual PORT). It is an 8-bit input/output port.
\par   On the Commodore 64 this register is used for memory management, to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  allow the chip to control more than 64K of RAM and ROM memory.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The details of these registers are not given here. They are explained
\par   as the principles needed to explain them are explained.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  HOW DO YOU WRITE MACHINE LANGUAGE PROGRAMS?
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Since machine language programs reside in memory, and there is no
\par   facility in your Commodore 64 for writing and editing machine language
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  214   BASIC TO MACHINE LANGUAGE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   programs, you must use either a program to do this, or write for yourself
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a BASIC program that "allows" you to write machine language.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The most common methods used to write machine language programs are
\par   assembler programs. These packages allow you to write machine language
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  instructions in a standardized mnemonic format, which makes the machine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  language program a lot more readable than a stream of numbers! Let's
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  review: A program that allows you to write machine language programs in
\par   mnemonic format is called an assembler. Incidentally, a program that
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  displays a machine language program in mnemonic format is called a
\par   disassembler. Available for your Commodore 64 is a machine language
\par   monitor cartridge (with assembler/disassembler, etc.) made by Commodore:
\par 
\par 
\par   64MON
\par 
\par     The 64MON cartridge available from your local dealer, is a program that
\par   allows you to escape from the world of CBM BASIC, into the land of
\par   machine language. It can display the contents of the internal registers
\par   in the 6510 microprocessor, and it allows you to display portions of mem-
\par   ory, and change them on the screen, using the screen editor. It also has
\par   a built-in assembler and disassembler, as well as many other features
\par   that allow you to write and edit machine language programs easily. You
\par   don't HAVE to use an assembler to write machine language, but the task is
\par   considerably easier with it. If you wish to write machine language
\par   programs, it is strongly suggested that you purchase an assembler of some
\par   sort. Without an assembler you will probably have to "POKE" the machine
\par   language program into memory, which is totally unadvisable. This manual
\par   will give its examples in the format that 64MON uses, from now on. Nearly
\par   all assembler formats are the same, therefore the machine language
\par   examples shown will almost certainly be compatible with any assembler.
\par   But before explaining any of the other features of 64MON, the hexadecimal
\par   numbering system must be explained.
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  HEXADECIMAL NOTATION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Hexadecimal notation is used by most machine language programmers when
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  they talk about a number or address in a machine language program.
\par     Some assemblers let you refer to addresses and numbers in decimal
\par   (base 10), binary (base 2), or even octal (base 8) as well as hexadecimal
\par 
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   215
\par \page 
\par 
\par 
\par   (base 16) (or just "hex" as most people say). These assemblers do the
\par   conversions for you.
\par     Hexadecimal probably seems a little hard to grasp at first, but like
\par   most things, it won't take long to master with practice.
\par     By looking at decimal (base 10) numbers, you can see that each digit
\par   fails somewhere in the range between zero and a number equal to the base
\par   less one (e.g., 9). THIS IS TRUE OF ALL NUMBER BASES. Binary (base 2)
\par   numbers have digits ranging from zero to one (which is one less than the
\par   base). Similarly, hexadecimal numbers should have digits ranging from
\par   zero to fifteen, but we do not have any single digit figures for the
\par   numbers ten to fifteen, so the first six letters of the alphabet are used
\par   instead:
\par 
\par 
\par                     +---------+-------------+----------+
\par                     | DECIMAL | HEXADECIMAL |  BINARY  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    +---------+-------------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    |    0    |      0      | 00000000 |
\par                     |    1    |      1      | 00000001 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    |    2    |      2      | 00000010 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    |    3    |      3      | 00000011 |
\par                     |    4    |      4      | 00000100 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    |    5    |      5      | 00000101 |
\par                     |    6    |      6      | 00000110 |
\par                     |    7    |      7      | 00000111 |
\par                     |    8    |      8      | 00001000 |
\par                     |    9    |      9      | 00001001 |
\par                     |   10    |      A      | 00001010 |
\par                     |   11    |      B      | 00001011 |
\par                     |   12    |      C      | 00001100 |
\par                     |   13    |      D      | 00001101 |
\par                     |   14    |      E      | 00001110 |
\par                     |   15    |      F      | 00001111 |
\par                     |   16    |     10      | 00010000 |
\par                     +---------+-------------+----------+
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   216   BASIC TO MACHINE LANGUAGE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Let's look at it another way; here's an example of how a base 10
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (decimal number) is constructed:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Base raised by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    increasing powers:... 10^3 10^2 10^1 10^0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         ---------------------
\par     Equals:.............. 1000  100   10    1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         ---------------------
\par 
\par     Consider 4569 (base 10)  4    5    6    9 = (4*1000)+(5*100)+(6*10)+9
\par 
\par   Now look at an example of how a base 16 (hexadecimal number) is
\par   constructed:
\par 
\par     Base raised by
\par     increasing powers:... 16^3 16^2 16^1 16^0
\par                          ---------------------
\par     Equals:.............. 4096  256   16    1
\par                          ---------------------
\par 
\par     Consider 11D9 (base 16)  1    1    D    9 = 1*4096+1*256+13*16+9
\par 
\par   Therefore, 4569 (base 10) = 11D9 (base 16)
\par     The range for addressable memory locations is 0-65535 (as was stated
\par   earlier). This range is therefore 0-FFFF in hexadecimal notation.
\par     Usually hexadecimal numbers are prefixed with a dollar sign ($). This
\par   is to distinguish them from decimal numbers. Let's look at some "hex"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  numbers, using 64MON, by displaying the contents of some memory by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  typing:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    SYS 8*4096   (or SYS 12*4096)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    B*
\par        PC  SR AC XR YR SP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .;0401 32 04 5E 00 F6 (these may be different)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Then if you type in:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  .M 0000 0020 (and press <RETURN>).
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  you will see rows of 9 hex numbers. The first 4-digit number is the ad-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  dress of the first byte of memory being shown in that row, and the other
\par   eight numbers are the actual contents of the memory locations beginning
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  at that start address.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   217
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     You should really try to learn to "think" in hexadecimal. It's not too
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  difficult, because you don't have to think about converting it back into
\par   decimal. For example, if you said that a particular value is stored at
\par   $14ED instead of 5357, it shouldn't make any difference.
\par 
\par 
\par   YOUR FIRST MACHINE LANGUAGE INSTRUCTION
\par 
\par   LDA - LOAD THE ACCUMULATOR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    In 6510 assembly language, mnemonics are always three characters. LDA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  represents "load accumulator with...", and what the accumulator should be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  loaded with is decided by the parameter(s) associated with that
\par   instruction. The assembler knows which token is represented by each
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  mnemonic, and when it "assembles" an instruction, it simply puts into
\par   memory (at whatever address has been specified), the token, and what
\par   parameters, are given. Some assemblers give error messages, or warnings
\par   when you try to assemble something that either the assembler, or the 6510
\par   microprocessor, cannot do.
\par     If you put a "#" symbol in front of the parameter associated with the
\par   instruction, this means that you want the register specified in the
\par   instruction to be loaded with the "value" after the "#". For example:
\par 
\par     LDA #$05  <----[ $=HEX ]
\par 
\par   This instruction will put $05 (decimal 5) into the accumulator register.
\par   The assembler will put into the specified address for this instruction,
\par   $A9 (which is the token for this particular instruction, in this mode),
\par   and it will put $05 into the next location after the location containing
\par   the instruction ($A9).
\par     If the parameter to be used by an instruction has "#" before it; i.e.,
\par   the parameter is a "value," rather than the contents of a memory loca-
\par   tion, or another register, the instruction is said to be in the
\par   "immediate" mode. To put this into perspective, let's compare this with
\par   another mode:
\par     If you want to put the contents of memory location $102E into the
\par   accumulator, you're using the "absolute" mode of instruction:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDA $102E
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   The assembler can distinguish between the two different modes because the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  latter does not have a "#" before the parameter. The 6510 microprocessor
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   218   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  can distinguish between the immediate mode, and the absolute mode of the
\par   LDA instruction, because they have slightly different tokens. LDA
\par   (immediate) has $A9 as its token, and LDA (absolute), has $AD as its
\par   token.
\par     The mnemonic representing an instruction usually implies what it does.
\par   For instance, if we consider another instruction, LDX, what do you think
\par   this does?
\par     If you said "load the X register with...", go to the top of the class.
\par   If you didn't, then don't worry, learning machine language does take
\par   patience, and cannot be learned in a day.
\par     The various internal registers can be thought of as special memory
\par   locations, because they too can hold one byte of information. It is not
\par   necessary for us to explain the binary numbering system (base 2) since it
\par   follows the same rules as outlined for hexadecimal and decimal outlined
\par   previously, but one "bit" is one binary digit and eight bits make up one
\par   byte! This means that the maximum number that can be contained in a
\par   byte is the largest number that an eight digit binary number can be. This
\par   number is 11111111 (binary), which equals $FF (hexadecimal), which equals
\par   255 (decimal). You have probably wondered why only numbers from zero to
\par   255 could be put into a memory location. If you try POKE 7680,260 (which
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is a BASIC statement that "says": "Put the number two hundred and sixty,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  into memory location seven thousand, six hundred and eighty", the BASIC
\par   interpreter knows that only numbers 0 - 255 can be put in a memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  location, and your Commodore 64 will reply with:
\par 
\par     ?ILLEGAL QUANTITY ERROR
\par 
\par     READY.
\par 
\par   If the limit of one byte is $FF (hex), how is the address parameter in
\par   the absolute instruction "LDA $102E" expressed in memory? It's expressed
\par   in two bytes (it won't fit into one, of course). The lower (rightmost)
\par   two digits of the hexadecimal address form the "low byte" of the address,
\par   and the upper (leftmost) two digits form the "high byte."
\par     The 6510 requires any address to be specified with its low byte first,
\par   and then the high byte. This means that the instruction "LDA $102E" is
\par   represented in memory by the three consecutive values:
\par 
\par     $AD, $2E, $10
\par 
\par   Now all you need to know is one more instruction and then you can write
\par   your first program. That instruction is BRK. For a full explanation of
\par 
\par                                             BASIC TO MACHINE LANGUAGE   219
\par \page 
\par 
\par 
\par   this I instruction, refer to M.O.S. 6502 Programming Manual. But right
\par   now, you can think of it as the END instruction in machine language.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    If we write a program with 64MON and put the BRK instruction at the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  end, then when the program is executed, it will return to 64MON when it
\par   is finished. This might not happen if there is a mistake in your program,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  or the BRK instruction is never reached (just like an END statement in
\par   BASIC may never get executed). This means that if the Commodore 64 didn't
\par   have a STOP key, you wouldn't be able to abort your BASIC programs!
\par 
\par 
\par   WRITING YOUR FIRST PROGRAM
\par 
\par     If you've used the POKE statement in BASIC to put characters onto the
\par   screen, you're aware that the character codes for POKEing are different
\par   from CBM ASCII character values. For example, if you enter:
\par 
\par     PRINT ASC("A") (and press <RETURN> )
\par 
\par 
\par   the Commodore 64 will respond with:
\par 
\par     65
\par 
\par     READY.
\par 
\par 
\par   However, to put an "A" onto the screen by POKEing, the code is 1, enter:
\par 
\par     <SHIFT+CLR/HOME> to clear the screen
\par 
\par     POKE 1024,1:POKE 55296,14 (and <RETURN> (1024 is the start of screen
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    memory)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   The "P" in the POKE statement should now be an "A."
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Now let's try this in machine language. Type the following in 64MON:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (Your cursor should be flashing alongside a "." right now.)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .A 1400 LDA#$01 (and press <RETURN>)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  220   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The Commodore 64 will prompt you with:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .A 1400 A9 01      LDA #$01
\par     .A 1402
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Type:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .A 1402 STA $0400
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (The STA instruction stores the contents of the accumulator in a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  specified memory location.)
\par   The Commodore 64 will prompt you with:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .A 1405
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Now type in:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .A 1405 LDA #$0E
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .A 1407 STA $D800
\par     .A 140A BRK
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Clear the screen, and type:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    G 1400
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The G should turn into an "A" if you've done everything correctly. You
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  have now written your first machine language program. Its purpose is to
\par   store one character ("A") at the first location in the screen memory.
\par   Having achieved this, we must now explore some of the other instructions,
\par   and principles.
\par 
\par 
\par   ADDRESSING MODES
\par 
\par   ZERO PAGE
\par 
\par     As shown earlier, absolute addresses are expressed in terms of a high
\par   and a low order byte. The high order byte is often referred to as the
\par   page of memory. For example, the address $1637 is in page $16 (22), and
\par   $0277 is in page $02 (2). There is, however, a special mode of addressing
\par   known as zero page addressing and is, as the name implies, associated
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   221
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   with the addressing of memory locations in page zero. These addresses,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  therefore, ALWAYS have a high order byte of zero. The zero page mode of
\par   addressing only expects one byte to describe the address, rather than two
\par   when using an absolute address. The zero page addressing mode tells the
\par   microprocessor to assume that the high order address is zero. Therefore
\par   zero page addressing can reference memory locations whose addresses are
\par   between $0000 and $00FF. This may not seem too important at the moment,
\par   but you'll need the principles of zero page addressing soon.
\par 
\par 
\par   THE STACK
\par 
\par     The 6510 microprocessor has what is known as a stack. This is used by
\par   both the programmer and the microprocessor to temporarily remember
\par   things, and to remember, for example, an order of events. The GOSUB
\par   statement in BASIC, which allows the programmer to call a subroutine,
\par   must remember where it is being called from, so that when the RETURN
\par   statement is executed in the subroutine, the BASIC interpreter "knows"
\par   where to go back to continue executing. When a GOSUB statement is
\par   encountered in a program by the BASIC interpreter, the BASIC interpreter
\par   "pushes" its current position onto the stack before going to do the
\par   subroutine, and when a RETURN is executed, the interpreter "pulls" off
\par   the stack the information that tells it where it was before the
\par   subroutine call was made. The interpreter uses instructions like PHA,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  which pushes the contents of the accumulator onto the stack, and PLA (the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  reverse) which pulls a value off the stack and into the accumulator. The
\par   status register can also be pushed and pulled with the PHP and PLP,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  respectively.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The stack is 256 bytes long, and is located in page one of memory. It
\par   is therefore from $01 00 to $01 FF. It is organized backwards in memory.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  In other words, the first position in the stack is at $01 FF, and the
\par   last is at $0100. Another register in the 651 0 microprocessor is called
\par   the stack pointer, and it always points to the next available location in
\par   the stack. When something is pushed onto the stack, it is placed where
\par   the stack pointer points to, and the stack pointer is moved down to the
\par   next position (decremented). When something is pulled off the stack, the
\par   stack pointer is incremented, and the byte pointed to by the stack
\par   pointer is placed into the specified register.
\par 
\par 
\par 
\par 
\par 
\par   222   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par     Up to this point, we have covered immediate, zero page, and absolute
\par   mode instructions. We have also covered, but have not really talked
\par   about, the "implied" mode. The implied mode means that information is
\par   implied by an instruction itself. In other words, what registers, flags,
\par   and memory the instruction is referring to. The examples we have seen are
\par   PHA, PLA, PHP, and PLP, which refer to stack processing and the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  accumulator and status registers, respectively.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par   | NOTE: The X register will be referred to as X from now on, and        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | similarly A (accumulator), Y (Y index register), S (stack pointer),   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | and P (processor status).                                             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   INDEXING
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Indexing plays an extremely important part in the running of the 6510
\par   microprocessor. It can be defined as "creating an actual address from a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  base address plus the contents of either the X or Y index registers."
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    For example, if X contains $05, and the microprocessor executes an LDA
\par   instruction in the "absolute X indexed mode" with base address (e.g.,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  $9000), then the actual location that is loaded into the A register is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  $9000 + $05 = $9005. The mnemonic format of an absolute indexed
\par   instruction is the same as an absolute instruction except a ",X" or ",Y"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  denoting the index is added to the address.
\par 
\par   EXAMPLE:
\par 
\par     LDA $9000,X
\par 
\par     There are absolute indexed, zero page indexed, indirect indexed, and
\par   indexed indirect modes of addressing available on the 6510
\par   microprocessor.
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INDIRECT INDEXED
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     This only allows usage of the Y register as the index. The actual ad-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  dress can only be in zero page, and the mode of instruction is called
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  indirect because the zero page address specified in the instruction con-
\par   tains the low byte of the actual address, and the next byte to it
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  contains the high order byte.
\par 
\par                                             BASIC TO MACHINE LANGUAGE   223
\par \page 
\par 
\par 
\par   EXAMPLE:
\par 
\par     Let us suppose that location $02 contains $45, and location $03 con-
\par   tains $1E. If the instruction to load the accumulator in the indirect
\par   indexed mode is executed and the specified zero page address is $02, then
\par   the actual address will be:
\par 
\par     Low order = contents of $02
\par     High order = contents of $03
\par     Y register = $00
\par 
\par   Thus the actual address = $1E45 + Y = $1E45.
\par     The title of this mode does in fact imply an indirect principle,
\par   although this may be difficult to grasp at first sight. Let's look at it
\par   another way:
\par     "I am going to deliver this letter to the post office at address $02,
\par   MEMORY ST., and the address on the letter is $05 houses past $1600,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  MEMORY street." This is equivalent to the code:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     LDA #$00      - load low order actual base address
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    STA $02       - set the low byte of the indirect address
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDA #$16      - load high order indirect address
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    STA $03       - set the high byte of the indirect address
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDY #$05      - set the indirect index (Y)
\par     LDA ($02),Y   - load indirectly indexed by Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   INDEXED INDIRECT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Indexed indirect only allows usage of the X register as the index. This
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is the some as indirect indexed, except it is the zero page address of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the pointer that is indexed, rather than the actual base address.
\par   Therefore, the actual base address IS the actual address because the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  index has already been used for the indirect. Index indirect would also
\par   be used if a table of indirect pointers were located in zero page memory,
\par   and the X register could then specify which indirect pointer to use.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   224   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Let us suppose that location $02 contains $45, and location $03 con-
\par   tains $10. If the instruction to load the accumulator in the indexed
\par   indirect mode is executed and the specified zero page address is $02,
\par   then the actual address will be:
\par 
\par     Low order = contents of ($02+X)
\par     High order = contents of ($03+X)
\par     X register = $00
\par 
\par   Thus the actual pointer is in = $02 + X = $02.
\par     Therefore, the actual address is the indirect address contained in $02
\par   which is again $1045.
\par     The title of this mode does in fact imply the principle, although it
\par   may be difficult to grasp at first sight. Look at it this way:
\par     "I am going to deliver this letter to the fourth post office at address
\par   $01,MEMORY ST., and the address on the letter will then be delivered to
\par   $1600, MEMORY street." This is equivalent to the code:
\par 
\par 
\par     LDA #$00    - load low order actual base address
\par     STA $06     - set the low byte of the indirect address
\par     LDA #$16    - load high order indirect address
\par     STA $07     - set the high byte of the indirect address
\par     LDX #$05    - set the indirect index (X)
\par     LDA ($02,X) - load indirectly indexed by X
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTE: Of the two indirect methods of addressing, the first (indirect  |
\par   | indexed) is far more widely used.                                     |
\par   +-----------------------------------------------------------------------+
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   225
\par \page 
\par 
\par 
\par   BRANCHES AND TESTING
\par 
\par     Another very important principle in machine language is the ability to
\par   test, and detect certain conditions, in a similar fashion to the "IF...
\par   THEN, IF... GOTO" structure in CBM BASIC.
\par     The various flags in the status register are affected by different in-
\par   structions in different ways. For example, there is a flag that is set
\par   when an instruction has caused a zero result, and is reset when a result
\par   is not zero. The instruction:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDA #$00
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   will cause the zero result flag to be set, because the instruction has
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  resulted in the accumulator containing a zero.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    There are a set of instructions that will, given a particular
\par   condition, branch to another part of the program. An example of a branch
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  instruction is BEQ, which means Branch if result EQual to zero. The
\par   branch instructions branch if the condition is true, and if not, the
\par   program continues onto the next instruction, as if nothing had occurred.
\par   The branch instructions branch not by the result of the previous
\par   instructions), but by internally examining the status register. As was
\par   just mentioned, there is a zero result flag in the status register. The
\par   BEQ instruction branches if the zero result flag (known as Z) is set.
\par   Every branch instruction has an opposite branch instruction. The BEQ
\par   instruction has an opposite instruction BNE, which means Branch on result
\par   Not Equal to zero (i.e., Z not set).
\par     The index registers have a number of associated instructions which
\par   modify their contents. For example, the INX instruction INcrements the X
\par   index register. If the X register contained $FF before it was incremented
\par   (the maximum number the X register can contain), it will "wrap around"
\par   back to zero. If you wanted a program to continue to do something until
\par   you had performed the increment of the X index that pushed it around to
\par   zero, you could use the BNE instruction to continue "looping" around,
\par   until X became zero.
\par     The reverse of INX, is DEX, which is DEcrement the X index register. If
\par   the X index register is zero, DEX wraps around to $FF. Similarly, there
\par   are INY and DEY for the Y index register.
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  226   BASIC TO MACHINE LANGUAGE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     But what if a program didn't want to wait until X or Y had reached (or
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  not reached) zero? Well there are comparison instructions, CPX and CPY,
\par   which allow the machine language programmer to test the index registers
\par   with specific values, or even the contents of memory locations. If you
\par   wanted to see if the X register contained $40, you would use the
\par   instruction:
\par 
\par 
\par     CPX #$40         - compare X with the "value" $40.
\par     BEQ              - branch to somewhere else in the
\par     (some other        program, if this condition is "true."
\par      part of the
\par      program)
\par 
\par 
\par   The compare, and branch instructions play a major part in any machine
\par   language program.
\par     The operand specified in a branch instruction when using 64MON is the
\par   address of the part of the program that the branch goes to when the
\par   proper conditions are met. However, the operand is only an offset, which
\par   gets you from where the program currently is to the address specified.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  This offset is just one byte, and therefore the range that a branch
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  instruction can branch to is limited. It can branch from 128 bytes back-
\par   ward, to 127 bytes forward.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par   | NOTE: This is a total range of 255 bytes which is, of course, the     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | maximum range of values one byte can contain.                         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    64MON will tell you if you "branch out of range" by refusing to "as-
\par   semble" that particular instruction. But don't worry about that now be-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cause it's unlikely that you will have such branches for quite a while.
\par   The branch is a "quick" instruction by machine language standards because
\par   of the "offset" principle as opposed to an absolute address. 64MON allows
\par   you to type in an absolute address, and it calculates the correct offset.
\par   This is just one of the "comforts" of using an assembler.
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE: It is NOT possible to cover every single branch instruction. For|
\par   | further information, refer to the Bibliography section in Appendix F. |
\par   +-----------------------------------------------------------------------+
\par 
\par                                             BASIC TO MACHINE LANGUAGE   227
\par \page 
\par 
\par 
\par   SUBROUTINES
\par 
\par     In machine language (in the same way as using BASIC), you can call
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  subroutines. The instruction to call a subroutine is JSR (Jump to Sub-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Routine), followed by the specified absolute address.
\par     Incorporated in the operating system, there is a machine language
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  subroutine that will PRINT a character to the screen. The CBM ASCII code
\par   of the character should be in the accumulator before calling the
\par   subroutine. The address of this subroutine is $FFD2.
\par     Therefore, to print "Hi" to the screen, the following program should be
\par   entered:
\par 
\par 
\par 
\par     .A 1400 LDA #$48     - load the CBM ASCII code of "H"
\par     .A 1402 JSR $FFD2    -  print it
\par     .A 1405 LDA #$49     - load the CBM ASCII code of "I"
\par     .A 1407 JSR $FFD2    -  print that too
\par     .A 140A LDA #$0D     - print a carriage return as well
\par     .A 140C JSR $FFD2
\par     .A 140F BRK          - return to 64MON
\par     .G 1400              - will print "HI" and return to 64MON
\par 
\par 
\par 
\par     The "PRINT a character" routine we have just used is part of the KERNAL
\par   jump table. The instruction similar to GOTO in BASIC is JMP, which means
\par   JUMP to the specified absolute address. The KERNAL is a long list of
\par   "standardized" subroutines that control ALL input and output of the
\par   Commodore 64. Each entry in the KERNAL JMPs to a subroutine in the
\par   operating system. This "jump table" is found between memory locations
\par   $FF84 to $FFF5 in the operating system. A full explanation of the KERNAL
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is available in the "KERNAL Reference Section" of this manual. However,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  certain routines are used here to show how easy and effective the KERNAL
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Let's now use the new principles you've just learned in another pro-
\par   gram. It will help you to put the instructions into context:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  228   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This program. will display the alphabet using a KERNAL routine. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  only new instruction introduced here is TXA Transfer the contents of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  X index register, into the Accumulator.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .A 1400 LDX #$41     - X = CBM ASCII of "A"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .A 1402 TXA          - A = X
\par     .A 1403 JSR $FFD2    - print character
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .A 1406 INX          - bump count
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .A 1407 CPX #$5B     - have we gone past "Z"?
\par     .A 1409 BNE $1402    - no, go back and do more
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .A 140B BRK          - yes, return to 64MON
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     To see the Commodore 64 print the alphabet, type the familiar command:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .G 1400
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The comments that are beside the program, explain the program flow and
\par   logic. If you are writing a program, write it on paper first, and then
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  test it in small parts if possible.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  USEFUL TIPS FOR THE BEGINNER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     One of the best ways to learn machine language is to look at other
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  peoples' machine language programs. These are published all the time in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  magazines and newsletters. Look at them even if the article is for a
\par   different computer, which also uses the 6510 (or 6502) microprocessor.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  You should make sure that you thoroughly understand the code that you
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  look at. This will require perseveres I ce, especially when you see a new
\par   technique that you have never come across before. This can be infuriat-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ing, but if patience prevails, you will be the victor.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Having looked at other machine language programs, you MUST write your
\par   own. These may be utilities for your BASIC programs, or they may be an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  all machine language program.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   229
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    You should also use the utilities that are available, either IN your
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  computer, or in a program, that aid you in writing, editing, or tracking
\par   down errors in a machine language program. An example would be the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  KERNAL, which allows you to check the keyboard, print text, control
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  peripheral devices like disk drives, printers, modems, etc., manage
\par   memory and the screen. It is extremely powerful and it is advised
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  strongly that it is used (refer to KERNAL section, Page 268).
\par     Advantages of writing programs in machine language:
\par 
\par     1. Speed - Machine language is hundreds, and in some cases thousands of
\par        times faster than a high level language such as BASIC.
\par 
\par     2. Tightness - A machine language program can be made totally
\par        "watertight," i.e., the user can be made to do ONLY what the program
\par         allows, and no more. With a high level language, you are relying on
\par         the user not "crashing" the BASIC interpreter by entering, for
\par         example, a zero which later causes a:
\par 
\par 
\par   ?DIVISION BY ZERO ERROR IN LINE 830
\par 
\par   READY.
\par 
\par 
\par   In essence, the computer can only be maximized by the machine language
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  programmer.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  APPROACHING A LARGE TASK
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     When approaching a large task in machine language, a certain amount of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  subconscious thought has usually taken place. You think about how certain
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  processes are carried out in machine language. When the task is started,
\par   it is usually a good idea to write it out on paper. Use block diagrams of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  memory usage, functional modules of code required, and a program flow.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Let's say that you wanted to write a roulette game in machine language.
\par   You could outline it something like this:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  230   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    o Display title
\par     o Ask if player requires instructions
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    o YES - display them-Go to START
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    o NO - Go to START
\par     o START Initialize everything
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    o MAIN display roulette table
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    o Take in bets
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    o Spin wheel
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    o Slow wheel to stop
\par     o Check bets with result
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    o Inform player
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    o Player any money left?
\par     o YES - Go to MAIN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    o NO - Inform user!, and go to START
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This is the main outline. As each module is approached, you can break
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  it down further. If you look at a large indigestable problem as something
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  that can be broken down into small enough pieces to be eaten, then you'll
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  be able to approach something that seems impossible, and have it all fall
\par   into place.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This process only improves with practice, so KEEP TRYING.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   231
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +------------------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      MCS6510 MICROPROCESSOR INSTRUCTION SET - ALPHABETIC SEQUENCE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------------------------------------------------
\par   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     ADC   Add Memory to Accumulator with Carry
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     AND   "AND" Memory with Accumulator
\par   |     ASL   Shift Left One Bit (Memory or Accumulator)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     BCC   Branch on Carry Clear
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     BCS   Branch on Carry Set
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     BEQ   Branch on Result Zero
\par   |     BIT   Test Bits in Memory with Accumulator
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     BMI   Branch on Result Minus
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     BNE   Branch on Result not Zero
\par   |     BPL   Branch on Result Plus
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     BRK   Force Break
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     BVC   Branch on Overflow Clear
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     BVS   Branch on Overflow Set
\par   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     CLC   Clear Carry Flag
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     CLD   Clear Decimal Mode
\par   |     CLI   Clear interrupt Disable Bit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     CLV   Clear Overflow Flag
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     CMP   Compare Memory and Accumulator
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     CPX   Compare Memory and Index X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     CPY   Compare Memory and Index Y
\par   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     DEC   Decrement Memory by One
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     DEX   Decrement Index X by One
\par   |     DEY   Decrement Index Y by One
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     EOR   "Exclusive-Or" Memory with Accumulator
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     INC   Increment Memory by One
\par   |     INX   Increment Index X by One
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     INY   Increment Index Y by One
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |
\par   |     JMP   Jump to New Location
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  232   BASIC TO MACHINE LANGUAGE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ------------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                                          |
\par          MCS6510 MICROPROCESSOR INSTRUCTION SET - ALPHABETIC SEQUENCE     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                                          |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ------------------------------------------------------------------------+
\par                                                                           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        JSR   Jump to New Location Saving Return Address                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                                          |
\par         LDA   Load Accumulator with Memory                                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        LDX   Load Index X with Memory                                    |
\par         LDY   Load Index Y with Memory                                    |
\par         LSR   Shift Right One Bit (Memory or Accumulator)                 |
\par                                                                           |
\par         NOP   No Operation                                                |
\par                                                                           |
\par         ORA   "OR" Memory with Accumulator                                |
\par                                                                           |
\par         PHA   Push Accumulator on Stack                                   |
\par         PHP   Push Processor Status on Stack                              |
\par         PLA   Pull Accumulator from Stack                                 |
\par         PLP   Pull Processor Status from Stack                            |
\par                                                                           |
\par         ROL   Rotate One Bit Left (Memory or Accumulator)                 |
\par         ROR   Rotate One Bit Right (Memory or Accumulator)                |
\par         RTI   Return from Interrupt                                       |
\par         RTS   Return from Subroutine                                      |
\par                                                                           |
\par         SBC   Subtract Memory from Accumulator with Borrow                |
\par         SEC   Set Carry Flag                                              |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        SED   Set Decimal Mode                                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        SEI   Set Interrupt Disable Status                                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        STA   Store Accumulator in Memory                                 |
\par         STX   Store Index X in Memory                                     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        STY   Store Index Y in Memory                                     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                                          |
\par         TAX   Transfer Accumulator to Index X                             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        TAY   Transfer Accumulator to Index Y                             |
\par         TSX   Transfer Stack Pointer to Index X                           |
\par         TXA   Transfer Index X to Accumulator                             |
\par         TXS   Transfer Index X to Stack Pointer                           |
\par         TYA   Transfer Index Y to Accumulator                             |
\par   ------------------------------------------------------------------------+
\par 
\par                                             BASIC TO MACHINE LANGUAGE   233
\par \page 
\par 
\par 
\par                 The following notation applies to this summary:
\par 
\par 
\par      A       Accumulator                  EOR     Logical Exclusive Or
\par 
\par      X, Y    Index Registers              fromS   Transfer from Stack
\par 
\par      M       Memory                       toS     Transfer to Stack
\par 
\par      P       Processor Status Register    ->      Transfer to
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     S       Stack Pointer                <-      Transfer from
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par      /       Change                       V       Logical OR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     _       No Change                    PC      Program Counter
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     +       Add                          PCH     Program Counter High
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     /\\      Logical AND                  PCL     Program Counter Low
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par      -       Subtract                     OPER    OPERAND
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                          #       IMMEDIATE ADDRESSING MODE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Note: At the top of each table is located in parentheses a reference
\par         number (Ref: XX) which directs the user to that Section in the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        MCS6500 Microcomputer Family Programming Manual in which the
\par         instruction is defined and discussed.
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  234   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ADC               Add memory to accumulator with carry                ADC
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  A + M + C -> A, C                         N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        / / / _ _ /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                (Ref: 2.2.1)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Immediate     |   ADC #Oper           |    69   |    2    |    2     |
\par   |  Zero Page     |   ADC Oper            |    65   |    2    |    3     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Zero Page,X   |   ADC Oper,X          |    75   |    2    |    4     |
\par   |  Absolute      |   ADC Oper            |    60   |    3    |    4     |
\par   |  Absolute,X    |   ADC Oper,X          |    70   |    3    |    4*    |
\par   |  Absolute,Y    |   ADC Oper,Y          |    79   |    3    |    4*    |
\par   |  (Indirect,X)  |   ADC (Oper,X)        |    61   |    2    |    6     |
\par   |  (Indirect),Y  |   ADC (Oper),Y        |    71   |    2    |    5*    |
\par   +----------------+-----------------------+---------+---------+----------+
\par   * Add 1 if page boundary is crossed.
\par 
\par 
\par   AND                  "AND" memory with accumulator                    AND
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  A /\\ M -> A                               N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        / / _ _ _ _
\par                                (Ref: 2.2.3.0)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Immediate     |   AND #Oper           |    29   |    2    |    2     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Zero Page     |   AND Oper            |    25   |    2    |    3     |
\par   |  Zero Page,X   |   AND Oper,X          |    35   |    2    |    4     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Absolute      |   AND Oper            |    2D   |    3    |    4     |
\par   |  Absolute,X    |   AND Oper,X          |    3D   |    3    |    4*    |
\par   |  Absolute,Y    |   AND Oper,Y          |    39   |    3    |    4*    |
\par   |  (Indirect,X)  |   AND (Oper,X)        |    21   |    2    |    6     |
\par   |  (Indirect,Y)  |   AND (Oper),Y        |    31   |    2    |    5     |
\par   +----------------+-----------------------+---------+---------+----------+
\par   * Add 1 if page boundary is crossed.
\par 
\par 
\par 
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   235
\par \page 
\par 
\par 
\par   ASL          ASL Shift Left One Bit (Memory or Accumulator)           ASL
\par                    +-+-+-+-+-+-+-+-+
\par   Operation:  C <- |7|6|5|4|3|2|1|0| <- 0
\par                    +-+-+-+-+-+-+-+-+                    N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        / / / _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 (Ref: 10.2)
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Accumulator   |   ASL A               |    0A   |    1    |    2     |
\par   |  Zero Page     |   ASL Oper            |    06   |    2    |    5     |
\par   |  Zero Page,X   |   ASL Oper,X          |    16   |    2    |    6     |
\par   |  Absolute      |   ASL Oper            |    0E   |    3    |    6     |
\par   |  Absolute, X   |   ASL Oper,X          |    1E   |    3    |    7     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par   BCC                     BCC Branch on Carry Clear                     BCC
\par                                                         N Z C I D V
\par   Operation:  Branch on C = 0                           _ _ _ _ _ _
\par                                (Ref: 4.1.1.3)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Relative      |   BCC Oper            |    90   |    2    |    2*    |
\par   +----------------+-----------------------+---------+---------+----------+
\par   * Add 1 if branch occurs to same page.
\par   * Add 2 if branch occurs to different page.
\par 
\par 
\par   BCS                      BCS Branch on carry set                      BCS
\par 
\par   Operation:  Branch on C = 1                           N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        _ _ _ _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                               (Ref: 4.1.1.4)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Relative      |   BCS Oper            |    B0   |    2    |    2*    |
\par   +----------------+-----------------------+---------+---------+----------+
\par   * Add 1 if branch occurs to same  page.
\par   * Add 2 if branch occurs to next  page.
\par 
\par   236   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par   BEQ                    BEQ Branch on result zero                      BEQ
\par                                                         N Z C I D V
\par   Operation:  Branch on Z = 1                           _ _ _ _ _ _
\par                                (Ref: 4.1.1.5)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Relative      |   BEQ Oper            |    F0   |    2    |    2*    |
\par   +----------------+-----------------------+---------+---------+----------+
\par   * Add 1 if branch occurs to same  page.
\par   * Add 2 if branch occurs to next  page.
\par 
\par 
\par   BIT             BIT Test bits in memory with accumulator              BIT
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  A /\\ M, M7 -> N, M6 -> V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Bit 6 and 7 are transferred to the status register.   N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  If the result of A /\\ M is zero then Z = 1, otherwise M7/ _ _ _ M6
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Z = 0
\par                                (Ref: 4.2.1.1)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Zero Page     |   BIT Oper            |    24   |    2    |    3     |
\par   |  Absolute      |   BIT Oper            |    2C   |    3    |    4     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par   BMI                    BMI Branch on result minus                     BMI
\par 
\par   Operation:  Branch on N = 1                           N Z C I D V
\par                                                         _ _ _ _ _ _
\par                                (Ref: 4.1.1.1)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Relative      |   BMI Oper            |    30   |    2    |    2*    |
\par   +----------------+-----------------------+---------+---------+----------+
\par   * Add 1 if branch occurs to same page.
\par   * Add 1 if branch occurs to different page.
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   237
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BNE                   BNE Branch on result not zero                   BNE
\par 
\par   Operation:  Branch on Z = 0                           N Z C I D V
\par                                                         _ _ _ _ _ _
\par                                (Ref: 4.1.1.6)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Relative      |   BMI Oper            |    D0   |    2    |    2*    |
\par   +----------------+-----------------------+---------+---------+----------+
\par   * Add 1 if branch occurs to same page.
\par   * Add 2 if branch occurs to different page.
\par 
\par 
\par   BPL                     BPL Branch on result plus                     BPL
\par 
\par   Operation:  Branch on N = 0                           N Z C I D V
\par                                                         _ _ _ _ _ _
\par                                (Ref: 4.1.1.2)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Relative      |   BPL Oper            |    10   |    2    |    2*    |
\par   +----------------+-----------------------+---------+---------+----------+
\par   * Add 1 if branch occurs to same page.
\par   * Add 2 if branch occurs to different page.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   BRK                          BRK Force Break                          BRK
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  Forced Interrupt PC + 2 toS P toS         N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        _ _ _ 1 _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 (Ref: 9.11)
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   BRK                 |    00   |    1    |    7     |
\par   +----------------+-----------------------+---------+---------+----------+
\par   1. A BRK command cannot be masked by setting I.
\par 
\par 
\par 
\par 
\par   238   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par   BVC                   BVC Branch on overflow clear                    BVC
\par 
\par   Operation:  Branch on V = 0                           N Z C I D V
\par                                                         _ _ _ _ _ _
\par                                (Ref: 4.1.1.8)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Relative      |   BVC Oper            |    50   |    2    |    2*    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  * Add 1 if branch occurs to same page.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  * Add 2 if branch occurs to different page.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BVS                    BVS Branch on overflow set                     BVS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  Branch on V = 1                           N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        _ _ _ _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                               (Ref: 4.1.1.7)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   |  Relative      |   BVS Oper            |    70   |    2    |    2*    |
\par   +----------------+-----------------------+---------+---------+----------+
\par   * Add 1 if branch occurs to same page.
\par   * Add 2 if branch occurs to different page.
\par 
\par 
\par   CLC                       CLC Clear carry flag                        CLC
\par 
\par   Operation:  0 -> C                                    N Z C I D V
\par                                                         _ _ 0 _ _ _
\par                                 (Ref: 3.0.2)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   CLC                 |    18   |    1    |    2     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   239
\par \page 
\par 
\par 
\par   CLD                      CLD Clear decimal mode                       CLD
\par 
\par   Operation:  0 -> D                                    N A C I D V
\par                                                         _ _ _ _ 0 _
\par                                 (Ref: 3.3.2)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   CLD                 |    D8   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par   CLI                  CLI Clear interrupt disable bit                  CLI
\par 
\par   Operation: 0 -> I                                     N Z C I D V
\par                                                         _ _ _ 0 _ _
\par                                 (Ref: 3.2.2)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Implied       |   CLI                 |    58   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   CLV                      CLV Clear overflow flag                      CLV
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation: 0 -> V                                     N Z C I D V
\par                                                         _ _ _ _ _ 0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                (Ref: 3.6.1)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   CLV                 |    B8   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   240   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par   CMP                CMP Compare memory and accumulator                 CMP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  A - M                                     N Z C I D V
\par                                                         / / / _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                (Ref: 4.2.1)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   |  Immediate     |   CMP #Oper           |    C9   |    2    |    2     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Zero Page     |   CMP Oper            |    C5   |    2    |    3     |
\par   |  Zero Page,X   |   CMP Oper,X          |    D5   |    2    |    4     |
\par   |  Absolute      |   CMP Oper            |    CD   |    3    |    4     |
\par   |  Absolute,X    |   CMP Oper,X          |    DD   |    3    |    4*    |
\par   |  Absolute,Y    |   CMP Oper,Y          |    D9   |    3    |    4*    |
\par   |  (Indirect,X)  |   CMP (Oper,X)        |    C1   |    2    |    6     |
\par   |  (Indirect),Y  |   CMP (Oper),Y        |    D1   |    2    |    5*    |
\par   +----------------+-----------------------+---------+---------+----------+
\par   * Add 1 if page boundary is crossed.
\par 
\par   CPX                  CPX Compare Memory and Index X                   CPX
\par                                                         N Z C I D V
\par   Operation:  X - M                                     / / / _ _ _
\par                                  (Ref: 7.8)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Immediate     |   CPX *Oper           |    E0   |    2    |    2     |
\par   |  Zero Page     |   CPX Oper            |    E4   |    2    |    3     |
\par   |  Absolute      |   CPX Oper            |    EC   |    3    |    4     |
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CPY                  CPY Compare memory and index Y                   CPY
\par                                                         N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  Y - M                                     / / / _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 (Ref: 7.9)
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Immediate     |   CPY *Oper           |    C0   |    2    |    2     |
\par   |  Zero Page     |   CPY Oper            |    C4   |    2    |    3     |
\par   |  Absolute      |   CPY Oper            |    CC   |    3    |    4     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par                                             BASIC TO MACHINE LANGUAGE   241
\par \page 
\par 
\par 
\par   DEC                   DEC Decrement memory by one                     DEC
\par 
\par   Operation:  M - 1 -> M                                N Z C I D V
\par                                                         / / _ _ _ _
\par                                  (Ref: 10.7)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Zero Page     |   DEC Oper            |    C6   |    2    |    5     |
\par   |  Zero Page,X   |   DEC Oper,X          |    D6   |    2    |    6     |
\par   |  Absolute      |   DEC Oper            |    CE   |    3    |    6     |
\par   |  Absolute,X    |   DEC Oper,X          |    DE   |    3    |    7     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   DEX                   DEX Decrement index X by one                    DEX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  X - 1 -> X                                N Z C I D V
\par                                                         / / _ _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 (Ref: 7.6)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   DEX                 |    CA   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par   DEY                   DEY Decrement index Y by one                    DEY
\par 
\par   Operation:  X - 1 -> Y                                N Z C I D V
\par                                                         / / _ _ _ _
\par                                  (Ref: 7.7)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   DEY                 |    88   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   242   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EOR            EOR "Exclusive-Or" memory with accumulator             EOR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Operation:  A EOR M -> A                              N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        / / _ _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                               (Ref: 2.2.3.2)
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Immediate     |   EOR #Oper           |    49   |    2    |    2     |
\par   |  Zero Page     |   EOR Oper            |    45   |    2    |    3     |
\par   |  Zero Page,X   |   EOR Oper,X          |    55   |    2    |    4     |
\par   |  Absolute      |   EOR Oper            |    40   |    3    |    4     |
\par   |  Absolute,X    |   EOR Oper,X          |    50   |    3    |    4*    |
\par   |  Absolute,Y    |   EOR Oper,Y          |    59   |    3    |    4*    |
\par   |  (Indirect,X)  |   EOR (Oper,X)        |    41   |    2    |    6     |
\par   |  (Indirect),Y  |   EOR (Oper),Y        |    51   |    2    |    5*    |
\par   +----------------+-----------------------+---------+---------+----------+
\par   * Add 1 if page boundary is crossed.
\par 
\par   INC                    INC Increment memory by one                    INC
\par                                                         N Z C I D V
\par   Operation:  M + 1 -> M                                / / _ _ _ _
\par                                  (Ref: 10.6)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Zero Page     |   INC Oper            |    E6   |    2    |    5     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Zero Page,X   |   INC Oper,X          |    F6   |    2    |    6     |
\par   |  Absolute      |   INC Oper            |    EE   |    3    |    6     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Absolute,X    |   INC Oper,X          |    FE   |    3    |    7     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par   INX                    INX Increment Index X by one                   INX
\par                                                         N Z C I D V
\par   Operation:  X + 1 -> X                                / / _ _ _ _
\par                                  (Ref: 7.4)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   INX                 |    E8   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   243
\par \page 
\par 
\par 
\par   INY                    INY Increment Index Y by one                   INY
\par 
\par   Operation:  X + 1 -> X                                N Z C I D V
\par                                                         / / _ _ _ _
\par                                  (Ref: 7.5)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Implied       |   INY                 |    C8   |    1    |    2     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  JMP                     JMP Jump to new location                      JMP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  (PC + 1) -> PCL                           N Z C I D V
\par               (PC + 2) -> PCH   (Ref: 4.0.2)            _ _ _ _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                (Ref: 9.8.1)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   |  Absolute      |   JMP Oper            |    4C   |    3    |    3     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Indirect      |   JMP (Oper)          |    6C   |    3    |    5     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  JSR          JSR Jump to new location saving return address           JSR
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  PC + 2 toS, (PC + 1) -> PCL               N Z C I D V
\par                           (PC + 2) -> PCH               _ _ _ _ _ _
\par                                  (Ref: 8.1)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Absolute      |   JSR Oper            |    20   |    3    |    6     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   244   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LDA                  LDA Load accumulator with memory                 LDA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Operation:  M -> A                                    N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        / / _ _ _ _
\par                                 (Ref: 2.1.1)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Immediate     |   LDA #Oper           |    A9   |    2    |    2     |
\par   |  Zero Page     |   LDA Oper            |    A5   |    2    |    3     |
\par   |  Zero Page,X   |   LDA Oper,X          |    B5   |    2    |    4     |
\par   |  Absolute      |   LDA Oper            |    AD   |    3    |    4     |
\par   |  Absolute,X    |   LDA Oper,X          |    BD   |    3    |    4*    |
\par   |  Absolute,Y    |   LDA Oper,Y          |    B9   |    3    |    4*    |
\par   |  (Indirect,X)  |   LDA (Oper,X)        |    A1   |    2    |    6     |
\par   |  (Indirect),Y  |   LDA (Oper),Y        |    B1   |    2    |    5*    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  * Add 1 if page boundary is crossed.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   LDX                   LDX Load index X with memory                    LDX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  M -> X                                    N Z C I D V
\par                                                         / / _ _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 (Ref: 7.0)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Immediate     |   LDX #Oper           |    A2   |    2    |    2     |
\par   |  Zero Page     |   LDX Oper            |    A6   |    2    |    3     |
\par   |  Zero Page,Y   |   LDX Oper,Y          |    B6   |    2    |    4     |
\par   |  Absolute      |   LDX Oper            |    AE   |    3    |    4     |
\par   |  Absolute,Y    |   LDX Oper,Y          |    BE   |    3    |    4*    |
\par   +----------------+-----------------------+---------+---------+----------+
\par   * Add 1 when page boundary is crossed.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   245
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   LDY                   LDY Load index Y with memory                    LDY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  M -> Y                                    / / _ _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 (Ref: 7.1)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   |  Immediate     |   LDY #Oper           |    A0   |    2    |    2     |
\par   |  Zero Page     |   LDY Oper            |    A4   |    2    |    3     |
\par   |  Zero Page,X   |   LDY Oper,X          |    B4   |    2    |    4     |
\par   |  Absolute      |   LDY Oper            |    AC   |    3    |    4     |
\par   |  Absolute,X    |   LDY Oper,X          |    BC   |    3    |    4*    |
\par   +----------------+-----------------------+---------+---------+----------+
\par   * Add 1 when page boundary is crossed.
\par 
\par 
\par   LSR          LSR Shift right one bit (memory or accumulator)          LSR
\par 
\par                    +-+-+-+-+-+-+-+-+
\par   Operation:  0 -> |7|6|5|4|3|2|1|0| -> C               N Z C I D V
\par                    +-+-+-+-+-+-+-+-+                    0 / / _ _ _
\par                                  (Ref: 10.1)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Accumulator   |   LSR A               |    4A   |    1    |    2     |
\par   |  Zero Page     |   LSR Oper            |    46   |    2    |    5     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Zero Page,X   |   LSR Oper,X          |    56   |    2    |    6     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Absolute      |   LSR Oper            |    4E   |    3    |    6     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Absolute,X    |   LSR Oper,X          |    5E   |    3    |    7     |
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   NOP                         NOP No operation                          NOP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  No Operation (2 cycles)                   _ _ _ _ _ _
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   NOP                 |    EA   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par   246   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par   ORA                 ORA "OR" memory with accumulator                  ORA
\par 
\par   Operation: A V M -> A                                 N Z C I D V
\par                                                         / / _ _ _ _
\par                                (Ref: 2.2.3.1)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Immediate     |   ORA #Oper           |    09   |    2    |    2     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Zero Page     |   ORA Oper            |    05   |    2    |    3     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Zero Page,X   |   ORA Oper,X          |    15   |    2    |    4     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Absolute      |   ORA Oper            |    0D   |    3    |    4     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Absolute,X    |   ORA Oper,X          |    10   |    3    |    4*    |
\par   |  Absolute,Y    |   ORA Oper,Y          |    19   |    3    |    4*    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  (Indirect,X)  |   ORA (Oper,X)        |    01   |    2    |    6     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  (Indirect),Y  |   ORA (Oper),Y        |    11   |    2    |    5     |
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  * Add 1 on page crossing
\par 
\par 
\par   PHA                   PHA Push accumulator on stack                   PHA
\par 
\par   Operation:  A toS                                     N Z C I D V
\par                                                         _ _ _ _ _ _
\par                                  (Ref: 8.5)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   PHA                 |    48   |    1    |    3     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par   PHP                 PHP Push processor status on stack                PHP
\par 
\par   Operation:  P toS                                     N Z C I D V
\par                                                         _ _ _ _ _ _
\par                                  (Ref: 8.11)
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Implied       |   PHP                 |    08   |    1    |    3     |
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   247
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   PLA                 PLA Pull accumulator from stack                   PLA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  A fromS                                   N Z C I D V
\par                                                         _ _ _ _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 (Ref: 8.6)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   PLA                 |    68   |    1    |    4     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par   PLP               PLP Pull processor status from stack                PLA
\par 
\par   Operation:  P fromS                                   N Z C I D V
\par                                                          From Stack
\par                                  (Ref: 8.12)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Implied       |   PLP                 |    28   |    1    |    4     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ROL          ROL Rotate one bit left (memory or accumulator)          ROL
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                +------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               |         M or A               |
\par                |   +-+-+-+-+-+-+-+-+    +-+   |
\par   Operation:   +-< |7|6|5|4|3|2|1|0| <- |C| <-+         N Z C I D V
\par                    +-+-+-+-+-+-+-+-+    +-+             / / / _ _ _
\par                                  (Ref: 10.3)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Accumulator   |   ROL A               |    2A   |    1    |    2     |
\par   |  Zero Page     |   ROL Oper            |    26   |    2    |    5     |
\par   |  Zero Page,X   |   ROL Oper,X          |    36   |    2    |    6     |
\par   |  Absolute      |   ROL Oper            |    2E   |    3    |    6     |
\par   |  Absolute,X    |   ROL Oper,X          |    3E   |    3    |    7     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par   248   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par   ROR          ROR Rotate one bit right (memory or accumulator)         ROR
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               +------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               |                              |
\par                |   +-+    +-+-+-+-+-+-+-+-+   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:   +-> |C| -> |7|6|5|4|3|2|1|0| >-+         N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                   +-+    +-+-+-+-+-+-+-+-+             / / / _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 (Ref: 10.4)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   |  Accumulator   |   ROR A               |    6A   |    1    |    2     |
\par   |  Zero Page     |   ROR Oper            |    66   |    2    |    5     |
\par   |  Zero Page,X   |   ROR Oper,X          |    76   |    2    |    6     |
\par   |  Absolute      |   ROR Oper            |    6E   |    3    |    6     |
\par   |  Absolute,X    |   ROR Oper,X          |    7E   |    3    |    7     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par     Note: ROR instruction is available on MCS650X microprocessors after
\par           June, 1976.
\par 
\par 
\par   RTI                    RTI Return from interrupt                      RTI
\par                                                         N Z C I D V
\par   Operation:  P fromS PC fromS                           From Stack
\par                                  (Ref: 9.6)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   RTI                 |    4D   |    1    |    6     |
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   RTS                    RTS Return from subroutine                     RTS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  PC fromS, PC + 1 -> PC                    _ _ _ _ _ _
\par                                  (Ref: 8.2)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   RTS                 |    60   |    1    |    6     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par                                             BASIC TO MACHINE LANGUAGE   249
\par \page 
\par 
\par 
\par   SBC          SBC Subtract memory from accumulator with borrow         SBC
\par                       -
\par   Operation:  A - M - C -> A                            N Z C I D V
\par          -                                              / / / _ _ /
\par     Note:C = Borrow             (Ref: 2.2.2)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Immediate     |   SBC #Oper           |    E9   |    2    |    2     |
\par   |  Zero Page     |   SBC Oper            |    E5   |    2    |    3     |
\par   |  Zero Page,X   |   SBC Oper,X          |    F5   |    2    |    4     |
\par   |  Absolute      |   SBC Oper            |    ED   |    3    |    4     |
\par   |  Absolute,X    |   SBC Oper,X          |    FD   |    3    |    4*    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Absolute,Y    |   SBC Oper,Y          |    F9   |    3    |    4*    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  (Indirect,X)  |   SBC (Oper,X)        |    E1   |    2    |    6     |
\par   |  (Indirect),Y  |   SBC (Oper),Y        |    F1   |    2    |    5     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  * Add 1 when page boundary is crossed.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SEC                        SEC Set carry flag                         SEC
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  1 -> C                                    N Z C I D V
\par                                                         _ _ 1 _ _ _
\par                                 (Ref: 3.0.1)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   SEC                 |    38   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par   SED                       SED Set decimal mode                        SED
\par                                                         N Z C I D V
\par   Operation:  1 -> D                                    _ _ _ _ 1 _
\par                                 (Ref: 3.3.1)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   SED                 |    F8   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  250   BASIC TO MACHINE LANGUAGE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SEI                 SEI Set interrupt disable status                  SED
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        N Z C I D V
\par   Operation:  1 -> I                                    _ _ _ 1 _ _
\par                                 (Ref: 3.2.1)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   SEI                 |    78   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par   STA                  STA Store accumulator in memory                  STA
\par 
\par   Operation:  A -> M                                    N Z C I D V
\par                                                         _ _ _ _ _ _
\par                                 (Ref: 2.1.2)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Zero Page     |   STA Oper            |    85   |    2    |    3     |
\par   |  Zero Page,X   |   STA Oper,X          |    95   |    2    |    4     |
\par   |  Absolute      |   STA Oper            |    80   |    3    |    4     |
\par   |  Absolute,X    |   STA Oper,X          |    90   |    3    |    5     |
\par   |  Absolute,Y    |   STA Oper, Y         |    99   |    3    |    5     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  (Indirect,X)  |   STA (Oper,X)        |    81   |    2    |    6     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  (Indirect),Y  |   STA (Oper),Y        |    91   |    2    |    6     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STX                    STX Store index X in memory                    STX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Operation: X -> M                                     N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        _ _ _ _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 (Ref: 7.2)
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Zero Page     |   STX Oper            |    86   |    2    |    3     |
\par   |  Zero Page,Y   |   STX Oper,Y          |    96   |    2    |    4     |
\par   |  Absolute      |   STX Oper            |    8E   |    3    |    4     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   251
\par \page 
\par 
\par 
\par   STY                    STY Store index Y in memory                    STY
\par 
\par   Operation: Y -> M                                     N Z C I D V
\par                                                         _ _ _ _ _ _
\par                                  (Ref: 7.3)
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   |  Zero Page     |   STY Oper            |    84   |    2    |    3     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Zero Page,X   |   STY Oper,X          |    94   |    2    |    4     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Absolute      |   STY Oper            |    8C   |    3    |    4     |
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TAX                TAX Transfer accumulator to index X                TAX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  A -> X                                    N Z C I D V
\par                                                         / / _ _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 (Ref: 7.11)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   TAX                 |    AA   |    1    |    2     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TAY                TAY Transfer accumulator to index Y                TAY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Operation:  A -> Y                                    N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        / / _ _ _ _
\par                                  (Ref: 7.13)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   TAY                 |    A8   |    1    |    2     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   252   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TSX              TSX Transfer stack pointer to index X                TSX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Operation:  S -> X                                    N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                        / / _ _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 (Ref: 8.9)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Implied       |   TSX                 |    BA   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par   TXA                TXA Transfer index X to accumulator                TXA
\par                                                         N Z C I D V
\par   Operation:  X -> A                                    / / _ _ _ _
\par                                  (Ref: 7.12)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Implied       |   TXA                 |    8A   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TXS              TXS Transfer index X to stack pointer                TXS
\par                                                         N Z C I D V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operation:  X -> S                                    _ _ _ _ _ _
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 (Ref: 8.8)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  Implied       |   TXS                 |    9A   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par   TYA                TYA Transfer index Y to accumulator                TYA
\par 
\par   Operation:  Y -> A                                    N Z C I D V
\par                                                         / / _ _ _ _
\par                                  (Ref: 7.14)
\par   +----------------+-----------------------+---------+---------+----------+
\par   | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
\par   +----------------+-----------------------+---------+---------+----------+
\par   |  Implied       |   TYA                 |    98   |    1    |    2     |
\par   +----------------+-----------------------+---------+---------+----------+
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   253
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------------------------------------------------
\par   | INSTRUCTION ADDRESSING MODES AND RELATED EXECUTION TIMES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | (in clock cycles)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------------------------------------------------
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                  A   A   A   B   B   B   B   B   B   B   B   B   B   C
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                  D   N   S   C   C   E   I   M   N   P   R   V   V   L
\par                   C   D   L   C   S   Q   T   I   E   L   K   C   S   C
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Accumulator  |  .   .   2   .   .   .   .   .   .   .   .   .   .   .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Immediate    |  2   2       .   .   .   .   .   .   .   .   .   .   .
\par   Zero Page    |  3   3   5   .   .   .   3   .   .   .   .   .   .   .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Zero Page,X  |  4   4   6   .   .   .   .   .   .   .   .   .   .   .
\par   Zero Page,Y  |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
\par   Absolute     |  4   4   6   .   .   .   4   .   .   .   .   .   .   .
\par   Absolute,X   |  4*  4*  7   .   .   .   .   .   .   .   .   .   .   .
\par   Absolute,Y   |  4*  4*  .   .   .   .   .   .   .   .   .   .   .   .
\par   Implied      |  .   .   .   .   .   .   .   .   .   .   .   .   .   2
\par   Relative     |  .   .   .   2** 2** 2** .   2** 2** 2** 7   2** 2** .
\par   (Indirect,X) |  6   6   .   .   .   .   .   .   .   .   .   .   .   .
\par   (Indirect),Y |  5*  5*  .   .   .   .   .   .   .   .   .   .   .   .
\par   Abs. Indirect|  .   .   .   .   .   .   .   .   .   .   .   .   .   .
\par                +-----------------------------------------------------------
\par                   C   C   C   C   C   C   D   D   D   E   I   I   I   J
\par                   L   L   L   M   P   P   E   E   E   O   N   N   N   M
\par                   D   I   V   P   X   Y   C   X   Y   R   C   X   Y   P
\par   Accumulator  |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
\par   Immediate    |  .   .   .   2   2   2   .   .   .   2   .   .   .   .
\par   Zero Page    |  .   .   .   3   3   3   5   .   .   3   5   .   .   .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Zero Page,X  |  .   .   .   4   .   .   6   .   .   4   6   .   .   .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Zero Page,Y  |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Absolute     |  .   .   .   4   4   4   6   .   .   4   6   .   .   3
\par   Absolute,X   |  .   .   .   4*  .   .   7   .   .   4*  7   .   .   .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Absolute,Y   |  .   .   .   4*  .   .   .   .   .   4*  .   .   .   .
\par   Implied      |  2   2   2   .   .   .   .   2   2   .   .   2   2   .
\par   Relative     |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
\par   (Indirect,X) |  .   .   .   6   .   .   .   .   .   6   .   .   .   .
\par   (Indirect),Y |  .   .   .   5*  .   .   .   .   .   5*  .   .   .   .
\par   Abs. Indirect|  .   .   .   .   .   .   .   .   .   .   .   .   .   5
\par                +-----------------------------------------------------------
\par      *  Add one cycle if indexing across page boundary
\par      ** Add one cycle if branch is taken, Add one additional if branching
\par         operation crosses page boundary
\par 
\par   254   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par   ------------------------------------------------------------------------+
\par     INSTRUCTION ADDRESSING MODES AND RELATED EXECUTION TIMES              |
\par     (in clock cycles)                                                     |
\par   ------------------------------------------------------------------------+
\par 
\par                   J   L   L   L   L   N   O   P   P   P   P   R   R   R
\par                   S   D   D   D   S   O   R   H   H   L   L   O   O   T
\par                   R   A   X   Y   R   P   A   A   P   A   P   L   R   I
\par   Accumulator  |  .   .   .   .   2   .   .   .   .   .   .   2   2   .
\par   Immediate    |  .   2   2   2   .   .   2   .   .   .   .   .   .   .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Zero Page    |  .   3   3   3   5   .   3   .   .   .   .   5   5   .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Zero Page,X  |  .   4   .   4   6   .   4   .   .   .   .   6   6   .
\par   Zero Page,Y  |  .   .   4   .   .   .   .   .   .   .   .   .   .   .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Absolute     |  6   4   4   4   6   .   4   .   .   .   .   6   6   .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Absolute,X   |  .   4*  .   4*  7   .   4*  .   .   .   .   7   7   .
\par   Absolute,Y   |  .   4*  4*  .   .   .   4*  .   .   .   .   .   .   .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Implied      |  .   .   .   .   .   2   .   3   3   4   4   .   .   6
\par   Relative     |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
\par   (Indirect,X) |  .   6   .   .   .   .   6   .   .   .   .   .   .   .
\par   (Indirect),Y |  .   5*  .   .   .   .   5*  .   .   .   .   .   .   .
\par   Abs. Indirect|  .   .   .   .   .   .   .   .   .   .   .   .   .   .
\par                +-----------------------------------------------------------
\par                   R   S   S   S   S   S   S   S   T   T   T   T   T   T
\par                   T   B   E   E   E   T   T   T   A   A   S   X   X   Y
\par                   S   C   C   D   I   A   X   Y   X   Y   X   A   S   A
\par   Accumulator  |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
\par   Immediate    |  .   2   .   .   .   .   .   .   .   .   .   .   .   .
\par   Zero Page    |  .   3   .   .   .   3   3   3   .   .   .   .   .   .
\par   Zero Page,X  |  .   4   .   .   .   4   .   4   .   .   .   .   .   .
\par   Zero Page,Y  |  .   .   .   .   .   .   4   .   .   .   .   .   .   .
\par   Absolute     |  .   4   .   .   .   4   4   4   .   .   .   .   .   .
\par   Absolute,X   |  .   4*  .   .   .   5   .   .   .   .   .   .   .   .
\par   Absolute,Y   |  .   4*  .   .   .   5   .   .   .   .   .   .   .   .
\par   Implied      |  6   .   2   2   2   .   .   .   2   2   2   2   2   2
\par   Relative     |  .   .   .   .   .   .   .   .   .   .   .   .   .   .
\par   (Indirect,X) |  .   6   .   .   .   6   .   .   .   .   .   .   .   .
\par   (Indirect),Y |  .   5*  .   .   .   6   .   .   .   .   .   .   .   .
\par   Abs. Indirect|  .   .   .   .   .   .   .   .   .   .   .   .   .   .
\par                +-----------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     *  Add one cycle if indexing across page boundary
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     ** Add one cycle if branch is taken, Add one additional if branching
\par         operation crosses page boundary
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                              BASIC TO MACHINE LANGUAGE 255
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par         00 - BRK                        20 - JSR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        01 - ORA - (Indirect,X)         21 - AND - (Indirect,X)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        02 - Future Expansion           22 - Future Expansion
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        03 - Future Expansion           23 - Future Expansion
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        04 - Future Expansion           24 - BIT - Zero Page
\par         05 - ORA - Zero Page            25 - AND - Zero Page
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        06 - ASL - Zero Page            26 - ROL - Zero Page
\par         07 - Future Expansion           27 - Future Expansion
\par         08 - PHP                        28 - PLP
\par         09 - ORA - Immediate            29 - AND - Immediate
\par         0A - ASL - Accumulator          2A - ROL - Accumulator
\par         0B - Future Expansion           2B - Future Expansion
\par         0C - Future Expansion           2C - BIT - Absolute
\par         0D - ORA - Absolute             2D - AND - Absolute
\par         0E - ASL - Absolute             2E - ROL - Absolute
\par         0F - Future Expansion           2F - Future Expansion
\par         10 - BPL                        30 - BMI
\par         11 - ORA - (Indirect),Y         31 - AND - (Indirect),Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        12 - Future Expansion           32 - Future Expansion
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        13 - Future Expansion           33 - Future Expansion
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        14 - Future Expansion           34 - Future Expansion
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        15 - ORA - Zero Page,X          35 - AND - Zero Page,X
\par         16 - ASL - Zero Page,X          36 - ROL - Zero Page,X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        17 - Future Expansion           37 - Future Expansion
\par         18 - CLC                        38 - SEC
\par         19 - ORA - Absolute,Y           39 - AND - Absolute,Y
\par         1A - Future Expansion           3A - Future Expansion
\par         1B - Future Expansion           3B - Future Expansion
\par         1C - Future Expansion           3C - Future Expansion
\par         1D - ORA - Absolute,X           3D - AND - Absolute,X
\par         1E - ASL - Absolute,X           3E - ROL - Absolute,X
\par         1F - Future Expansion           3F - Future Expansion
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   256   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        40 - RTI                        60 - RTS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        41 - EOR - (Indirect,X)         61 - ADC - (Indirect,X)
\par         42 - Future Expansion           62 - Future Expansion
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        43 - Future Expansion           63 - Future Expansion
\par         44 - Future Expansion           64 - Future Expansion
\par         45 - EOR - Zero Page            65 - ADC - Zero Page
\par         46 - LSR - Zero Page            66 - ROR - Zero Page
\par         47 - Future Expansion           67 - Future Expansion
\par         48 - PHA                        68 - PLA
\par         49 - EOR - Immediate            69 - ADC - Immediate
\par         4A - LSR - Accumulator          6A - ROR - Accumulator
\par         4B - Future Expansion           6B - Future Expansion
\par         4C - JMP - Absolute             6C - JMP - Indirect
\par         4D - EOR - Absolute             6D - ADC - Absolute
\par         4E - LSR - Absolute             6E - ROR - Absolute
\par         4F - Future Expansion           6F - Future Expansion
\par         50 - BVC                        70 - BVS
\par         51 - EOR - (Indirect),Y         71 - ADC - (Indirect),Y
\par         52 - Future Expansion           72 - Future Expansion
\par         53 - Future Expansion           73 - Future Expansion
\par         54 - Future Expansion           74 - Future Expansion
\par         55 - EOR - Zero Page,X          75 - ADC - Zero Page,X
\par         56 - LSR - Zero Page,X          76 - ROR - Zero Page,X
\par         57 - Future Expansion           77 - Future Expansion
\par         58 - CLI                        78 - SEI
\par         59 - EOR - Absolute,Y           79 - ADC - Absolute,Y
\par         5A - Future Expansion           7A - Future Expansion
\par         5B - Future Expansion           7B - Future Expansion
\par         5C - Future Expansion           7C - Future Expansion
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        50 - EOR - Absolute,X           70 - ADC - Absolute,X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        5E - LSR - Absolute,X           7E - ROR - Absolute,X
\par         5F - Future Expansion           7F - Future Expansion
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                             BASIC TO MACHINE LANGUAGE   257
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        80 - Future Expansion           A0 - LDY - Immediate
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        81 - STA - (Indirect,X)         A1 - LDA - (Indirect,X)
\par         82 - Future Expansion           A2 - LDX - Immediate
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        83 - Future Expansion           A3 - Future Expansion
\par         84 - STY - Zero Page            A4 - LDY - Zero Page
\par         85 - STA - Zero Page            A5 - LDA - Zero Page
\par         86 - STX - Zero Page            A6 - LDX - Zero Page
\par         87 - Future Expansion           A7 - Future Expansion
\par         88 - DEY                        A8 - TAY
\par         89 - Future Expansion           A9 - LDA - Immediate
\par         8A - TXA                        AA - TAX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        8B - Future Expansion           AB - Future Expansion
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        8C - STY - Absolute             AC - LDY - Absolute
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        80 - STA - Absolute             AD - LDA - Absolute
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        8E - STX - Absolute             AE - LDX - Absolute
\par         8F - Future Expansion           AF - Future Expansion
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        90 - BCC                        B0 - BCS
\par         91 - STA - (Indirect),Y         B1 - LDA - (Indirect),Y
\par         92 - Future Expansion           B2 - Future Expansion
\par         93 - Future Expansion           B3 - Future Expansion
\par         94 - STY - Zero Page,X          B4 - LDY - Zero Page,X
\par         95 - STA - Zero Page,X          BS - LDA - Zero Page,X
\par         96 - STX - Zero Page,Y          B6 - LDX - Zero Page,Y
\par         97 - Future Expansion           B7 - Future Expansion
\par         98 - TYA                        B8 - CLV
\par         99 - STA - Absolute,Y           B9 - LDA - Absolute,Y
\par         9A - TXS                        BA - TSX
\par         9B - Future Expansion           BB - Future Expansion
\par         9C - Future Expansion           BC - LDY - Absolute,X
\par         90 - STA - Absolute,X           BD - LDA - Absolute,X
\par         9E - Future Expansion           BE - LDX - Absolute,Y
\par         9F - Future Expansion           BF - Future Expansion
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  258   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        C0 - Cpy - Immediate            E0 - CPX - Immediate
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        C1 - CMP - (Indirect,X)         E1 - SBC - (Indirect,X)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        C2 - Future Expansion           E2 - Future Expansion
\par         C3 - Future Expansion           E3 - Future Expansion
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        C4 - CPY - Zero Page            E4 - CPX - Zero Page
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        C5 - CMP - Zero Page            E5 - SBC - Zero Page
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        C6 - DEC - Zero Page            E6 - INC - Zero Page
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        C7 - Future Expansion           E7 - Future Expansion
\par         C8 - INY                        E8 - INX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        C9 - CMP - Immediate            E9 - SBC - Immediate
\par         CA - DEX                        EA - NOP
\par         CB - Future Expansion           EB - Future Expansion
\par         CC - CPY - Absolute             EC - CPX - Absolute
\par         CD - CMP - Absolute             ED - SBC - Absolute
\par         CE - DEC - Absolute             EE - INC - Absolute
\par         CF - Future Expansion           EF - Future Expansion
\par         D0 - BNE                        F0 - BEQ
\par         D1 - CMP   (Indirect@,Y         F1 - SBC - (Indirect),Y
\par         D2 - Future Expansion           F2 - Future Expansion
\par         D3 - Future Expansion           F3 - Future Expansion
\par         D4 - Future Expansion           F4 - Future Expansion
\par         D5 - CMP - Zero Page,X          F5 - SBC - Zero Page,X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        D6 - DEC - Zero Page,X          F6 - INC - Zero Page,X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        D7 - Future Expansion           F7 - Future Expansion
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        D8 - CLD                        F8 - SED
\par         D9 - CMP - Absolute,Y           F9 - SBC - Absolute,Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        DA - Future Expansion           FA - Future Expansion
\par         DB - Future Expansion           FB - Future Expansion
\par         DC - Future Expansion           FC - Future Expansion
\par         DD - CMP - Absolute,X           FD - SBC - Absolute,X
\par         DE - DEC - Absolute,X           FE - INC - Absolute,X
\par         DF - Future Expansion           FF - Future Expansion
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   259
\par \page 
\par 
\par 
\par   MEMORY MANAGEMENT ON THE
\par   COMMODORE 64
\par 
\par     The Commodore 64 has 64K bytes of RAM. It also has 20K bytes of ROM,
\par   containing BASIC, the operating system, and the standard character set.
\par   It also accesses input/output devices as a 4K chunk of memory. How is
\par   this all possible on a computer with a 16-bit address bus, that is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  normally only capable of addressing 64K?
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The secret is in the 6510 processor chip itself. On the chip is an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  input/output port. This port is used to control whether RAM or ROM or I/O
\par   will appear in certain portions of the system's memory. The port is also
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  used to control the Datassette(TM), so it is important to affect only the
\par   proper bits.
\par     The 6510 input/output port appears at location 1. The data direction
\par   register for this port appears at location 0. The port is controlled like
\par   any of the other input/output ports in the system... the data direction
\par   controls whether a given bit will be an input or an output, and the
\par   actual data transfer occurs through the port itself. The lines in the
\par   6510 control port are defined as follows:
\par 
\par 
\par   +---------+---+------------+--------------------------------------------+
\par   |  NAME   |BIT| DIRECTION  |                 DESCRIPTION                |
\par   +---------+---+------------+--------------------------------------------+
\par   |  LORAM  | 0 |   OUTPUT   | Control for RAM/ROM at $A000-$BFFF         |
\par   |  HIRAM  | 1 |   OUTPUT   | Control for RAM/ROM at $E000-$FFFF         |
\par   |  CHAREN | 2 |   OUTPUT   | Control for I/O/ROM at $D000-$DFFF         |
\par   |         | 3 |   OUTPUT   | Cassette write line                        |
\par   |         | 4 |   INPUT    | Cassette switch sense (0=play button down) |
\par   |         | 5 |   OUTPUT   | Cassette motor control (0=motor spins)     |
\par   +---------+---+------------+--------------------------------------------+
\par 
\par 
\par     The proper value for the data direction register is as follows:
\par 
\par                               BITS 5 4 3 2 1 0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                              ----------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                   1 0 1 1 1 1
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (where 1 is an output, and 0 is an input).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  260   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This gives a value of 47 decimal. The Commodore 64 automatically sets
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the data direction register to this value.
\par     The control lines, in general, perform the function given in their de-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  scriptions. However, a combination of control lines are occasionally used
\par   to get a particular memory configuration.
\par     LORAM (bit 0) can generally be thought of as a control line which banks
\par   the 8K byte BASIC ROM in and out of the microprocessor address space.
\par   Normally, this line is HIGH for BASIC operation. If this line is
\par   programmed LOW, the BASIC ROM will disappear from the memory map and be
\par   replaced by 8K bytes of RAM from $A000-$BFFF.
\par     HIRAM (bit 1) can generally be thought of as a control line which banks
\par   the 8K byte KERNAL ROM in and out of the microprocessor address space.
\par   Normally, this line is HIGH for BASIC operation. If this line is
\par   programmed LOW, the KERNAL ROM will disappear from the memory map and be
\par   replaced by 8K bytes of RAM from $E000-$FFFF.
\par     CHAREN (bit 2) is used only to bank the 4K byte character generator ROM
\par   in or out of the microprocessor address space. From the processor point
\par   of view, the character ROM occupies the same address space as the I/O
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  devices ($D000-$DFFF). When the CHAREN line is set to 1 (as is normal),
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the I/O devices appear in the microprocessor address space, and the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  character ROM is not accessable. When the CHAREN bit is cleared to 0, the
\par   character ROM appears in the processor address space, and the I/O devices
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  are not accessable. (The microprocessor only needs to access the
\par   character ROM when downloading the character set from ROM to RAM. Special
\par   care is needed for this... see the section on PROGRAMMABLE CHARACTERS in
\par   the GRAPHICS chapter). CHAREN can be overridden by other control lines in
\par   certain memory configurations. CHAREN will have no effect on any memory
\par   configuration without I/O devices. RAM will appear from $D000-$DFFF
\par   instead.
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE: In any memory map containing ROM, a WRITE (a POKE) to a ROM     |
\par   | location will store data in the RAM "under" the ROM. Writing to a ROM |
\par   | location stores data in the "hidden" RAM. For example, this allows a  |
\par   | hi-resolution screen to be kept underneath a ROM, and be changed      |
\par   | without having to bank the screen back into the processor address     |
\par   | space. Of course a READ of a ROM location will return the contents of |
\par   | the ROM, not the "hidden" RAM.                                        |
\par   +-----------------------------------------------------------------------+
\par 
\par 
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   261
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  COMMODORE 64 FUNDAMENTAL MEMORY MAP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                 +----------------------------+
\par                                  |       8K KERNAL ROM        |
\par                       E000-FFFF  |           OR RAM           |
\par                                  +----------------------------+
\par                       D000-DFFF  | 4K I/O OR RAM OR CHAR. ROM |
\par                                  +----------------------------+
\par                       C000-CFFF  |           4K RAM           |
\par                                  +----------------------------+
\par                                  |    8K BASIC ROM OR RAM     |
\par                       A000-BFFF  |       OR ROM PLUG-IN       |
\par                                  +----------------------------+
\par                                  |            8K RAM          |
\par                       8000-9FFF  |       OR ROM PLUG-IN       |
\par                                  +----------------------------+
\par                                  |                            |
\par                                  |                            |
\par                                  |          16 K RAM          |
\par                       4000-7FFF  |                            |
\par                                  +----------------------------+
\par                                  |                            |
\par                                  |                            |
\par                                  |          16 K RAM          |
\par                       0000-3FFF  |                            |
\par                                  +----------------------------+
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  I/O BREAKDOWN
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    D000-D3FF   VIC (Video Controller)                     1 K Bytes
\par     D400-D7FF   SID (Sound Synthesizer)                    1 K Bytes
\par     D800-DBFF   Color RAM                                  1 K Nybbles
\par     DC00-DCFF   CIA1 (Keyboard)                            256 Bytes
\par     DD00-DDFF   CIA2 (Serial Bus, User Port/RS-232)        256 Bytes
\par     DE00-DEFF   Open I/O slot #l (CP/M Enable)             256 Bytes
\par     DF00-DFFF   Open I/O slot #2 (Disk)                    256 Bytes
\par 
\par 
\par 
\par 
\par   262   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par     The two open I/O slots are for general purpose user I/O, special pur-
\par   pose I/O cartridges (such as IEEE), and have been tentatively designated
\par   for enabling the Z-80 cartridge (CP/M option) and for interfacing to a
\par   low-cost high-speed disk system.
\par     The system provides for "auto-start" of the program in a Commodore 64
\par   Expansion Cartridge. The cartridge program is started if the first nine
\par   bytes of the cartridge ROM starting at location 32768 ($8000) contain
\par   specific data. The first two bytes must hold the Cold Start vector to be
\par   used by the cartridge program. The next two bytes at 32770 ($8002) must
\par   be the Warm Start vector used by the cartridge program. The next three
\par   bytes must be the letters, CBM, with bit 7 set in each letter. The last
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  two bytes must be the digits "80" in PET ASCII.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  COMMODORE 64 MEMORY MAPS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The following table lists the various memory configurations available
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  on the COMMODORE 64, the states of the control lines which select each
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  memory map, and the intended use of each map.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The leftmost column of the table contains addresses in hexadecimal
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  notation. The columns aside it introduce all possible memory
\par   configurations. The default mode is on the left, and the absolutely most
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  rarely used Ultimax game console configuration is on the right. Each
\par   memory configuration column has one or more four-digit binary numbers as
\par   a title. The bits, from left to right, represent the state of the /LORAM,
\par   /HIRAM, /GAME and /EXROM lines, respectively. The bits whose state does
\par   not matter are marked with "X". For instance, when the Ultimax video game
\par   configuration is active (the /GAME line is shorted to ground, /EXROM kept
\par   high), the /LORAM and /HIRAM lines have no effect.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   263
\par \page 
\par 
\par 
\par            LHGE   LHGE   LHGE   LHGE   LHGE   LHGE   LHGE   LHGE   LHGE
\par 
\par            1111   101X   1000   011X   001X   1110   0100   1100   XX01
\par   10000  default                00X0                             Ultimax
\par   -------------------------------------------------------------------------
\par    F000
\par           Kernal  RAM    RAM   Kernal  RAM   Kernal Kernal Kernal ROMH(*
\par    E000
\par   -------------------------------------------------------------------------
\par    D000    IO/C   IO/C  IO/RAM  IO/C   RAM    IO/C   IO/C   IO/C   I/O
\par   -------------------------------------------------------------------------
\par    C000    RAM    RAM    RAM    RAM    RAM    RAM    RAM    RAM     -
\par   -------------------------------------------------------------------------
\par    B000
\par           BASIC   RAM    RAM    RAM    RAM   BASIC   ROMH   ROMH    -
\par    A000
\par   -------------------------------------------------------------------------
\par    9000
\par            RAM    RAM    RAM    RAM    RAM    ROML   RAM    ROML  ROML(*
\par    8000
\par   -------------------------------------------------------------------------
\par    7000
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   6000
\par            RAM    RAM    RAM    RAM    RAM    RAM    RAM    RAM     -
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   5000
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par    4000
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------------------------------------------------------------------------
\par    3000
\par 
\par    2000    RAM    RAM    RAM    RAM    RAM    RAM    RAM    RAM     -
\par 
\par    1000
\par   -------------------------------------------------------------------------
\par    0000    RAM    RAM    RAM    RAM    RAM    RAM    RAM    RAM    RAM
\par   -------------------------------------------------------------------------
\par 
\par      NOTE: (1)    (2)    (3)    (4)    (5)    (6)    (7)    (8)    (9)
\par 
\par     *) Internal memory does not respond to write accesses to these areas.
\par 
\par 
\par   264   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par     Legend: Kernal      E000-FFFF       Kernal ROM.
\par 
\par \tab     IO/C        D000-DFFF       I/O address space or Character
\par \tab \tab \tab \tab \tab generator ROM, selected by -CHAREN.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab \tab \tab If the CHAREN bit is clear,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab \tab \tab the character generator ROM is
\par \tab \tab \tab \tab \tab chosen. If it is set, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab \tab \tab I/O chips are accessible.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par \tab     IO/RAM      D000-DFFF       I/O address space or RAM,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab \tab \tab selected by -CHAREN.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab \tab \tab If the CHAREN bit is clear,
\par \tab \tab \tab \tab \tab the character generator ROM is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab \tab \tab chosen. If it is set, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab \tab \tab internal RAM is accessible.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab     I/O         D000-DFFF       I/O address space.
\par \tab \tab \tab \tab \tab The -CHAREN line has no effect.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab     BASIC       A000-BFFF       BASIC ROM.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab     ROMH        A000-BFFF or    External ROM with the -ROMH line
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab E000-FFFF       connected to its -CS line.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab     ROML        8000-9FFF       External ROM with the -ROML line
\par \tab \tab \tab \tab \tab connected to its -CS line.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab     RAM         various ranges  Commodore 64's internal RAM.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab     -           1000-7FFF and   Open address space.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab A000-CFFF       The Commodore 64's memory chips
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab \tab \tab do not detect any memory accesses
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab \tab \tab to this area except the VIC-II's
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\tab \tab \tab \tab \tab DMA and memory refreshes.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   265
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        (1)   This is the default BASIC memory map which provides
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              BASIC 2.0 and 38K contiguous bytes of user RAM.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par         (2)   This map provides 60K bytes of RAM and I/O devices.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              The user must write his own I/O driver routines.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par         (3)   The same as 2, but the character ROM is not
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              accessible by the CPU in this map.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par         (4)   This map is intended for use with softload languages
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              (including CP/M), providing 52K contiguous bytes of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              user RAM, I/O devices, and I/O driver routines.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        (5)   This map gives access to all 64K bytes of RAM. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              I/O devices must be banked back into the processor's
\par               address space for any I/O operation.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        (6)   This is the standard configuration for a BASIC system
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              with a BASIC expansion ROM. This map provides 32K
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              contiguous bytes of user RAM and up to 8K bytes of
\par               BASIC "enhancement".
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        (7)   This map provides 40K contiguous bytes of user RAM
\par               and up to 8K bytes of plug-in ROM for special ROM-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              based applications which don't require BASIC.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par         (8)   This map provides 32K contiguous bytes of user RAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              and up to 16K bytes of plug-in ROM for special
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              applications which don't require BASIC (word
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              processors, other languages, etc.).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par         (9)   This is the ULTIMAX video game memory map. Note that
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              the 2K byte "expansion RAM" for the ULTIMAX, if
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              required, is accessed out of the COMMODORE 64 and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              any RAM in the cartridge is ignored.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  266   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                             BASIC TO MACHINE LANGUAGE   267
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  THE KERNAL
\par 
\par 
\par     One of the problems facing programmers in the microcomputer field is
\par   the question of what to do when changes are made to the operating system
\par   of the computer by the company. Machine language programs which took much
\par   time to develop might no longer work, forcing major revisions in the
\par   program. To alleviate this problem, Commodore has developed a method of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  protecting software writers called the KERNAL.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Essentially, the KERNAL is a standardized JUMP TABLE to the input,
\par   output, and memory management routines in the operating system. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  locations of each routine in ROM may change as the system is upgraded.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  But the KERNAL jump table will always be changed to match. If your
\par   machine language routines only use the system ROM routines through the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  KERNAL, it will take much less work to modify them, should that need ever
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  arise.
\par     The KERNAL is the operating system of the Commodore 64 computer. All
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  input, output, and memory management is controlled by the KERNAL.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    To simplify the machine language programs you write, and to make sure
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  that future versions of the Commodore 64 operating system don't make your
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  machine language programs obsolete, the KERNAL contains a jump table for
\par   you to use. By taking advantage of the 39 input/output routines and other
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  utilities available to you from the table, not only do you save time, you
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  also make it easier to translate your programs from one Commodore
\par   computer to another.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The jump table is located on the last page of memory, in read-only
\par   memory (ROM).
\par     To use the KERNAL jump table, first you set up the parameters that the
\par   KERNAL routine needs to work. Then JSR (Jump to SubRoutine) to the proper
\par   place in the KERNAL jump table. After performing its function, the KERNAL
\par   transfers control back to your machine language program. Depending on
\par   which KERNAL routine you are using, certain registers may pass parameters
\par   back to your program. The particular registers for each KERNAL routine
\par   may be found in the individual descriptions of the KERNAL subroutines.
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  268   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    A good question at this point is why use the jump table at all? Why not
\par   just JSR directly to the KERNAL subroutine involved? The jump table is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  used so that if the KERNAL or BASIC is changed, your machine language
\par   programs will still work. In future operating systems the routines may
\par   have their memory locations moved around to a different position in the
\par   memory map... but the jump table will still work correctly!
\par 
\par 
\par   KERNAL POWER-UP ACTIVITIES
\par 
\par   1) On power-up, the KERNAL first resets the stack pointer, and clears
\par      decimal mode.
\par   2) The KERNAL then checks for the presence of an autostart ROM cartridge
\par      at location $8000 HEX (32768 decimal). If this is present, normal
\par      initialization is suspended, and control is transferred to the car-
\par      tridge code. If an autostart ROM is not present, normal system ini-
\par      tialization continues.
\par   3) Next, the KERNAL initializes all INPUT/OUTPUT devices. The serial bus
\par      is initialized. Both 6526 CIA chips are set to the proper values for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     keyboard scanning, and the 60-Hz timer is activated. The SID chip is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     cleared. The BASIC memory map is selected and the cassette motor is
\par      switched off.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  4) Next, the KERNAL performs a RAM test, setting the top and bottom of
\par      memory pointers. Also, page zero is initialized, and the tape buffer
\par      is set up.
\par        The RAM TEST routine is a nondestructive test starting at location
\par      $0300 and working upward. Once the test has found the first non-RAM
\par      location, the top of RAM has its pointer set. The bottom of memory is
\par      always set to $0800, and the screen setup is always set at $0400.
\par   5) Finally, the KERNAL performs these other activities. I/O vectors are
\par      set to default values. The indirect jump table in low memory is estab-
\par      lished. The screen is then cleared, and all screen editor variables
\par      reset. Then the indirect at $A000 is used to start BASIC.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   269
\par \page 
\par 
\par 
\par   HOW TO USE THE KERNAL
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     When writing machine language programs it is often convenient to use
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the routines which are already part of the operating system for input/
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  output, access to the system clock, memory management, and other similar
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  operations. It is an unnecessary duplication of effort to write these
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  routines over and over again, so easy access to the operating system
\par   helps speed machine language programming.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    As mentioned before, the KERNAL is a jump table. This is just a col-
\par   lection of JMP instructions to many operating system routines.
\par     To use a KERNAL routine you must first make all of the preparations
\par   that the routine demands. If one routine says that you must call another
\par   KERNAL routine first, then that routine must be called. If the routine
\par   expects you to put a number in the accumulator, then that number must be
\par   there. Otherwise your routines have little chance of working the way you
\par   expect them to work.
\par     After all preparations are made, you must call the routine by means of
\par   the JSR instruction. All KERNAL routines you can access are structured as
\par   SUBROUTINES, and must end with an RTS instruction. When the KERNAL
\par   routine has finished its task, control is returned to your program at the
\par   instruction after the JSR.
\par     Many of the KERNAL routines return error codes in the status word or
\par   the accumulator if you have problems in the routine. Good programming
\par   practice and the success of your machine language programs demand that
\par   you handle this properly. If you ignore an error return, the rest of your
\par   program might "bomb."
\par     That's all there is to do when you're using the KERNAL. Just these
\par   three simple steps:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Set up
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) Call the routine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) Error handling
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   270   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The following conventions are used in describing the KERNAL routines:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  - FUNCTION NAME: Name of the KERNAL routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   - CALL ADDRESS: This is the call address of the KERNAL routine, given in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    hexadecimal.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   - COMMUNICATION REGISTERS: Registers listed under this heading are used
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    to pass parameters to and from the KERNAL routines.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   - PREPARATORY ROUTINES: Certain KERNAL routines require that data be set
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    up before they can operate. The routines needed are listed here.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  - ERROR RETURNS: A return from a KERNAL routine with the CARRY set
\par     indicates that an error was encountered in processing. The accumulator
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    will contain the number of the error.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   - STACK REQUIREMENTS: This is the actual number of stack bytes used by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    the KERNAL routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   - REGISTERS AFFECTED: All registers used by the KERNAL routine are listed
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    here.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   - DESCRIPTION: A short tutorial on the function of the KERNAL routine is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    given here.
\par 
\par 
\par 
\par 
\par 
\par     The list of the KERNAL routines follows.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                             BASIC TO MACHINE LANGUAGE   271
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       USER CALLABLE KERNAL ROUTINES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +--------+-------------------+------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |        |      ADDRESS      |                                          |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  NAME  +---------+---------+                 FUNCTION                 |
\par   |        |   HEX   | DECIMAL |                                          |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +--------+---------+---------+------------------------------------------+
\par   | ACPTR  |  $FFA5  |  65445  |  Input byte from serial port             |
\par   | CHKIN  |  $FFC6  |  65478  |  Open channel for input                  |
\par   | CHKOUT |  $FFC9  |  65481  |  Open channel for output                 |
\par   | CHRIN  |  $FFCF  |  65487  |  Input character from channel            |
\par   | CHROUT |  $FFD2  |  65490  |  Output character to channel             |
\par   | CIOUT  |  $FFA8  |  65448  |  Output byte to serial port              |
\par   | CINT   |  $FF81  |  65409  |  Initialize screen editor                |
\par   | CLALL  |  $FFE7  |  65511  |  Close all channels and files            |
\par   | CLOSE  |  $FFC3  |  65475  |  Close a specified logical file          |
\par   | CLRCHN |  $FFCC  |  65484  |  Close input and output channels         |
\par   | GETIN  |  $FFE4  |  65508  |  Get character from keyboard queue       |
\par   |        |         |         |  (keyboard buffer)                       |
\par   | IOBASE |  $FFF3  |  65523  |  Returns base address of I/O devices     |
\par   | IOINIT |  $FF84  |  65412  |  Initialize input/output                 |
\par   | LISTEN |  $FFB1  |  65457  |  Command devices on the serial bus to    |
\par   |        |         |         |  LISTEN                                  |
\par   | LOAD   |  $FFD5  |  65493  |  Load RAM from a device                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | MEMBOT |  $FF9C  |  65436  |  Read/set the bottom of memory           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | MEMTOP |  $FF99  |  65433  |  Read/set the top of memory              |
\par   | OPEN   |  $FFC0  |  65472  |  Open a logical file                     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +--------+---------+---------+------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   272   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +--------+-------------------+------------------------------------------+
\par   |        |      ADDRESS      |                                          |
\par   |  NAME  +---------+---------+                 FUNCTION                 |
\par   |        |   HEX   | DECIMAL |                                          |
\par   +--------+---------+---------+------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | PLOT   |  $FFF0  |  65520  |  Read/set X,Y cursor position            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | RAMTAS |  $FF87  |  65415  |  Initialize RAM, allocate tape buffer,   |
\par   |        |         |         |  set screen $0400                        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | RDTIM  |  $FFDE  |  65502  |  Read real time clock                    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | READST |  $FFB7  |  65463  |  Read I/O status word                    |
\par   | RESTOR |  $FF8A  |  65418  |  Restore default I/O vectors             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | SAVE   |  $FFD8  |  65496  |  Save RAM to device                      |
\par   | SCNKEY |  $FF9F  |  65439  |  Scan keyboard                           |
\par   | SCREEN |  $FFED  |  65517  |  Return X,Y organization of screen       |
\par   | SECOND |  $FF93  |  65427  |  Send secondary address after LISTEN     |
\par   | SETLFS |  $FFBA  |  65466  |  Set logical, first, and second addresses|
\par   | SETMSG |  $FF90  |  65424  |  Control KERNAL messages                 |
\par   | SETNAM |  $FFBD  |  65469  |  Set file name                           |
\par   | SETTIM |  $FFDB  |  65499  |  Set real time clock                     |
\par   | SETTMO |  $FFA2  |  65442  |  Set timeout on serial bus               |
\par   | STOP   |  $FFE1  |  65505  |  Scan stop key                           |
\par   | TALK   |  $FFB4  |  65460  |  Command serial bus device to TALK       |
\par   | TKSA   |  $FF96  |  65430  |  Send secondary address after TALK       |
\par   | UDTIM  |  $FFEA  |  65514  |  Increment real time clock               |
\par   | UNLSN  |  $FFAE  |  65454  |  Command serial bus to UNLISTEN          |
\par   | UNTLK  |  $FFAB  |  65451  |  Command serial bus to UNTALK            |
\par   | VECTOR |  $FF8D  |  65421  |  Read/set vectored I/O                   |
\par   +--------+---------+---------+------------------------------------------+
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   273
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B-1. Function Name: ACPTR
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Get data from the serial bus
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FFA5 (hex) 65445 (decimal)
\par     Communication registers: A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: TALK, TKSA
\par     Error returns: See READST
\par     Stack requirements: 13
\par     Registers affected: A, X
\par 
\par 
\par 
\par     Description: This is the routine to use when you want to get informa-
\par   tion from a device on the serial bus, like a disk. This routine gets a
\par   byte of data off the serial bus using full handshaking. The data is
\par   returned in the accumulator. To prepare for this routine the TALK routine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  must be called first to command the device on the serial bus to send data
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  through the bus. If the input device needs a secondary command, it must
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  be sent by using the TKSA KERNAL routine before calling this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Errors are returned in the status word. The READST routine is used to
\par   read the status word.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    0) Command a device on the serial bus to prepare to send data to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       the Commodore 64. (Use the TALK and TKSA KERNAL routines.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Call this routine (using JSR).
\par     2) Store or otherwise use the data.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    ;GET A BYTE FROM THE BUS
\par     JSR ACPTR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    STA DATA
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   274   BASIC TO MACHINE LANGUAGE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-2. Function Name: CHKIN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Open a channel for input
\par     Call address: $FFC6 (hex) 65478 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: (OPEN)
\par     Error returns:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: None
\par     Registers affected: A, X
\par 
\par 
\par     Description: Any logical file that has already been opened by the
\par   KERNAL OPEN routine can be defined as an input channel by this routine.
\par   Naturally, the device on the channel must be an input device. Otherwise
\par   an error will occur, and the routine will abort.
\par     If you are getting data from anywhere other than the keyboard, this
\par   routine must be called before using either the CHRIN or the GETIN KERNAL
\par   routines for data input. If you want to use the input from the keyboard,
\par   and no other input channels are opened, then the calls to this routine,
\par   and to the OPEN routine are not needed.
\par     When this routine is used with a device on the serial bus, it auto-
\par   matically sends the talk address (and the secondary address if one was
\par   specified by the OPEN routine) over the bus.
\par 
\par   How to Use:
\par 
\par     0) OPEN the logical file (if necessary; see description above).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Load the X register with number of the logical file to be used.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) Call this routine (using a JSR command).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Possible errors are:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    #3: File not open
\par     #5: Device not present
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    #6: File not an input file
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    ;PREPARE FOR INPUT FROM LOGICAL FILE 2
\par     LDX #2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR CHKIN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                             BASIC TO MACHINE LANGUAGE   275
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B-3. Function Name: CHKOUT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Purpose: Open a channel for output
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FFC9 (hex) 65481 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: X
\par     Preparatory routines: (OPEN)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: 0,3,5,7 (See READST)
\par     Stack requirements: 4+
\par     Registers affected: A, X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: Any logical file number that has been created by the
\par   KERNAL routine OPEN can be defined as an output channel. Of course, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  device you intend opening a channel to must be an output device.
\par   Otherwise an error will occur, and the routine will be aborted.
\par     This routine must be called before any data is sent to any output
\par   device unless you want to use the Commodore 64 screen as your output
\par   device. If screen output is desired, and there are no other output chan-
\par   nels already defined, then calls to this routine, and to the OPEN routine
\par   are not needed.
\par     When used to open a channel to a device on the serial bus, this routine
\par   will automatically send the LISTEN address specified by the OPEN routine
\par   (and a secondary address if there was one).
\par 
\par   How to Use:
\par   +-----------------------------------------------------------------------+
\par   | REMEMBER: this routine is NOT NEEDED to send data to the screen.      |
\par   +-----------------------------------------------------------------------+
\par     0) Use the KERNAL OPEN routine to specify a logical file number, a
\par        LISTEN address, and a secondary address (if needed).
\par     1) Load the X register with the logical file number used in the open
\par        statement.
\par     2) Call this routine (by using the JSR instruction).
\par 
\par   EXAMPLE:
\par 
\par     LDX #3        ;DEFINE LOGICAL FILE 3 AS AN OUTPUT CHANNEL
\par     JSR CHKOUT
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Possible errors are:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    #3: File not open
\par     #5: Device not present
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    #7: Not an output file
\par 
\par   276   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par   B-4. Function Name: CHRIN
\par 
\par     Purpose: Get a character from the input channel
\par     Call address: $FFCF (hex) 65487 (decimal)
\par     Communication registers: A
\par     Preparatory routines: (OPEN, CHKIN)
\par     Error returns: 0 (See READST)
\par     Stack requirements: 7+
\par     Registers affected: A, X
\par 
\par     Description: This routine gets a byte of data from a channel already
\par   set up as the input channel by the KERNAL routine CHKIN. If the CHKIN has
\par   NOT been used to define another input channel, then all your data is
\par   expected from the keyboard. The data byte is returned in the accumulator.
\par   The channel remains open after the call.
\par     Input from the keyboard is handled in a special way. First, the cursor
\par   is turned on, and blinks until a carriage return is typed on the
\par   keyboard. All characters on the line (up to 88 characters) are stored in
\par   the BASIC input buffer. These characters can be retrieved one at a time
\par   by calling this routine once for each character. When the carriage return
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is retrieved, the entire line has been processed. The next time this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  routine is called, the whole process begins again, i.e., by flashing the
\par   cursor.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  How to Use:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FROM THE KEYBOARD
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     1) Retrieve a byte of data by calling this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) Store the data byte.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) Check if it is the last data byte (is it a CR?)
\par     4) If not, go to step 1.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       LDY $#00      ;PREPARE THE Y REGISTER TO STORE THE DATA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   RD  JSR CHRIN
\par        STA DATA,Y    ;STORE THE YTH DATA BYTE IN THE YTH
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     ;LOCATION IN THE DATA AREA.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       INY
\par        CMP #CR       ;IS IT A CARRIAGE RETURN?
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       BNE RD        ;NO, GET ANOTHER DATA BYTE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                             BASIC TO MACHINE LANGUAGE   277
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR CHRIN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    STA DATA
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FROM OTHER DEVICES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     0) Use the KERNAL OPEN and CHKIN routines.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Call this routine (using a JSR instruction).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) Store the data.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     JSR CHRIN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    STA DATA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B-5. Function Name: CHROUT
\par 
\par     Purpose: Output a character
\par     Call address: $FFD2 (hex) 65490 (decimal)
\par     Communication registers: A
\par     Preparatory routines: (CHKOUT,OPEN)
\par     Error returns: 0 (See READST)
\par     Stack requirements: 8+
\par     Registers affected: A
\par 
\par     Description: This routine outputs a character to an already opened
\par   channel. Use the KERNAL OPEN and CHKOUT routines to set up the output
\par   channel before calling this routine, If this call is omitted, data is
\par   sent to the default output device (number 3, the screen). The data byte
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to be output is loaded into the accumulator, and this routine is called.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The data is then sent to the specified output device. The channel is left
\par   open after the call.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTE: Care must be taken when using this routine to send data to a    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | specific serial device since data will be sent to all open output     |
\par   | channels on the bus. Unless this is desired, all open output channels |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | on the serial bus other than the intended destination channel must be |
\par   | closed by a call to the KERNAL CLRCHN routine.                        |
\par   +-----------------------------------------------------------------------+
\par 
\par   278   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par   How to Use:
\par 
\par     0) Use the CHKOUT KERNAL routine if needed, (see description above).
\par     1) Load the data to be output into the accumulator.
\par     2) Call this routine.
\par 
\par   EXAMPLE:
\par 
\par     ;DUPLICATE THE BASIC INSTRUCTION CMD 4,"A";
\par     LDX #4          ;LOGICAL FILE #4
\par     JSR CHKOUT      ;OPEN CHANNEL OUT
\par     LDA #'A
\par     JSR CHROUT      ;SEND CHARACTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-6. Function Name: CIOUT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Transmit a byte over the serial bus
\par     Call address: $FFA8 (hex) 65448 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A
\par     Preparatory routines: LISTEN, [SECOND]
\par     Error returns: See READST
\par     Stack requirements: 5
\par     Registers affected: None
\par 
\par     Description: This routine is used to send information to devices on the
\par   serial bus. A call to this routine will put a data byte onto the serial
\par   bus using full serial handshaking. Before this routine is called, the
\par   LISTEN KERNAL routine must be used to command a device on the serial bus
\par   to get ready to receive data. (If a device needs a secondary address, it
\par   must also be sent by using the SECOND KERNAL routine.) The accumulator is
\par   loaded with a byte to handshake as data on the serial bus. A device must
\par   be listening or the status word will return a timeout. This routine
\par   always buffers one character. (The routine holds the previous character
\par   to be sent back.) So when a call to the KERNAL UNLSN routine is made to
\par   end the data transmission, the buffered character is sent with an End Or
\par   Identify (EOI) set. Then the UNLSN command is sent to the device.
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   279
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     0) Use the LISTEN KERNAL routine (and the SECOND routine if needed).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Load the accumulator with a byte of data.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) Call this routine to send the data byte.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDA #'X       ;SEND AN X TO THE SERIAL BUS
\par     JSR CIOUT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-7. Function Name: CINT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Initialize screen editor & 6567 video chip
\par     Call address: $FF81 (hex) 65409 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 4
\par     Registers affected: A, X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine sets up the 6567 video controller chip in the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Commodore 64 for normal operation. The KERNAL screen editor is also
\par   initialized. This routine should be called by a Commodore 64 program
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cartridge.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Call this routine.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     JSR CINT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JMP RUN       ;BEGIN EXECUTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  280   BASIC TO MACHINE LANGUAGE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-8. Function Name: CLALL
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Close all files
\par     Call address: $FFE7 (hex) 65511 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 11
\par     Registers affected: A, X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine closes all open files. When this routine is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  called, the pointers into the open file table are reset, closing all
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  files. Also, the CLRCHN routine is automatically called to reset the I/O
\par   channels.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  How to Use:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Call this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR CLALL   ;CLOSE ALL FILES AND SELECT DEFAULT I/O CHANNELS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JMP RUN     ;BEGIN EXECUTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B-9. Function Name: CLOSE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Purpose: Close a logical file
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FFC3 (hex) 65475 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A
\par     Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: 0,240 (See READST)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 2+
\par     Registers affected: A, X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine is used to close a logical file after all I/O
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  operations have been completed on that file. This routine is called after
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the accumulator is loaded with the logical file number to be closed (the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  same number used when the file was opened using the OPEN routine).
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   281
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  How to Use:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Load the accumulator with the number of the logical file to be
\par        closed.
\par     2) Call this routine.
\par 
\par   EXAMPLE:
\par 
\par     ;CLOSE 15
\par     LDA #15
\par     JSR CLOSE
\par 
\par   B-10. Function Name: CLRCHN
\par 
\par     Purpose: Clear I/O channels
\par     Call address: $FFCC (hex) 65484 (decimal)
\par     Communication registers: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns:
\par     Stack requirements: 9
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected: A, X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Description: This routine is called to clear all open channels and re-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  store the I/O channels to their original default values. It is usually
\par   called after opening other I/O channels (like a tape or disk drive) and
\par   using them for input/output operations. The default input device is 0
\par   (keyboard). The default output device is 3 (the Commodore 64 screen).
\par     If one of the channels to be closed is to the serial port, an UNTALK
\par   signal is sent first to clear the input channel or an UNLISTEN is sent to
\par   clear the output channel. By not calling this routine (and leaving lis-
\par   tener(s) active on the serial bus) several devices can receive the same
\par   data from the Commodore 64 at the same time. One way to take advantage
\par   of this would be to command the printer to TALK and the disk to LISTEN.
\par   This would allow direct printing of a disk file.
\par     This routine is automatically called when the KERNAL CLALL routine is
\par   executed.
\par 
\par   How to Use:
\par     1) Call this routine using the JSR instruction.
\par 
\par   EXAMPLE:
\par     JSR CLRCHN
\par 
\par   282   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B-11. Function Name: GETIN
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Get a character
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FFE4 (hex) 65508 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A
\par     Preparatory routines: CHKIN, OPEN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: See READST
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 7+
\par     Registers affected: A (X, Y)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: If the channel is the keyboard, this subroutine removes
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  one character from the keyboard queue and returns it as an ASCII value in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the accumulator. If the queue is empty, the value returned in the
\par   accumulator will be zero. Characters are put into the queue automatically
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  by an interrupt driven keyboard scan routine which calls the SCNKEY
\par   routine. The keyboard buffer can hold up to ten characters. After the
\par   buffer is filled, additional characters are ignored until at least one
\par   character has been removed from the queue. If the channel is RS-232, then
\par   only the A register is used and a single character is returned. See
\par   READST to check validity. If the channel is serial, cassette, or screen,
\par   call BASIN routine.
\par 
\par 
\par   How to Use:
\par 
\par     1) Call this routine using a JSR instruction.
\par     2) Check for a zero in the accumulator (empty buffer).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) Process the data.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par          ;WAIT FOR A CHARACTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    WAIT JSR GETIN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         CMP #0
\par          BEQ WAIT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   283
\par \page 
\par 
\par 
\par   B-12. Function Name: IOBASE
\par 
\par     Purpose: Define I/O memory page
\par     Call address: $FFF3 (hex) 65523 (decimal)
\par     Communication registers: X, Y
\par     Preparatory routines: None
\par     Error returns:
\par     Stack requirements: 2
\par     Registers affected: X, Y
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine sets the X and Y registers to the address of
\par   the memory section where the memory mapped 110 devices are located. This
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  address can then be used with an offset to access the memory mapped I/O
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  devices in the Commodore 64. The offset is the number of locations from
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the beginning of the page on which the I/O register you want is located.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The X register contains the low order address byte, while the Y register
\par   contains the high order address byte.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This routine exists to provide compatibility between the Commodore 64,
\par   VIC-20, and future models of the Commodore 64. If the J/0 locations for
\par   a machine language program are set by a call to this routine, they should
\par   still remain compatible with future versions of the Commodore 64, the
\par   KERNAL and BASIC.
\par 
\par 
\par   How to Use:
\par 
\par     1) Call this routine by using the JSR instruction.
\par     2) Store the X and the Y registers in consecutive locations.
\par     3) Load the Y register with the offset.
\par     4) Access that I/O location.
\par 
\par   EXAMPLE:
\par 
\par     ;SET THE DATA DIRECTION REGISTER OF THE USER PORT TO 0 (INPUT)
\par     JSR IOBASE
\par     STX POINT       ;SET BASE REGISTERS
\par     STY POINT+1
\par     LDY #2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDA #0          ;OFFSET FOR DDR OF THE USER PORT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    STA (POINT),Y   ;SET DDR TO 0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   284   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B-13. Function Name: IOINIT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Purpose: Initialize I/O devices
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call Address: $FF84 (hex) 65412 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: None
\par     Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected: A, X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Description: This routine initializes all input/output devices and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  routines. It is normally called as part of the initialization procedure
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of a Commodore 64 program cartridge.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR IOINIT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B-14. Function Name: LISTEN
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Command a device on the serial bus to listen
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call Address: $FFB1 (hex) 65457 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: None
\par     Error returns: See READST
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: None
\par     Registers affected: A
\par 
\par     Description: This routine will command a device on the serial bus to
\par   receive data. The accumulator must be loaded with a device number between
\par   0 and 31 before calling the routine. LISTEN will OR the number bit by bit
\par   to convert to a listen address, then transmits this data as a command on
\par   the serial bus. The specified device will then go into listen mode, and
\par   be ready to accept information.
\par 
\par   How to Use:
\par     1) Load the accumulator with the number of the device to command
\par        to LISTEN.
\par     2) Call this routine using the JSR instruction.
\par 
\par   EXAMPLE:
\par     ;COMMAND DEVICE #8 TO LISTEN
\par     LDA #8
\par     JSR LISTEN
\par                                             BASIC TO MACHINE LANGUAGE   285
\par \page 
\par 
\par 
\par   B-15. Function Name: LOAD
\par 
\par     Purpose: Load RAM from device
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FFD5 (hex) 65493 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A, X, Y
\par     Preparatory routines: SETLFS, SETNAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: 0,4,5,8,9, READST
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: None
\par     Registers affected: A, X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine LOADs data bytes from any input device di-
\par   rectly into the memory of the Commodore 64. It can also be used for a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  verify operation, comparing data from a device with the data already in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  memory, while leaving the data stored in RAM unchanged.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The accumulator (.A) must be set to 0 for a LOAD operation, or 1 for a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  verify, If the input device is OPENed with a secondary address (SA) of 0
\par   the header information from the device is ignored. In this case, the X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and Y registers must contain the starting address for the load. If the
\par   device is addressed with a secondary address of 1, then the data is
\par   loaded into memory starting at the location specified by the header. This
\par   routine returns the address of the highest RAM location loaded.
\par     Before this routine can be called, the KERNAL SETLFS, and SETNAM
\par   routines must be called.
\par 
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE: You can NOT LOAD from the keyboard (0), RS-232 (2), or the      |
\par   | screen (3).                                                           |
\par   +-----------------------------------------------------------------------+
\par 
\par 
\par   How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    0) Call the SETLFS, and SETNAM routines. If a relocated load is de-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       sired, use the SETLFS routine to send a secondary address of 0.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Set the A register to 0 for load, 1 for verify.
\par     2) If a relocated load is desired, the X and Y registers must be set
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       to the start address for the load.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) Call the routine using the JSR instruction.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  286   BASIC TO MACHINE LANGUAGE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          ;LOAD   A FILE FROM TAPE
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           LDA #DEVICE1        ;SET DEVICE NUMBER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           LDX #FILENO         ;SET LOGICAL FILE NUMBER
\par            LDY CMD1            ;SET SECONDARY ADDRESS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           JSR SETLFS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           LDA #NAME1-NAME     ;LOAD A WITH NUMBER OF
\par                                ;CHARACTERS IN FILE NAME
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           LDX #<NAME          ;LOAD X AND Y WITH ADDRESS OF
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           LDY #>NAME          ;FILE NAME
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           JSR SETNAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           LDA #0              ;SET FLAG FOR A LOAD
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           LDX #$FF            ;ALTERNATE START
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           LDY #$FF
\par            JSR LOAD
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           STX VARTAB          ;END OF LOAD
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           STY VARTA B+1
\par            JMP START
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   NAME    .BYT 'FILE NAME'
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   NAME1                       ;
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B-16. Function Name: MEMBOT
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Set bottom of memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FF9C (hex) 65436 (decimal)
\par     Communication registers: X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected: X, Y
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine is used to set the bottom of the memory. If
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the accumulator carry bit is set when this routine is called, a pointer
\par   to the lowest byte of RAM is returned in the X and Y registers. On the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  unexpanded Commodore 64 the initial value of this pointer is $0800
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (2048 in decimal). If the accumulator carry bit is clear (-O) when this
\par   routine is called, the values of the X and Y registers are transferred to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the low and high bytes, respectively, of the pointer to the beginning of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RAM.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   287
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  How to Use:
\par   TO READ THE BOTTOM OF RAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Set the carry.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) Call this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TO SET THE BOTTOM OF MEMORY
\par     1) Clear the carry.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) Call this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    ;MOVE BOTTOM OF MEMORY UP 1 PAGE
\par     SEC         ;READ MEMORY BOTTOM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR MEMBOT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    INY
\par     CLC         ;SET MEMORY BOTTOM TO NEW VALUE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR MEMBOT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-17. Function Name: MEMTOP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Set the top of RAM
\par     Call address: $FF99 (hex) 65433 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: None
\par     Error returns: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected: X, Y
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine is used to set the top of RAM. When this
\par   routine is called with the carry bit of the accumulator set, the pointer
\par   to the top of RAM will be loaded into the X and Y registers. When this
\par   routine is called with the accumulator carry bit clear, the contents of
\par   the X and Y registers are loaded in the top of memory pointer, changing
\par   the top of memory.
\par 
\par   EXAMPLE:
\par     ;DEALLOCATE THE RS-232 BUFFER
\par     SEC
\par     JSR MEMTOP   ;READ TOP OF MEMORY
\par     DEX
\par     CLC
\par     JSR MEMTOP   ;SET NEW TOP OF MEMORY
\par 
\par   288   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par   B-18. Function Name: OPEN
\par 
\par 
\par     Purpose: Open a logical file
\par     Call address: $FFC0 (hex) 65472 (decimal)
\par     Communication registers: None
\par     Preparatory routines: SETLFS, SETNAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: 1,2,4,5,6,240, READST
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected: A, X, Y
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine is used to OPEN a logical file. Once the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  logical file is set up, it can be used for input/output operations. Most
\par   of the I/O KERNAL routines call on this routine to create the logical
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  files to operate on. No arguments need to be set up to use this routine,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  but both the SETLFS and SETNAM KERNAL routines must be called before
\par   using this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    0) Use the SETLFS routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Use the SETNAM routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) Call this routine.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     This is an implementation of the BASIC statement: OPEN 15,8,15,"I/O"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par           LDA #NAME2-NAME    ;LENGTH OF FILE NAME FOR SETLFS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          LDY #>NAME         ;ADDRESS OF FILE NAME
\par           LDX #<NAME
\par           JSR SETNAM
\par           LDA #15
\par           LDX #8
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          LDY #15
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          JSR SETLFS
\par           JSR OPEN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    NAME  .BYT 'I/O'
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    NAME2
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   289
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B-19. Function Name: PLOT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Purpose: Set cursor location
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FFF0 (hex) 65520 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A, X, Y
\par     Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 2
\par     Registers affected: A, X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: A call to this routine with the accumulator carry flag
\par   set loads the current position of the cursor on the screen (in X,Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  coordinates) into the Y and X registers. Y is the column number of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cursor location (6-39), and X is the row number of the location of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cursor (0-24). A call with the carry bit clear moves the cursor to X,Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  as determined by the Y and X registers.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   READING CURSOR LOCATION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Set the carry flag.
\par     2) Call this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) Get the X and Y position from the Y and X registers, respectively.
\par 
\par 
\par   SETTING CURSOR LOCATION
\par 
\par     1) Clear carry flag.
\par     2) Set the Y and X registers to the desired cursor location.
\par     3) Call this routine.
\par 
\par 
\par   EXAMPLE:
\par 
\par     ;MOVE THE CURSOR TO ROW 10, COLUMN 5 (5,10)
\par     LDX #10
\par     LDY #5
\par     CLC
\par     JSR PLOT
\par 
\par 
\par   290   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B.20. Function Name: RAMTAS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Purpose: Perform RAM test
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FF87 (hex) 65415 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A, X, Y
\par     Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 2
\par     Registers affected: A, X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine is used to test RAM and set the top and
\par   bottom of memory pointers accordingly. It also clears locations $0000 to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  $0101 and $0200 to $03FF. It also allocates the cassette buffer, and sets
\par   the screen base to $0400. Normally, this routine is called as part of the
\par   initialization process of a Commodore 64 program cartridge.
\par 
\par   EXAMPLE:
\par     JSR RAMTAS
\par 
\par   B-21. Function Name: RDTIM
\par 
\par     Purpose: Read system clock
\par     Call address: $FFDE (hex) 65502 (decimal)
\par     Communication registers: A, X, Y
\par     Preparatory routines: None
\par     Error returns: None
\par     Stack requirements: 2
\par     Registers affected: A, X, Y
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine is used to read the system clock. The clock's
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  resolution is a 60th of a second. Three bytes are returned by the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  routine. The accumulator contains the most significant byte, the X index
\par   register contains the next most significant byte, and the Y index
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  register contains the least significant byte.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR RDTIM
\par     STY TIME
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    STX TIME+1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    STA TIME+2
\par     ...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    TIME *=*+3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   291
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-22. Function Name: READST
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Read status word
\par     Call address: $FFB7 (hex) 65463 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: None
\par     Error returns: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected: A
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine returns the current status of the I/O devices
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in the accumulator. The routine is usually called after new communication
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to an I/O device. The routine gives you information about device status,
\par   or errors that have occurred during the I/O operation.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The bits returned in the accumulator contain the following information:
\par   (see table below)
\par 
\par   +---------+------------+---------------+------------+-------------------+
\par   |  ST Bit | ST Numeric |    Cassette   |   Serial   |    Tape Verify    |
\par   | Position|    Value   |      Read     |  Bus R/W   |      + Load       |
\par   +---------+------------+---------------+------------+-------------------+
\par   |    0    |      1     |               |  time out  |                   |
\par   |         |            |               |  write     |                   |
\par   +---------+------------+---------------+------------+-------------------+
\par   |    1    |      2     |               |  time out  |                   |
\par   |         |            |               |    read    |                   |
\par   +---------+------------+---------------+------------+-------------------+
\par   |    2    |      4     |  short block  |            |    short block    |
\par   +---------+------------+---------------+------------+-------------------+
\par   |    3    |      8     |   long block  |            |    long block     |
\par   +---------+------------+---------------+------------+-------------------+
\par   |    4    |     16     | unrecoverable |            |   any mismatch    |
\par   |         |            |   read error  |            |                   |
\par   +---------+------------+---------------+------------+-------------------+
\par   |    5    |     32     |    checksum   |            |     checksum      |
\par   |         |            |     error     |            |       error       |
\par   +---------+------------+---------------+------------+-------------------+
\par   |    6    |     64     |  end of file  |  EOI line  |                   |
\par   +---------+------------+---------------+------------+-------------------+
\par   |    7    |   -128     |  end of tape  | device not |    end of tape    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         |            |               |   present  |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+------------+---------------+------------+-------------------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  292   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Call this routine.
\par     2) Decode the information in the A register as it refers to your pro-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       gram.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    ;CHECK FOR END OF FILE DURING READ
\par     JSR READST
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    AND #64                       ;CHECK EOF BIT (EOF=END OF FILE)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    BNE EOF                       ;BRANCH ON EOF
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B-23. Function Name: RESTOR
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Restore default system and interrupt vectors
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FF8A (hex) 65418 (decimal)
\par     Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected: A, X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine restores the default values of all system
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  vectors used in KERNAL and BASIC routines and interrupts. (See the Memory
\par   Map for the default vector contents). The KERNAL VECTOR routine is used
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to read and alter individual system vectors.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Call this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR RESTOR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-24. Function Name: SAVE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Save memory to a device
\par     Call address: $FFD8 (hex) 65496 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A, X, Y
\par     Preparatory routines: SETLFS, SETNAM
\par     Error returns: 5,8,9, READST
\par     Stack requirements: None
\par     Registers affected: A, X, Y
\par 
\par                                             BASIC TO MACHINE LANGUAGE   293
\par \page 
\par 
\par 
\par     Description: This routine saves a section of memory. Memory is saved
\par   from an indirect address on page 0 specified by the accumulator to the
\par   address stored in the X and Y registers. It is then sent to a logical
\par   file on an input/output device. The SETLFS and SETNAM routines must be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  used before calling this routine. However, a file name is not required to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SAVE to device 1 (the Datassette(TM) recorder). Any attempt to save to
\par   other devices without using a file name results in an error.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTE: Device 0 (the keyboard), device 2 (RS-232), and device 3 (the   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | screen) cannot be SAVEd to. If the attempt is made, an error occurs,  |
\par   | and the SAVE is stopped.                                              |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    0) Use the SETLFS routine and the SETNAM routine (unless a SAVE with no
\par        file name is desired on "a save to the tape recorder"),
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Load two consecutive locations on page 0 with a pointer to the start
\par        of your save (in standard 6502 low byte first, high byte next
\par        format).
\par     2) Load the accumulator with the single byte page zero offset to the
\par        pointer.
\par     3) Load the X and Y registers with the low byte and high byte re-
\par        spectively of the location of the end of the save.
\par     4) Call this routine.
\par 
\par   EXAMPLE:
\par 
\par     LDA #1              ;DEVICE = 1:CASSETTE
\par     JSR SETLFS
\par     LDA #0              ;NO FILE NAME
\par     JSR SETNAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDA PROG            ;LOAD START ADDRESS OF SAVE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    STA TXTTAB          ;(LOW BYTE)
\par     LDA PROG+1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    STA TXTTA B+1       ;(HIGH BYTE)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDX VARTAB          ;LOAD X WITH LOW BYTE OF END OF SAVE
\par     LDY VARTAB+1        ;LOAD Y WITH HIGH BYTE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDA #<TXTTAB        ;LOAD ACCUMULATOR WITH PAGE 0 OFFSET
\par     JSR SAVE
\par 
\par 
\par   294   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par   B-25. Function Name: SCNKEY
\par 
\par     Purpose: Scan the keyboard
\par     Call address: $FF9F (hex) 65439 (decimal)
\par     Communication registers: None
\par     Preparatory routines: IOINIT
\par     Error returns: None
\par     Stack requirements: 5
\par     Registers affected: A, X, Y
\par 
\par     Description: This routine scans the Commodore 64 keyboard and checks
\par   for pressed keys. It is the same routine called by the interrupt handler.
\par   If a key is down, its ASCII value is placed in the keyboard queue. This
\par   routine is called only if the normal IRQ interrupt is bypassed.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   1) Call this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    GET  JSR SCNKEY      ;SCAN KEYBOARD
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         JSR GETIN       ;GET CHARACTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         CMP #0          ;IS IT NULL?
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         BEQ GET         ;YES... SCAN AGAIN
\par          JSR CHROUT      ;PRINT IT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-26. Function Name: SCREEN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Return screen format
\par     Call address: $FFED (hex) 65517 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: X, Y
\par     Preparatory routines: None
\par     Stack requirements: 2
\par     Registers affected: X, Y
\par 
\par     Description: This routine returns the format of the screen, e.g., 40
\par   columns in X and 25 lines in Y. The routine can be used to determine what
\par   machine a program is running on. This function has been implemented on
\par   the Commodore 64 to help upward compatibility of your programs.
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   295
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     1) Call this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR SCREEN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    STX MAXCOL
\par     STY MAXROW
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-27. Function Name: SECOND
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Send secondary address for LISTEN
\par     Call address: $FF93 (hex) 65427 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: LISTEN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: See READST
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 8
\par     Registers affected: A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine is used to send a secondary address to an
\par   I/O device after a call to the LISTEN routine is made, and the device is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  commanded to LISTEN. The routine canNOT be used to send a secondary
\par   address after a call to the TALK routine.
\par     A secondary address is usually used to give setup information to a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  device before I/O operations begin.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When a secondary address is to be sent to a device on the serial bus,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the address must first be ORed with $60.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) load the accumulator with the secondary address to be sent.
\par     2) Call this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    ;ADDRESS DEVICE #8 WITH COMMAND (SECONDARY ADDRESS) #15
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDA #8
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR LISTEN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDA #15
\par     JSR SECOND
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  296   BASIC TO MACHINE LANGUAGE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-28. Function Name: SETLFS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Set up a logical file
\par     Call address: $FFBA (hex) 65466 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A, X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine sets the logical file number, device address,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and secondary address (command number) for other KERNAL routines.
\par     The logical file number is used by the system as a key to the file
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  table created by the OPEN file routine. Device addresses can range from 0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to 31. The following codes are used by the Commodore 64 to stand for the
\par   CBM devices listed below:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                   ADDRESS          DEVICE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     0            Keyboard
\par                      1            Datassette(TM)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     2            RS-232C device
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     3            CRT display
\par                      4            Serial bus printer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     8            CBM serial bus disk drive
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Device numbers 4 or greater automatically refer to devices on the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  serial bus.
\par     A command to the device is sent as a secondary address on the serial
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  bus after the device number is sent during the serial attention
\par   handshaking sequence. If no secondary address is to be sent, the Y index
\par   register should be set to 255.
\par 
\par   How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Load the accumulator with the logical file number.
\par     2) Load the X index register with the device number.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) Load the Y index register with the command.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   297
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    FOR LOGICAL FILE 32, DEVICE #4, AND NO COMMAND:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDA #32
\par     LDX #4
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDY #255
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR SETLFS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-29. Function Name: SETMSG
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Control system message output
\par     Call address: $FF90 (hex) 65424 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: None
\par     Error returns: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected: A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine controls the printing of error and control
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  messages by the KERNAL. Either print error messages or print control mes-
\par   sages can be selected by setting the accumulator when the routine is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  called. FILE NOT FOUND is an example of an error message. PRESS PLAY ON
\par   CASSETTE is an example of a control message.
\par     Bits 6 and 7 of this value determine where the message will come from.
\par   If bit 7 is 1, one of the error messages from the KERNAL is printed. If
\par   bit 6 is set, control messages are printed.
\par 
\par   How to Use:
\par 
\par     1) Set accumulator to desired value.
\par     2) Call this routine.
\par 
\par   EXAMPLE:
\par 
\par     LDA #$40
\par     JSR SETMSG          ;TURN ON CONTROL MESSAGES
\par     LDA #$80
\par     JSR SETMSG          ;TURN ON ERROR MESSAGES
\par     LDA #0
\par     JSR SETMSG          ;TURN OFF ALL KERNAL MESSAGES
\par 
\par 
\par   298   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par   B-30. Function Name: SETNAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Set file name
\par     Call address: $FFBD (hex) 65469 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A, X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine is used to set up the file name for the OPEN,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SAVE, or LOAD routines. The accumulator must be loaded with the length of
\par   the file name. The X and Y registers must be loaded with the address of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the file name, in standard 6502 low-byte/high-byte format. The address
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  can be any valid memory address in the system where a string of
\par   characters for the file name is stored. If no file name is desired, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  accumulator must be set to 0, representing a zero file length. The X and
\par   Y registers can be set to any memory address in that case.
\par 
\par   How to Use:
\par 
\par     1) Load the accumulator with the length of the file name.
\par     2) Load the X index register with the low order address of the file
\par        name.
\par     3) Load the Y index register with the high order address.
\par     4) Call this routine.
\par 
\par   EXAMPLE:
\par 
\par     LDA #NAME2-NAME     ;LOAD LENGTH OF FILE NAME
\par     LDX #<NAME          ;LOAD ADDRESS OF FILE NAME
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDY #>NAME
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR SETNAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B-31. Function Name: SETTIM
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Set the system clock
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FFDB (hex) 65499 (decimal)
\par     Communication registers: A, X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: None
\par     Stack requirements: 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected: None
\par 
\par                                             BASIC TO MACHINE LANGUAGE   299
\par \page 
\par 
\par 
\par     Description: A system clock is maintained by an interrupt routine that
\par   updates the clock every 1/60th of a second (one "jiffy"). The clock is
\par   three bytes long, which gives it the capability to count up to 5,184,000
\par   jiffies (24 hours). At that point the clock resets to zero. Before
\par   calling this routine to set the clock, the accumulator must contain the
\par   most significant byte, the X index register the next most significant
\par   byte, and the Y index register the least significant byte of the initial
\par   time setting (in jiffies).
\par 
\par   How to Use:
\par     1) Load the accumulator with the MSB of the 3-byte number to set the
\par        clock.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) Load the X register with the next byte.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) Load the Y register with the LSB.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    4) Call this routine.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   ;SET THE CLOCK TO 10 MINUTES = 3600 JIFFIES
\par    LDA #0               ;MOST SIGNIFICANT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   LDX #>3600
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   LDY #<3600           ;LEAST SIGNIFICANT
\par    JSR SETTIM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B-32. Function  Name: SETTMO
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Set IEEE bus card timeout flag
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FFA2 (hex) 65442 (decimal)
\par     Communication registers: A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: None
\par     Stack requirements: 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected: None
\par   +-----------------------------------------------------------------------+
\par   | NOTE: This routine is used ONLY with an IEEE add-on card!             |
\par   +-----------------------------------------------------------------------+
\par     Description: This routine sets the timeout flag for the IEEE bus. When
\par   the timeout flag is set, the Commodore 64 will wait for a device on the
\par   IEEE port for 64 milliseconds. If the device does not respond to the
\par   Commodore 64's Data Address Valid (DAV) signal within that time the
\par   Commodore 64 will recognize an error condition and leave the handshake
\par   sequence. When this routine is called when the accumulator contains a 0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in bit 7, timeouts are enabled. A 1 in bit 7 will disable the timeouts.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   300   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTE: The Commodore 64 uses the timeout feature to communicate that a |
\par   | disk file is not found on an attempt to OPEN a file only with an IEEE |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | card.                                                                 |
\par   +-----------------------------------------------------------------------+
\par 
\par   How to Use:
\par 
\par   TO SET THE TIMEOUT FLAG
\par     1) Set bit 7 of the accumulator to 0.
\par     2) Call this routine.
\par 
\par   TO RESET THE TIMEOUT FLAG
\par     1) Set bit 7 of the accumulator to 1.
\par     2) Call this routine.
\par 
\par   EXAMPLE:
\par 
\par     ;DISABLE TIMEOUT
\par     LDA #0
\par     JSR SETTMO
\par 
\par   B-33. Function Name: STOP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Check if <STOP> key is pressed
\par     Call address: $FFE1 (hex) 65505 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: None
\par     Error returns: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected: A, X
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: If the <STOP> key on the keyboard was pressed during a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  UDTIM call, this call returns the Z flag set. In addition, the channels
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  will be reset to default values. All other flags remain unchanged. If the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  <STOP> key is not pressed then the accumulator will contain a byte
\par   representing the lost row of the keyboard scan. The user can also check
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  for certain other keys this way.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    0) UDTIM should be called before this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Call this routine.
\par     2) Test for the zero flag.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   301
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR UDTIM   ;SCAN FOR STOP
\par     JSR STOP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    BNE *+5     ;KEY NOT DOWN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JMP READY   ;=... STOP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-34. Function Name: TALK
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Command a device on the serial bus to TALK
\par     Call address: $FFB4 (hex) 65460 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A
\par     Preparatory routines: None
\par     Error returns: See READST
\par     Stack requirements: 8
\par     Registers affected: A
\par 
\par     Description: To use this routine the accumulator must first be loaded
\par   with a device number between 0 and 31. When called, this routine then
\par   ORs bit by bit to convert this device number to a talk address. Then this
\par   data is transmitted as a command on the serial bus.
\par 
\par   How to Use:
\par 
\par     1) Load the accumulator with the device number.
\par     2) Call this routine.
\par 
\par   EXAMPLE:
\par 
\par     ;COMMAND DEVICE #4 TO TALK
\par     LDA #4
\par     JSR TALK
\par 
\par   B-35. Function Name: TKSA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Send a secondary address to a device commanded to TALK
\par     Call address: $FF96 (hex) 65430 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: TALK
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: See READST
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 8
\par     Registers affected: A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  302   BASIC TO MACHINE LANGUAGE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Description: This routine transmits a secondary address on the serial
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  bus for a TALK device. This routine must be called with a number between
\par   0 and 31 in the accumulator. The routine sends this number as a secondary
\par   address command over the serial bus. This routine can only be called
\par   after a call to the TALK routine. It will not work after a LISTEN.
\par 
\par   How to Use:
\par 
\par     0) Use the TALK routine.
\par     1) Load the accumulator with the secondary address.
\par     2) Call this routine.
\par 
\par   EXAMPLE:
\par 
\par     ;TELL DEVICE #4 TO TALK WITH COMMAND #7
\par     LDA #4
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR TALK
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDA #7
\par     JSR TALKSA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-36. Function Name: UDTIM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Update the system clock
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FFEA (hex) 65514 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: None
\par     Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 2
\par     Registers affected: A, X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine updates the system clock. Normally this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  routine is called by the normal KERNAL interrupt routine every 1/60th of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a second. If the user program processes its own interrupts this routine
\par   must be called to update the time. In addition, the <STOP> key routine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  must be called, if the <STOP> key is to remain functional.
\par 
\par   How to Use:
\par     1) Call this routine.
\par 
\par   EXAMPLE:
\par 
\par     JSR UDTIM
\par                                             BASIC TO MACHINE LANGUAGE   303
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   B-37. Function Name: UNLSN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Send an UNLISTEN command
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FFAE (hex) 65454 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: None
\par     Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: See READST
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 8
\par     Registers affected: A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine commands all devices on the serial bus to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  stop receiving data from the Commodore 64 (i.e., UNLISTEN). Calling this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  routine results in an UNLISTEN command being transmitted on the serial
\par   bus. Only devices previously commanded to listen are affected. This
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  routine is normally used after the Commodore 64 is finished sending data
\par   to external devices. Sending the UNLISTEN commands the listening devices
\par   to get off the serial bus so it can be used for other purposes.
\par 
\par   How to Use:
\par     1) Call this routine.
\par 
\par   EXAMPLE:
\par     JSR UNLSN
\par 
\par   B-38. Function Name: UNTLK
\par 
\par     Purpose: Send an UNTALK command
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FFAB (hex) 65451 (decimal)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication registers: None
\par     Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: See READST
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Stack requirements: 8
\par     Registers affected: A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine transmits an UNTALK command on the serial
\par   bus. All devices previously set to TALK will stop sending data when this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  command is received.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Call this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  304 BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR UNTALK
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  B-39. Function Name: VECTOR
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Purpose: Manage RAM vectors
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Call address: $FF8D (hex) 65421 (decimal)
\par     Communication registers: X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Preparatory routines: None
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Error returns: None
\par     Stack requirements: 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers affected: A, X, Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Description: This routine manages all system vector jump addresses
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  stored in RAM. Calling this routine with the the accumulator carry bit
\par   set stores the current contents of the RAM vectors in a list pointed to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  by the X and Y registers. When this routine is called with the carry
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  clear, the user list pointed to by the X and Y registers is transferred
\par   to the system RAM vectors. The RAM vectors are listed in the memory map.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTE: This routine requires caution in its use. The best way to use it|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | is to first read the entire vector contents into the user area, alter |
\par   | the desired vectors, and then copy the contents back to the system    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | vectors.                                                              |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  How to Use:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   READ THE SYSTEM RAM VECTORS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Set the carry.
\par     2) Set the X and y registers to the address to put the vectors.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) Call this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   LOAD THE SYSTEM RAM VECTORS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) Clear the carry bit.
\par     2) Set the X and Y registers to the address of the vector list in RAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       that must be loaded.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    3) Call this routine.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   305
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par     ;CHANGE THE INPUT ROUTINES TO NEW SYSTEM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDX #<USER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDY #>USER
\par     SEC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR VECTOR      ;READ OLD VECTORS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDA #<MYINP     ;CHANGE INPUT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    STA USER+10
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDA #>MYINP
\par     STA USER+11
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDX #<USER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LDY #>USER
\par     CLC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    JSR VECTOR      ;ALTER SYSTEM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    ...
\par     USER *=*+26
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ERROR CODES
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The following is a list of error messages which can occur when using
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the KERNAL routines. If an error occurs during a KERNAL routine , the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  carry bit of the accumulator is set, and the number of the error message
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is returned in the accumulator.
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTE: Some KERNAL I/O routines do not use these codes for error       |
\par   | messages. Instead, errors are identified using the KERNAL READST      |
\par   | routine.                                                              |
\par   +-----------------------------------------------------------------------+
\par   +-------+---------------------------------------------------------------+
\par   | NUMBER|                          MEANING                              |
\par   +-------+---------------------------------------------------------------+
\par   |   0   |  Routine terminated by the <STOP> key                         |
\par   |   1   |  Too many open files                                          |
\par   |   2   |  File already open                                            |
\par   |   3   |  File not open                                                |
\par   |   4   |  File not found                                               |
\par   |   5   |  Device not present                                           |
\par   |   6   |  File is not an input file                                    |
\par   |   7   |  File is not an output file                                   |
\par   |   8   |  File name is missing                                         |
\par   |   9   |  Illegal device number                                        |
\par   |  240  |  Top-of-memory change RS-232 buffer allocation/deallocation   |
\par   +-------+---------------------------------------------------------------+
\par   306   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par   USING MACHINE LANGUAGE FROM BASIC
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    There are several methods of using BASIC and machine language on the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Commodore 64, including special statements as part of CBM BASIC as well
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  as key locations in the machine. There are five main ways to use machine
\par   language routines from BASIC on the Commodore 64. They are:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                 1) The BASIC SYS statement
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                2) The BASIC USR function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                3) Changing one of the RAM I/O vectors
\par                 4) Changing one of the RAM interrupt vectors
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                5) Changing the CHRGET routine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) The BASIC statement SYS X causes a JUMP to a machine language
\par        subroutine located at address X. The routine must end with an RTS
\par        (ReTurn from Subroutine) instruction. This will transfer control
\par        back to BASIC.
\par          Parameters are generally passed between the machine language
\par        routine and the BASIC program using the BASIC PEEK and POKE
\par        statements, and their machine language equivalents.
\par          The SYS command is the most useful method of combining BASIC with
\par        machine language. PEEKs and POKEs make multiple parameter passing
\par        easy. There can be many SYS statements in a program, each to a
\par        different (or even the same) machine language routine.
\par 
\par     2) The BASIC function USR(X) transfers control to the machine language
\par        subroutine located at the address stored in locations 785 and 786.
\par        (The address is stored in standard low-byte/high-byte format.) The
\par        value X is evaluated and passed to the machine language subroutine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       through floating point accumulator #1, located beginning at address
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       $61 (see memory map for more details). A value may be returned back
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       to the BASIC program by placing it in the floating point
\par        accumulator. The machine language routine must end with an RTS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       instruction to return to BASIC.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {         This statement is different from the SYS, because you have to set
\par        up an indirect vector. Also different is the format through which
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       the variable is passed (floating point format). The indirect vector
\par        must be changed if more than one machine language routine is used.
\par 
\par 
\par 
\par                                             BASIC TO MACHINE LANGUAGE   307
\par \page 
\par 
\par 
\par     3) Any of the inpUt/OUtPUT or BASIC internal routines accessed through
\par        the vector table located on page 3 (see ADDRESSING MODES, ZERO PAGE)
\par        can be replaced, or amended by user code. Each 2-byte vector
\par        consists of a low byte and a high byte address which is used by the
\par        operating system.
\par          The KERNAL VECTOR routine is the most reliable way to change any
\par        of the vectors, but a single vector can be changed by POKES. A new
\par        vector will point to a user prepared routine which is meant to
\par        replace or augment the standard system routine. When the appropriate
\par        BASIC command is executed, the user routine will be executed. If
\par        after executing the user routine, it is necessary to execute the
\par        normal system routine, the user program must JMP (JUMP) to the
\par        address formerly contained in the vector. If not, the routine must
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       end with a RTS to transfer control back to BASIC.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     4) The HARDWARE INTERRUPT (IRQ) VECTOR can be changed. Every 1/60th of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       a second, the operating system transfers control to the routine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       specified by this vector. The KERNAL normally uses this for timing,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       keyboard scanning, etc. If this technique is used, you should always
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       transfer control to the normal IRQ handling routine, unless the
\par        replacement routine is prepared to handle the CIA chip. (REMEMBER to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       end the routine with an RTI (ReTurn from Interrupt) if the CIA is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       handled by the routine).
\par          This method is useful for tasks which must happen concurrently
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       with a BASIC program, but has the drawback of being more difficult.
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE: ALWAYS DISABLE INTERRUPTS BEFORE CHANGING THIS VECTOR!          |
\par   +-----------------------------------------------------------------------+
\par 
\par     5) The CHRGET routine is used by BASIC to get each character/token.
\par        This makes it simple to add new BASIC commands. Naturally, each new
\par        command must be executed by a user written machine language
\par        subroutine. A common way to use this method is to specify a
\par        character (@ for example) which will occur before any of the new
\par        commands. The new CHRGET routine will search for the special
\par        character. If none is present, control is passed to the normal BASIC
\par        CHRGET routine. If the special character is present, the new command
\par        is interpreted and executed by your machine language program. This
\par        minimizes the extra execution time added by the need to search for
\par        additional commands. This technique is often called a wedge.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  308   BASIC TO MACHINE LANGUAGE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   WHERE TO PUT MACHINE LANGUAGE ROUTINES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The best place for machine language routines on the Commodore 64 is
\par   from $C000-$CFFF, assuming the routines are smaller than 4K bytes long.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  This section of memory is not disturbed by BASIC.
\par     If for some reason it's not possible or desirable to put the machine
\par   language routine at $C000, for instance if the routine is larger than 4K
\par   bytes, it then becomes necessary to reserve an area at the top of memory
\par   from BASIC for the routine. The top of memory is normally $9FFF. The top
\par   of memory can be changed through the KERNAL routine MEMTOP, or by the
\par   following BASIC statements:
\par 
\par     10 POKE51,L:POKE52,H:POKE55,1:POKE56,H:CLR
\par 
\par   Where H and L are the high and low portions, respectively, of the new
\par   top of memory. For example, to reserve the area from $9000 to $9FFF for
\par   machine language, use the following:
\par 
\par     10 POKE5110:POKE52,144:POKE5510:POKE56,144:CLR
\par 
\par 
\par   HOW TO ENTER MACHINE LANGUAGE
\par 
\par     There are 3 common methods to add the machine language programs to a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BASIC program. They are:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   1) DATA STATEMENTS:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    By READing DATA statements, and POKEing the values into memory at the
\par   start of the program, machine language routines can be added. This is the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  easiest method. No special methods are needed to save the two parts of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the program, and it is fairly easy to debug. The drawbacks include taking
\par   up more memory space, and the wait while the program is POKED in.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Therefore, this method is better for smaller routines.
\par 
\par   EXAMPLE:
\par 
\par   10 RESTORE:FORX=1T09:READA:POKE12*4096+X,A:NEXT
\par   .
\par   BASIC PROGRAM
\par   .
\par   1000 DATA 161,1,204,204,204,204,204,204,96
\par 
\par                                             BASIC TO MACHINE LANGUAGE   309
\par \page 
\par 
\par 
\par   2) MACHINE LANGUAGE MONITOR (64MON):
\par 
\par     This program allows you to enter a program in either HEX or SYMBOLIC
\par   codes, and save the portion of memory the program is in. Advantages of
\par   this method include easier entry of the machine language routines,
\par   debugging aids, and a much faster means of saving and loading. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  drawback to this method is that it generally requires the BASIC program
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to load the machine language routine from tape or disk when it is
\par   started. (For more details on 64MON see the machine language section.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXAMPLE:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The following is an example of a BASIC program using a machine language
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  routine prepared by 64MON. The routine is stored on tape:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    10 IF FLAG=L THEN 20
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    15 FLAG=1:LOAD"MACHINE LANGUAGE ROUTINE NAME",1,1
\par     20
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    .
\par     REST OF BASIC PROGRAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   3) EDITOR/ASSEMBLER PACKAGE:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Advantages are similar to using a machine language monitor, but
\par   programs are even easier to enter. Disadvantages are also similar to the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  use of a machine language monitor.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  COMMODORE 64 MEMORY MAP
\par 
\par              HEX        DECIMAL
\par    LABEL   ADDRESS      LOCATION               DESCRIPTION
\par   -------------------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D6510   0000            0        6510 On-Chip Data-Direction Register
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  R6510   0001            1        6510 On-Chip 8-Bit Input/Output Register
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          0002            2        Unused
\par   ADRAY1  0003-0004       3-4      Jump Vector: Convert Floating-Integer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  310   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {             HEX        DECIMAL
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   LABEL   ADDRESS      LOCATION               DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------------------------------------------------------------------------
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ADRAY2  0005-0006       5-6      Jump Vector: Convert Integer--Floating
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CHARAC  0007            7        Search Character
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ENDCHR  0008            8        Flag: Scan for Quote at End of String
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TRMPOS  0009            9        Screen Column From Last TAB
\par   VERCK   000A           10        Flag: 0 = Load, 1 = Verify
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  COUNT   000B           11        Input Buffer Pointer / No. of Subscripts
\par   DIMFLG  000C           12        Flag: Default Array DiMension
\par   VALTYP  000D           13        Data Type: $FF = String, $00 = Numeric
\par   INTFLG  000E           14        Data Type: $80 = Integer, $00 = Floating
\par   GARBFL  000F           15        Flag: DATA scan/LIST quote/Garbage Coll
\par   SUBFLG  0010           16        Flag: Subscript Ref / User Function Call
\par   INPFLG  0011           17        Flag: $00 = INPUT, $40 = GET, $98 = READ
\par   TANSGN  0012           18        Flag TAN sign / Comparison Result
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          0013           19        Flag: INPUT Prompt
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LINNUM  0014-0015      20-21     Temp: Integer Value
\par   TEMPPT  0016           22        Pointer Temporary String
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LASTPT  0017-0018      23-24     Last Temp String Address
\par   TEMPST  0019-0021      25-33     Stack for Temporary Strings
\par   INDEX   0022-0025      34-37     Utility Pointer Area
\par 
\par   INDEX1  0022-0023      34-35     First Utility Pointer.
\par   INDEX2  0024-0025      36-37     Second Utility Pointer.
\par 
\par   RESHO   0026-002A      38-42     Floating-Point Product of Multiply
\par   TXTTAB  002B-002C      43-44     Pointer: Start of BASIC Text
\par   VARTAB  002D-002E      45-46     Pointer: Start of BASIC Variables
\par   ARYTAB  002F-0030      47-48     Pointer: Start of BASIC Arrays
\par   STREND  0031-0032      49-50     Pointer End of BASIC Arrays (+1)
\par   FRETOP  0033-0034      51-52     Pointer: Bottom of String Storage
\par   FRESPC  0035-0036      53-54     Utility String Pointer
\par   MEMSIZ  0037-0038      55-56     Pointer: Highest Address Used by BASIC
\par   CURLIN  0039-003A      57-58     Current BASIC Line Number
\par   OLDLIN  003B-003C      59-60     Previous BASIC Line Number
\par   OLDTXT  003D-003E      61-62     Pointer: BASIC Statement for CONT
\par   DATLIN  003F-0040      63-64     Current DATA Line Number
\par   DATPTR  0041-0042      65-66     Pointer: Current DATA Item Address
\par   INPPTR  0043-0044      67-68     Vector: INPUT Routine
\par   VARNAM  0045-0046      69-70     Current BASIC Variable Name
\par 
\par                                             BASIC TO MACHINE LANGUAGE   311
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {             HEX        DECIMAL
\par    LABEL   ADDRESS      LOCATION               DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------------------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   VARPNT  0047-0048      71-72     Pointer: Current BASIC Variable Data
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FORPNT  0049-004A      73-74     Pointer: Index Variable for FOR/NEXT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          004B-0060      75-96     Temp Pointer / Data Area
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VARTXT  004B-004C      75-76     Temporary storage for TXTPTR during
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     READ, INPUT and GET.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  OPMASK  004D           77        Mask used during FRMEVL.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TEMPF3  004E-0052      78-82     Temporary storage for FLPT value.
\par   FOUR6   0053           83        Length of String Variable during Garbage
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     collection.
\par   JMPER   0054-0056      84-86     Jump Vector used in Function Evaluation-
\par                                      JMP followed by Address ($4C,$LB,$MB).
\par   TEMPF1  0057-005B      87-91     Temporary storage for FLPT value.
\par   TEMPF2  005C-0060      92-96     Temporary storage for FLPT value.
\par   FACEXP  0061           97        Floating-Point Accumulator #1: Exponent
\par   FACHO   0062-0065      98-101    Floating Accum. #1: Mantissa
\par   FACSGN  0066          102        Floating Accum. #1: Sign
\par   SGNFLG  0067          103        Pointer: Series Evaluation Constant
\par   BITS    0068          104        Floating Accum. #1: Overflow Digit
\par   ARGEXP  0069          105        Floating-Point Accumulator #2: Exponent
\par   ARGHO   006A-006D     106-109    Floating Accum. #2: Mantissa
\par   ARGSGN  006E          110        Floating Accum. #2: Sign
\par   ARISGN  006F          111        Sign Comparison Result: Accum. # 1 vs #2
\par   FACOV   0070          112        Floating Accum. #1. Low-Order (Rounding)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FBUFPT  0071-0072     113-114    Pointer: Cassette Buffer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CHRGET  0073-008A     115-138    Subroutine: Get Next Byte of BASIC Text
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   CHRGOT  0079          121        Entry to Get Same Byte of Text Again
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TXTPTR  007A-007B     122-123    Pointer: Current Byte of BASIC Text
\par 
\par   RNDX    008B-008F     139-143    Floating RND Function Seed Value
\par   STATUS  0090          144        Kernal I/O Status Word: ST
\par   STKEY   0091          145        Flag: STOP key / RVS key
\par   SVXT    0092          146        Timing Constant for Tape
\par   VERCK   0093          147        Flag: 0 = Load, 1 = Verify
\par   C3PO    0094          148        Flag: Serial Bus-Output Char. Buffered
\par   BSOUR   0095          149        Buffered Character for Serial Bus
\par   SYNO    0096          150        Cassette Sync No.
\par 
\par   312   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par              HEX        DECIMAL
\par    LABEL   ADDRESS      LOCATION               DESCRIPTION
\par   -------------------------------------------------------------------------
\par 
\par           0097          151        Temp Data Area
\par   LDTND   0098          152        No. of Open Files / Index to File Table
\par   DFLTN   0099          153        Default Input Device (0)
\par   DFLTO   009A          154        Default Output (CMD) Device (3)
\par   PRTY    009B          155        Tape Character Parity
\par   DPSW    009C          156        Flag: Tape Byte-Received
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  MSGFLG  009D          157        Flag: $80 = Direct Mode, $00 = Program
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PTR1    009E          158        Tape Pass 1 Error Log
\par   PTR2    009F          159        Tape Pass 2 Error Log
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TIME    00A0-00A2     160-162    Real-Time Jiffy Clock (approx) 1/60 Sec
\par           00A3-00A4     163-164    Temp Data Area
\par   CNTDN   00A5          165        Cassette Sync Countdown
\par   BUFPNT  00A6          166        Pointer: Tape I/O Buffer
\par   INBIT   00A7          167        RS-232 Input Bits / Cassette Temp
\par   BITCI   00A8          168        RS-232 Input Bit Count / Cassette Temp
\par   RINONE  00A9          169        RS-232 Flag: Check for Start Bit
\par   RIDATA  00AA          170        RS-232 Input Byte Buffer/Cassette Temp
\par   RIPRTY  00AB          171        RS-232 Input Parity / Cassette Short Cnt
\par   SAL     00AC-00AD     172-173    Pointer: Tape Buffer/ Screen Scrolling
\par   EAL     00AE-00AF     174-175    Tape End Addresses/End of Program
\par   CMP0    00B0-00B1     176-177    Tape Timing Constants
\par   TAPE1   00B2-00B3     178-179    Pointer: Start of Tape Buffer
\par   BITTS   00B4          180        RS-232 Out Bit Count / Cassette Temp
\par   NXTBIT  00B5          181        RS-232 Next Bit to Send/ Tape EOT Flag
\par   RODATA  00B6          182        RS-232 Out Byte Buffer
\par   FNLEN   00B7          183        Length of Current File Name
\par   LA      00B8          184        Current Logical File Number
\par   SA      00B9          185        Current Secondary Address
\par   FA      00BA          186        Current Device Number
\par   FNADR   00BB-00BC     187-188    Pointer: Current File Name
\par   ROPRTY  00BD          189        RS-232 Out Parity / Cassette Temp
\par   FSBLK   00BE          190        Cassette Read / Write Block Count
\par   MYCH    00BF          191        Serial Word Buffer
\par   CAS1    00C0          192        Tape Motor Interlock
\par   STAL    00C1-00C2     193-194    I/O Start Address
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  MEMUSS  00C3-00C4     195-196    Tape Load Temps
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LSTX    00C5          197        Current Key Pressed: CHR$(n) 0 = No Key
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  NDX     00C6          198        No. of Chars. in Keyboard Buffer (Queue)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                             BASIC TO MACHINE LANGUAGE   313
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {             HEX        DECIMAL
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   LABEL   ADDRESS      LOCATION               DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------------------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   RVS     00C7          199        Flag: Reverse Chars. - 1=Yes, 0=No Used
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INDX    00C8          200        Pointer: End of Logical Line for INPUT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LXSP    00C9-00CA     201-202    Cursor X-Y Pos. at Start of INPUT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SFDX    00CB          203        Flag: Print Shifted Chars.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BLNSW   00CC          204        Cursor Blink enable: 0 = Flash Cursor
\par   BLNCT   00CD          205        Timer: Countdown to Toggle Cursor
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  GDBLN   00CE          206        Character Under Cursor
\par   BLNON   00CF          207        Flag: Last Cursor Blink On/Off
\par   CRSW    00D0          208        Flag: INPUT or GET from Keyboard
\par   PNT     00D1-00D2     209-210    Pointer: Current Screen Line Address
\par   PNTR    00D3          211        Cursor Column on Current Line
\par   QTSW    00D4          212        Flag: Editor in Quote Mode, $00 = NO
\par   LNMX    00D5          213        Physical Screen Line Length
\par   TBLX    00D6          214        Current Cursor Physical Line Number
\par           00D7          215        Temp Data Area
\par   INSRT   00D8          216        Flag: Insert Mode, >0 = # INSTs
\par   LDTB1   00D9-00F2     217-242    Screen Line Link Table / Editor Temps
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  USER    00F3-00F4     243-244    Pointer: Current Screen Color RAM loc.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  KEYTAB  00F5-00F6     245-246    Vector Keyboard Decode Table
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RIBUF   00F7-00F8     247-248    RS-232 Input Buffer Pointer
\par   ROBUF   00F9-00FA     249-250    RS-232 Output Buffer  Pointer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FREKZP  00FB-00FE     251-254    Free 0-Page Space for User Programs
\par   BASZPT  00FF          255        BASIC Temp Data Area
\par           0100-01FF     256-511    Micro-Processor System Stack Area
\par 
\par           0100-010A     256-266    Floating to String Work Area
\par   BAD     0100-013E     256-318    Tape Input Error Log
\par 
\par   BUF     0200-02S8     512-600    System INPUT Buffer
\par   LAT     0259-0262     601-610    KERNAL Table: Active Logical File No's.
\par   FAT     0263-026C     611-620    KERNAL Table: Device No. for Each File
\par   SAT     026D-0276     621-630    KERNAL Table: Second Address Each File
\par   KEYD    0277-0280     631-640    Keyboard Buffer Queue (FIFO)
\par   MEMSTR  0281-0282     641-642    Pointer: Bottom of Memory for O.S.
\par   MEMSIZ  0283-0284     643-644    Pointer: Top of Memory for O.S.
\par   TIMOUT  0285          645        Flag: Kernal Variable for IEEE Timeout
\par   COLOR   0286          646        Current Character Color Code
\par   GDCOL   0287          647        Background Color Under Cursor
\par 
\par   314   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par              HEX        DECIMAL
\par    LABEL   ADDRESS      LOCATION               DESCRIPTION
\par   -------------------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  HIBASE  0288          648        Top of Screen Memory (Page)
\par   XMAX    0289          649        Size of Keyboard Buffer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RPTFLG  028A          650        Flag: REPEAT Key Used, $80 = Repeat
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  KOUNT   028B          651        Repeat Speed Counter
\par   DELAY   028C          652        Repeat Delay Counter
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SHFLAG  028D          653        Flag: Keyboard SHIFT Key/CTRL Key/C= Key
\par   LSTSHF  028E          654        Last Keyboard Shift Pattern
\par   KEYLOG  028F-0290     655-656    Vector: Keyboard Table Setup
\par   MODE    0291          657        Flag: $00=Disable SHIFT Keys, $80=Enable
\par   AUTODN  0292          658        Flag: Auto Scroll Down, 0 = ON
\par   M51CTR  0293          659        RS-232: 6551 Control Register Image
\par   MS1CDR  0294          660        RS-232: 6551 Command Register Image
\par   M51AJB  0295-0296     661-662    RS-232 Non-Standard BPS (Time/2-100) USA
\par   RSSTAT  0297          663        RS-232: 6551 Status Register Image
\par   BITNUM  0298          664        RS-232 Number of Bits Left to Send
\par   BAUDOF  0299-029A     665-666    RS-232 Baud Rate: Full Bit Time (us)
\par   RIDBE   029B          667        RS-232 Index to End of Input Buffer
\par   RIDBS   029C          668        RS-232 Start of Input Buffer (Page)
\par   RODBS   029D          669        RS-232 Start of Output Buffer (Page)
\par   RODBE   029E          670        RS-232 Index to End of Output Buffer
\par   IRQTMP  029F-02A0     671-672    Holds IRQ Vector During Tape I/O
\par   ENABL   02A1          673        RS-232 Enables
\par           02A2          674        TOD Sense During Cassette I/O
\par           02A3          675        Temp Storage For Cassette Read
\par           02A4          676        Temp D1 IRQ Indicator For Cassette Read
\par           02A5          677        Temp For Line Index
\par           02A6          678        PAL/NTSC Flag, 0= NTSC, 1 = PAL
\par           02A7-02FF     679-767    Unused
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  IERROR  0300-0301     768-769    Vector: Print BASIC Error Message
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  IMAIN   0302-0303     770-771    Vector: BASIC Warm Start
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ICRNCH  0304-0305     772-773    Vector: Tokenize BASIC Text
\par   IQPLOP  0306-0307     774-775    Vector: BASIC Text LIST
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  IGONE   0308-0309     776-777    Vector: BASIC Char. Dispatch
\par   IEVAL   030A-030B     778-779    Vector: BASIC Token Evaluation
\par   SAREG   030C          780        Storage for 6502 .A Register
\par   SXREG   030D          781        Storage for 5502 .X Register
\par   SYREG   030E          782        Storage for 6502 .Y Register
\par   SPREG   030F          783        Storage for 6502 .SP Register
\par 
\par                                             BASIC TO MACHINE LANGUAGE   315
\par \page 
\par 
\par 
\par              HEX        DECIMAL
\par    LABEL   ADDRESS      LOCATION               DESCRIPTION
\par   -------------------------------------------------------------------------
\par 
\par   USRPOK  0310          784        USR Function Jump Instr (4C)
\par   USRADD  0311-0312     785-786    USR Address Low Byte / High Byte
\par           0313          787        Unused
\par   CINV    0314-0315     788-789    Vector: Hardware Interrupt
\par   CBINV   0316-0317     790-791    Vector: BRK Instr. Interrupt
\par   NMINV   0318-0319     792-793    Vector: Non-Maskable Interrupt
\par   IOPEN   031A-031B     794-795    KERNAL OPEN Routine Vector
\par   ICLOSE  031C-031D     796-797    KERNAL CLOSE Routine Vector
\par   ICHKIN  031E-031F     798-799    KERNAL CHKIN Routine
\par   ICKOUT  0320-0321     800-801    KERNAL CHKOUT Routine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ICLRCH  0322-0323     802-803    KERNAL CLRCHN Routine Vector
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  IBASIN  0324-0325     804-805    KERNAL CHRIN Routine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  IBSOUT  0326-0327     806-807    KERNAL CHROUT Routine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ISTOP   0328-0329     808-809    KERNAL STOP Routine Vector
\par   IGETIN  032A-032B     810-811    KERNAL GETIN Routine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ICLALL  032C-032D     812-813    KERNAL CLALL Routine Vector
\par   USRCMD  032E-032F     814-815    User-Defined Vector
\par   ILOAD   0330-0331     813-817    KERNAL LOAD Routine
\par   ISAVE   0332-0333     818-819    KERNAL SAVE Routine Vector
\par           0334-033B     820-827    Unused
\par   TBUFFR  033C-03FB     828-1019   Tape I/O Buffer
\par           03FC-03FF    1020-1023   Unused
\par   VICSCN  0400-07FF    1024-2047   1024 Byte Screen Memory Area
\par 
\par           0400-07E7    1024-2023   Video Matrix: 25 Lines X 40 Columns
\par           07F8-07FF    2040-2047   Sprite Data Pointers
\par 
\par           0800-9FFF   2048-40959   Normal BASIC Program Space
\par           8000-9FFF  32768-40959   VSP Cartridge ROM - 8192 Bytes
\par           A000-BFFF  40960-49151   BASIC ROM - 8192 Bytes (or 8K RAM)
\par           C000-CFFF  49152-53247   RAM - 4096 Bytes
\par           D000-DFFF  53248-57343   Input/Output Devices and
\par                                      Color RAM or Character Generator ROM
\par                                      or RAM - 4096 Bytes
\par           E000-FFFF  57344-65535   KERNAL ROM - 8192 Bytes (or 8K RAM)
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  316   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  COMMODORE 64 INPUT/OUTPUT ASSIGNMENTS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   HEX      DECIMAL        BITS                 DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------------------------------------------------------------------------
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  0000           0          7-0    MOS 6510 Data Direction
\par                                      Register (xx101111)
\par                                      Bit= 1: Output, Bit=0:
\par                                      Input, x=Don't Care
\par 
\par   0001           1                 MOS 6510 Micro-Processor
\par                                      On-Chip I/O Port
\par                             0      /LORAM Signal (0=Switch BASIC ROM Out)
\par                             1      /HIRAM Signal (0=Switch Kernal ROM Out)
\par                             2      /CHAREN Signal (0=Switch Char. ROM In)
\par                             3      Cassette Data Output Line
\par                             4      Cassette Switch Sense: 1 = Switch Closed
\par                             5      Cassette Motor Control 0 = ON, 1 = OFF
\par                             6-7    Undefined
\par 
\par 
\par   D000-D02E  53248-54271           MOS 6566 VIDEO INTERFACE CONTROLLER
\par                                    (VIC)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D000       53248                 Sprite 0 X Pos
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D001       53249                 Sprite 0 Y Pos
\par   D002       53250                 Sprite 1 X Pos
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D003       53251                 Sprite 1 Y Pos
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D004       53252                 Sprite 2 X Pos
\par   D005       53253                 Sprite 2 Y Pos
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D006       53254                 Sprite 3 X Pos
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D007       53255                 Sprite 3 Y Pos
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D008       53256                 Sprite 4 X Pos
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D009       53257                 Sprite 4 Y Pos
\par   D00A       53258                 Sprite 5 X Pos
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D00B       53259                 Sprite 5 Y Pos
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D00C       53260                 Sprite 6 X Pos
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D00D       53261                 Sprite 6 Y Pos
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D00E       53262                 Sprite 7 X Pos
\par   D00F       53263                 Sprite 7 Y Pos
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                             BASIC TO MACHINE LANGUAGE   317
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   HEX      DECIMAL        BITS                 DESCRIPTION
\par   -------------------------------------------------------------------------
\par 
\par   D010       53264                 Sprites 0-7 X Pos (msb of X coord.)
\par   D011       53265                 VIC Control Register
\par                             7      Raster Compare: (Bit 8) See 53266
\par                             6      Extended Color Text Mode 1 = Enable
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            5      Bit Map Mode. 1 = Enable
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            4      Blank Screen to Border Color: 0 = Blank
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            3      Select 24/25 Row Text Display: 1=25 Rows
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            2-0    Smooth Scroll to Y Dot-Position (0-7)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D012       53266                 Read Raster/Write Raster Value for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     Compare IRQ
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D013       53267                 Light-Pen Latch X Pos
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D014       53268                 Light-Pen Latch Y Pos
\par   D015       53269                 Sprite display Enable: 1 = Enable
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D016       53270                 VIC Control Register
\par                             7-6    Unused
\par                             5      ALWAYS SET THIS BIT TO 0 !
\par                             4      Multi-Color Mode: 1 = Enable (Text or
\par                                      Bit-Map)
\par                             3      Select 38/40 Column Text Display:
\par                                      1 = 40 Cols
\par                             2-0    Smooth Scroll to X Pos
\par 
\par   D017       53271                 Sprites 0-7 Expand 2x Vertical (Y)
\par   D018       53272                 VIC Memory Control Register
\par                             7-4    Video Matrix Base Address (inside VIC)
\par                             3-1    Character Dot-Data Base Address (inside
\par                                      VIC)
\par                             0      Select upper/lower Character Set
\par 
\par   D019       53273                 VIC Interrupt Flag Register (Bit = 1:
\par                                      IRQ Occurred)
\par                             7      Set on Any Enabled VIC IRQ Condition
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            3      Light-Pen Triggered IRQ Flag
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            2      Sprite to Sprite Collision IRQ Flag
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            1      Sprite to Background Collision IRQ Flag
\par                             0      Raster Compare IRQ Flag
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  318   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par    HEX      DECIMAL        BITS                 DESCRIPTION
\par   -------------------------------------------------------------------------
\par 
\par   D01A       53274                 IRQ Mask Register: 1 = Interrupt Enabled
\par   D01B       53275                 Sprite to Background Display Priority:
\par                                      1 = Sprite
\par   D01C       53276                 Sprites 0-7 Multi-Color Mode Select:
\par                                      1 = M.C.M.
\par   D01D       53277                 Sprites 0-7 Expand 2x Horizontal (X)
\par   D01E       53278                 Sprite to Sprite Collision Detect
\par   D01F       53279                 Sprite to Background Collision Detect
\par   D020       53280                 Border Color
\par   D021       53281                 Background Color 0
\par   D022       53282                 Background Color 1
\par   D023       53283                 Background Color 2
\par   D024       53284                 Background Color 3
\par   D025       53285                 Sprite Multi-Color Register 0
\par   D026       53286                 Sprite Multi-Color Register 1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D027       53287                 Sprite 0 Color
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D028       53288                 Sprite 1 Color
\par   D029       53289                 Sprite 2 Color
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D02A       53290                 Sprite 3 Color
\par   D02B       53291                 Sprite 4 Color
\par   D02C       53292                 Sprite 5 Color
\par   D02D       53293                 Sprite 6 Color
\par   D02E       53294                 Sprite 7 Color
\par 
\par 
\par   D400-D7FF  54272-55295     MOS 6581 SOUND INTERFACE DEVICE (SID)
\par 
\par   D400       54272                 Voice 1: Frequency Control - Low-Byte
\par   D401       54273                 Voice 1: Frequency Control - High-Byte
\par   D402       54274                 Voice 1: Pulse Waveform Width - Low-Byte
\par   D403       54275          7-4    Unused
\par                             3-0    Voice 1: Pulse Waveform Width - High-
\par                                      Nybble
\par 
\par   D404       54276                 Voice 1: Control Register
\par                             7      Select Random Noise Waveform, 1 = On
\par                             6      Select Pulse Waveform, 1 = On
\par                             5      Select Sawtooth Waveform, 1 = On
\par                             4      Select Triangle Waveform, 1 = On
\par 
\par                                             BASIC TO MACHINE LANGUAGE   319
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   HEX      DECIMAL        BITS                 DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------------------------------------------------------------------------
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            3      Test Bit: 1 = Disable Oscillator 1
\par                             2      Ring Modulate Osc. 1 with Osc. 3 Output,
\par                                      1 = On
\par                             1      Synchronize Osc.1 with Osc.3 Frequency,
\par                                      1 = On
\par                             0      Gate Bit: 1 = Start Att/Dec/Sus,
\par                                              0 = Start Release
\par 
\par   D405       54277                 Envelope Generator 1: Attack/Decay Cycle
\par                                      Control
\par                             7-4    Select Attack Cycle Duration: 0-15
\par                             3-0    Select Decay Cycle Duration: 0-15
\par 
\par   D406       54278                 Envelope Generator 1: Sustain/Release
\par                                      Cycle Control
\par                             7-4    Select Sustain Cycle Duration: 0-15
\par                             3-0    Select Release Cycle Duration: 0-15
\par 
\par   D407       54279                 Voice 2: Frequency Control - Low-Byte
\par   D408       54280                 Voice 2: Frequency Control - High-Byte
\par   D409       54281                 Voice 2: Pulse Waveform Width - Low-Byte
\par   D40A       54282          7-4    Unused
\par                             3-0    Voice 2: Pulse Waveform Width - High-
\par                                      Nybble
\par 
\par   D40B       54283                 Voice 2: Control Register
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            7      Select Random Noise Waveform, 1 = On
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            6      Select Pulse Waveform, 1 = On
\par                             5      Select Sawtooth Waveform, 1 = On
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            4      Select Triangle Waveform, 1 = On
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            3      Test Bit: 1 = Disable Oscillator 1
\par                             2      Ring Modulate Osc. 2 with Osc. 1 Output,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     1 = On
\par                             1      Synchronize Osc.2 with Osc. 1 Frequency,
\par                                      1 = On
\par                             0      Gate Bit: 1 = Start Att/Dec/Sus,
\par                                              0 = Start Release
\par 
\par 
\par 
\par   320   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par    HEX      DECIMAL        BITS                 DESCRIPTION
\par   -------------------------------------------------------------------------
\par 
\par   D40C       54284                 Envelope Generator 2: Attack / Decay
\par                                      Cycle Control
\par                             7-4    Select Attack Cycle Duration: 0-15
\par                             3-0    Select Decay Cycle Duration: 0-15
\par 
\par   D40D       54285                 Envelope Generator 2: Sustain / Release
\par                                      Cycle Control
\par                             7-4    Select Sustain Cycle Duration: 0-15
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            3-0    Select Release Cycle Duration: 0-15
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   D40E       54286                 Voice 3: Frequency Control - Low-Byte
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D40F       54287                 Voice 3: Frequency Control - High-Byte
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D410       54288                 Voice 3: Pulse Waveform Width - Low-Byte
\par   D411       54289          7-4    Unused
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            3-0    Voice 3: Pulse Waveform Width - High-
\par                                      Nybble
\par 
\par   D412       54290                 Voice 3: Control Register
\par                             7      Select Random Noise Waveform, 1 = On
\par                             6      Select Pulse Waveform, 1 = On
\par                             5      Select Sawtooth Waveform, 1 = On
\par                             4      Select Triangle Waveform, 1 = On
\par                             3      Test Bit: 1 = Disable Oscillator 1
\par                             2      Ring Modulate Osc. 3 with Osc. 2 Output,
\par                                      1 = On
\par                             1      Synchronize Osc. 3 with Osc.2 Frequency,
\par                                      1 = On
\par                             0      Gate Bit: 1 = Start Att/Dec/Sus,
\par                                              0 = Start Release
\par 
\par   D413       54291                 Envelope Generator 3: Attack/Decay Cycle
\par                                      Control
\par                             7-4    Select Attack Cycle Duration: 0-15
\par                             3-0    Select Decay Cycle Duration: 0-15
\par 
\par   D414       54285                 Envelope Generator 3: Sustain / Release
\par                                      Cycle Control
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            7-4    Select Sustain Cycle Duration: 0-15
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            3-0    Select Release Cycle Duration: 0-15
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                             BASIC TO MACHINE LANGUAGE   321
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   HEX      DECIMAL        BITS                 DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------------------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D415       54293                 Filter Cutoff Frequency: Low-Nybble
\par                                      (Bits 2-0)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D416       54294                 Filter Cutoff Frequency: High-Byte
\par   D417       54295                 Filter Resonance Control / Voice Input
\par                                      Control
\par                             7-4    Select Filter Resonance: 0-15
\par                             3      Filter External Input: 1 = Yes, 0 = No
\par                             2      Filter Voice 3 Output: 1 = Yes, 0 = No
\par                                    Filter Voice 2 Output: 1 = Yes, 0 = No
\par                             0      Filter Voice 1 Output: 1 = Yes, 0 = No
\par 
\par   D418       54296                 Select Filter Mode and Volume
\par                             7      Cut-Off Voice 3 Output: 1 = Off, 0 = On
\par                             6      Select Filter High-Pass Mode: 1 = On
\par                             5      Select Filter Band-Pass Mode: 1 = On
\par                             4      Select Filter Low-Pass Mode: 1 = On
\par                             3-0    Select Output Volume: 0-15
\par 
\par   D419       54297                 Analog/Digital Converter: Game Paddle 1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     (0-255)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D41A       54298                 Analog/Digital Converter: Game Paddle 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     (0-255)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D41B       54299                 Oscillator 3 Random Number Generator
\par   D41C       54230                 Envelope Generator 3 Output
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  D500-D7FF  54528-55295           SID IMAGES
\par   D800-DBFF  55296-56319           Color RAM (Nybbles)
\par 
\par   DC00-DCFF  56320-56575           MOS 6526 Complex Interface Adapter
\par                                      (CIA) #1
\par 
\par   DC00       56320                 Data Port A (Keyboard, Joystick,
\par                                      Paddles, Light-Pen)
\par                             7-0    Write Keyboard Column Values for
\par                                      Keyboard Scan
\par                             7-6    Read Paddles on Port A / B (01 = Port A,
\par                                      10 = Port B)
\par                             4      Joystick A Fire Button: 1 = Fire
\par                             3-2    Paddle Fire Buttons
\par                             3-0     Joystick A Direction (0-15)
\par 
\par   322   BASIC TO MACHINE LANGUAGE
\par \page 
\par 
\par 
\par    HEX      DECIMAL        BITS                 DESCRIPTION
\par   -------------------------------------------------------------------------
\par 
\par   DC01       56321                 Data Port B (Keyboard, Joystick,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     Paddles): Game Port 1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            7-0    Read Keyboard Row Values for Keyboard
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     Scan
\par                             7      Timer B Toggle/Pulse Output
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            6      Timer A: Toggle/Pulse Output
\par                             4      Joystick 1 Fire Button: 1 = Fire
\par                             3-2    Paddle Fire Buttons
\par                             3-0    Joystick 1 Direction
\par 
\par   DC02       56322                 Data Direction Register - Port A (56320)
\par   DC03       56323                 Data Direction Register - Port B (56321)
\par   DC04       56324                 Timer A: Low-Byte
\par   DC05       56325                 Timer A: High-Byte
\par   DC06       56326                 Timer B: Low-Byte
\par   DC07       56327                 Timer B: High-Byte
\par 
\par   DC08       56328                 Time-of-Day Clock: 1/10 Seconds
\par   DC09       56329                 Time-of-Day Clock: Seconds
\par   DC0A       56330                 Time-of-Day Clock: Minutes
\par   DC0B       56331                 Time-of-Day Clock: Hours + AM/PM Flag
\par                                      (Bit 7)
\par   DC0C       56332                 Synchronous Serial I/O Data Buffer
\par   DC0D       56333                 CIA Interrupt Control Register
\par                                      (Read IRQs/Write Mask)
\par                             7      IRQ Flag (1 = IRQ Occurred) / Set-
\par                                      Clear Flag
\par                             4      FLAG1 IRQ (Cassette Read / Serial Bus
\par                                      SRQ Input)
\par                             3      Serial Port Interrupt
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            2      Time-of-Day Clock Alarm Interrupt
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            1      Timer B Interrupt
\par                             0      Timer A Interrupt
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                            BASIC TO MACHINE LANGUAGE   323
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par    HEX      DECIMAL        BITS                 DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------------------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   DC0E       56334                 CIA Control Register A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            7      Time-of-Day Clock Frequency: 1 = 50 Hz,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     0 = 60 Hz
\par                             6      Serial Port I/O Mode Output, 0 = Input
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            5      Timer A Counts: 1 = CNT Signals,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     0 = System 02 Clock
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            4      Force Load Timer A: 1 = Yes
\par                             3      Timer A Run Mode: 1 = One-Shot,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     0 = Continuous
\par                             2      Timer A Output Mode to PB6: 1 = Toggle,
\par                                      0 = Pulse
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            1      Timer A Output on PB6: 1 = Yes, 0 = No
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            0      Start/Stop Timer A: 1 = Start, 0 = Stop
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  DC0F       56335                 CIA Control Register B
\par                             7      Set Alarm/TOD-Clock: 1 = Alarm,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     0 = Clock
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            6-5    Timer B Mode Select:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     00 = Count System 02 Clock Pulses
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     01 = Count Positive CNT Transitions
\par                                      10 = Count Timer A Underflow Pulses
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     11 = Count Timer A Underflows While
\par                                        CNT Positive
\par                             4-0    Same as CIA Control Reg. A - for Timer B
\par 
\par   DD00-DDFF  56576-56831           MOS 6526 Complex Interface Adapter
\par                                      (CIA) #2
\par 
\par   DD00       56576                 Data Port A (Serial Bus, RS-232, VIC
\par                                      Memory Control)
\par                             7      Serial Bus Data Input
\par                             6      Serial Bus Clock Pulse Input
\par                             5      Serial Bus Data Output
\par                             4      Serial Bus Clock Pulse Output
\par                             3      Serial Bus ATN Signal Output
\par                             2      RS-232 Data Output (User Port)
\par                             1-0    VIC Chip System Memory Bank Select
\par                                      (Default = 11)
\par 
\par   324   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   HEX      DECIMAL        BITS                 DESCRIPTION
\par   -------------------------------------------------------------------------
\par 
\par   DD01       56577                 Data Port B (User Port, RS-232)
\par                             7      User / RS-232 Data Set Ready
\par                             6      User / RS-232 Clear to Send
\par                             5      User
\par                             4      User / RS-232 Carrier Detect
\par                             3      User / RS-232 Ring Indicator
\par                             2      User / RS-232 Data Terminal Ready
\par                             1      User / RS-232 Request to Send
\par                             0      User / RS-232 Received Data
\par 
\par   DD02       56578                 Data Direction Register - Port A
\par   DD03       56579                 Data Direction Register - Port B
\par   DD04       56580                 Timer A: Low-Byte
\par   DD05       56581                 Timer A: High-Byte
\par   DD06       56582                 Timer B: Low-Byte
\par   DD07       56583                 Timer B: High-Byte
\par   DD08       56584                 Time-of-Day Clock: 1/10 Seconds
\par   DD09       56585                 Time-of-Day Clock: Seconds
\par   DD0A       56586                 Time-of-Day Clock: Minutes
\par   DD0B       56587                 Time-of-Day Clock: Hours + AM/PM Flag
\par                                      (Bit 7)
\par   DD0C       56588                 Synchronous Serial I/O Data Buffer
\par   DD0D       56589                 CIA Interrupt Control Register (Read
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     NMls/Write Mask)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            7        NMI Flag (1 = NMI Occurred) / Set-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                       Clear Flag
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            4        FLAG1 NMI (User/RS-232 Received Data
\par                                        Input)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            3        Serial Port Interrupt
\par                             1        Timer B Interrupt
\par                             0        Timer A Interrupt
\par 
\par   DD0E       56590                 CIA Control Register A
\par                             7      Time-of-Day Clock Frequency: 1 = 50 Hz,
\par                                      0 = 60 Hz
\par                             6      Serial Port I/O Mode Output, 0 = Input
\par                             5      Timer A Counts: 1 = CNT Signals,
\par                                      0 = System 02 Clock
\par                             4      Force Load Timer A: 1 = Yes
\par 
\par                                             BASIC TO MACHINE LANGUAGE   325
\par \page 
\par 
\par 
\par    HEX      DECIMAL        BITS                 DESCRIPTION
\par   -------------------------------------------------------------------------
\par 
\par                             3      Timer A Run Mode: 1 = One-Shot,
\par                                      0 = Continuous
\par                             2      Timer A Output Mode to PB6: 1 = Toggle,
\par                                      0 = Pulse
\par                             1      Timer A Output on PB6: 1 = Yes, 0 = No
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            0      Start/Stop Timer A: 1 = Start, 0 = Stop
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   DD0F       56591                 CIA Control Register B
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            7      Set Alarm/TOD-Clock: 1=Alarm, 0=Clock
\par                             6-5    Timer B Mode Select:
\par                                      00 = Count System 02 Clock Pulses
\par                                      01 = Count Positive CNT Transitions
\par                                      10 = Count Timer A Underflow Pulses
\par                                      11 = Count Timer A Underflows While
\par                                        CNT Positive
\par                             4-0    Same as CIA Control Reg. A - for Timer B
\par 
\par   DE00-DEFF  56832-57087           Reserved for Future I/O Expansion
\par   DF00-DFFF  57088-57343           Reserved for Future I/O Expansion
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  326   BASIC TO MACHINE LANGUAGE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                 CHAPTER 6
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                               INPUT/OUTPUT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                     GUIDE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Introduction
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Output to the TV
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o Output to Other Devices
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o The Game Ports
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o RS-232 Interface Description
\par                            o The User Port
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o The Serial Bus
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           o The Expansion Port
\par                            o Z-80 Microprocessor Cartridge
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     335
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   INTRODUCTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Computers have three basic abilities: they can calculate, make deci-
\par   sions, and communicate. Calculation is probably the easiest to program.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Most of the rules of mathematics are familiar to us. Decision making is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  not too difficult, since the rules of logic are relatively few, even if
\par   you don't know them too well yet.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Communication is the most complex, because it involves the least
\par   exacting set of rules. This is not an oversight in the design of
\par   computers. The rules allow enough flexibility to communicate virtually
\par   anything, and in many possible ways. The only real rule is this: whatever
\par   sends information must present the information so that it can be
\par   understood by the receiver.
\par 
\par 
\par   OUTPUT TO THE TV
\par 
\par     The simplest form of output in BASIC is the PRINT statement. PRINT uses
\par   the TV screen as the output device, and your eyes are the input device
\par   because they use the information on the screen.
\par     When PRINTing on the screen, your main objective is to format the
\par   information on the screen so it's easy to read. You should try to think
\par   like a graphic artist, using colors, placement of letters, capital and
\par   lower case letters, as well as graphics to best communicate the
\par   information. Remember, no matter how smart your program, you want to be
\par   able to understand what the results mean to you.
\par     The PRINT statement uses certain character codes as "commands" to the
\par   cursor. The <CRSR> key doesn't actually display anything, it just makes
\par   the cursor change position. Other commands change colors, clear the
\par   screen, and insert or delete spaces. The <RETURN> key has a character
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  code number (CHR$) of 13. A complete table of these codes is contained in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Appendix C.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    There are two functions in the BASIC language that work with the PRINT
\par   statement. TAB positions the,cursor on the given position from the left
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  edge of the screen, SPC moves the cursor right a given number of spaces
\par   from the current position.
\par     Punctuation marks in the PRINT statement serve to separate and format
\par   information. The semicolon (;) separates 2 items without any spaces in
\par   between. If it is the last thing on a line, the cursor remains after the
\par   last thing PRINTed instead of going down to the next line. It suppresses
\par 
\par 
\par 
\par   336   INPUT/OUTPUT GUIDE
\par \page 
\par 
\par 
\par   (replaces) the RETURN character that is normally PRINTed at the end of
\par   the line.
\par     The comma (,) separates items into columns. The Commodore 64 has 4
\par   columns of 10 characters each on the screen. When the computer PRINTs a
\par   comma, it moves the cursor right to the start of the next column. If it
\par   is past the last column of the line, it moves the cursor down to the next
\par   line. Like the semicolon, if it is the last item on a line the RETURN is
\par   suppressed.
\par     The quote marks ("") separate literal text from variables. The first
\par   quote mark on the line starts the literal area, and the next quote mark
\par   ends it. By the way, you don't have to have a final quote mark at the
\par   end of the line.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The RETURN code (CHR$ code of 13) makes the cursor go to the next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  logical line on the screen. This is not always the very next line. When
\par   you type past the end of a line, that line is linked to the next line.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The computer knows that both lines are really one long line. The links
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  are held in the line link table (see the memory map for how this is set
\par   up).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    A logical line can be 1 or 2 screen lines long, depending on what was
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  typed or PRINTed.  The logical line the cursor is on determines where the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  <RETURN> key sends it. The logical line at the top of the screen
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  determines if the screen scrolls 1 or 2 lines at a time. There are other
\par   ways to use the TV as an output device. The chapter on graphics describes
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the commands to create objects that move across the screen. The VIC chip
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  section tells how the screen and border colors and sizes are changed. And
\par   the sound chapter tells how the TV speaker creates music and special
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  effects.
\par 
\par   OUTPUT TO OTHER DEVICES
\par 
\par     It is often necessary to send output to devices other than the screen,
\par   like a cassette deck, printer, disk drive, or modem. The OPEN statement
\par   in BASIC creates a "channel" to talk to one of these devices. Once the
\par   channel is OPEN, the PRINT# statement will send characters to that
\par   device.
\par 
\par   EXAMPLE of OPEN and PRINT# Statements:
\par 
\par     100 OPEN 4,4: PRINT# 4, "WRITING ON PRINTER"
\par     110 OPEN 3,8,3,"0:DISK-FILE,S,W":PRINT#3,"SEND TO DISK"
\par     120 OPEN 1,1,1,"TAPE-FILE": PRINT#1,"WRITE ON TAPE"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    130 OPEN 2,2,0,CHR$(10):PRINT#2,"SEND TO MODEM"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                    INPUT/OUTPUT GUIDE   337
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The OPEN statement is somewhat different for each device. The pa-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  rameters in the OPEN statement are shown in the table below for each
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  device.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TABLE of OPEN Statement Parameters:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    FORMAT: OPEN file#, device#, number, string
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +--------+---------+---------------------+------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | DEVICE | DEVICE# |       NUMBER        |            STRING            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +--------+---------+---------------------+------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |CASSETTE|    1    | 0 = Input           | File Name                    |
\par   |        |         | 1 = Output          |                              |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |        |         | 2 = Output with EOT |                              |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | MODEM  |    2    | 0                   | Control Registers            |
\par   | SCREEN |    3    | 0,1                 |                              |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | PRINTER|  4 or 5 | 0 = Upper/Graphics  | Text Is PRINTed              |
\par   |        |         | 7 = Upper/Lower Case|                              |
\par   | DISK   | 8 to 11 | 2-14 = Data Channel | Drive #, File Name           |
\par   |        |         |                     | File Type, Read/Write        |
\par   |        |         | 15 = Command        | Command                      |
\par   |        |         |      Channel        |                              |
\par   +--------+---------+---------------------+------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  OUTPUT TO PRINTER
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The printer is an output device similar to the screen. Your main con-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cern when sending output to the printer is to create a format that is
\par   easy on the eyes. Your tools here include reversed, double-width, capital
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and lower case letters, as well as dot-programmable graphics.
\par     The SPC function works for the printer in the same way it works for the
\par   screen. However, the TAB function does not work correctly on the printer,
\par   because it calculates the current position on the line based on the
\par   cursor's position on the screen, not on the paper.
\par     The OPEN statement for the printer creates the channel for communi-
\par   cation. It also specifies which character set will be used, either upper
\par   case with graphics or upper and lower case.
\par 
\par   EXAMPLES of OPEN Statement for Printer:
\par 
\par     OPEN 1,4: REM UPPER CASE/GRAPHICS
\par     OPEN 1,4,7: REM UPPER AND LOWER CASE
\par 
\par   338   INPUT/OUTPUT GUIDE
\par \page 
\par 
\par 
\par     When working with one character set, individual lines can be PRINTed
\par   in the opposite character set. When in upper case with graphics, the
\par   cursor down character (CHR$(17)) switches the characters to the upper
\par   and lower case set. When in upper and lower case, the cursor up char-
\par   acter (CHR$(145)) allows upper case and graphics characters to be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PRINTed.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Other special functions in the printer are controlled through character
\par   codes. All these codes are simply PRINTed just like any other character.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TABLE of Printer Control Character Codes:
\par   +----------+------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | CHR$ CODE|                         PURPOSE                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------+------------------------------------------------------------+
\par   |    10    |   Line feed                                                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    13    |   RETURN (automatic line feed on CBM printers)             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    14    |   Begin double-width character mode                        |
\par   |    15    |   End double-width character mode                          |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    18    |   Begin reverse character mode                             |
\par   |   146    |   End reverse character mode                               |
\par   |    17    |   Switch to upper/lower case character set                 |
\par   |   145    |   Switch to upper case/graphics character set              |
\par   |    16    |   Tab to position in next 2 characters                     |
\par   |    27    |   Move to specified dot position                           |
\par   |     8    |   Begin dot-programmable graphic mode                      |
\par   |    26    |   Repeat graphics data                                     |
\par   +----------+------------------------------------------------------------+
\par     See your Commodore printer's manual for details on using the command
\par   codes.
\par 
\par   OUTPUT TO MODEM
\par 
\par     The modem is a simple device that can translate character codes into
\par   audio pulses and vice-versa, so that computers can communicate over
\par   telephone lines. The OPEN statement for the modem sets up the parameters
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to match the speed and format of the other computer you are communicating
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  with. Two characters can be sent in the string at the end
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of the OPEN statement.
\par     The bit positions of the first character code determine the baud rate,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  number of data bits, and number of stop bits. The second code is op-
\par   tional, and its bits specify the parity and duplex of the transmission.
\par   See the RS-232 section or your VICMODEM manual for specific details on
\par   this device.
\par 
\par                                                    INPUT/OUTPUT GUIDE   339
\par \page 
\par 
\par 
\par   EXAMPLE of OPEN Statement for Modem:
\par 
\par     OPEN 1,2,0,CHR$(6): REM 300 BAUD
\par     100 OPEN 2,2,0,CHR$(163) CHR$(112): REM 110 BAUD, ETC.
\par 
\par     Most computers use the American Standard Code for Information In-
\par   terchange, known as ASCII (pronounced ASK-KEY). This standard set of
\par   character codes is somewhat different from the codes used in the Com-
\par   modore 64. When communicating with other computers, the Commodore
\par   character codes must be translated into their ASCII counterparts. A table
\par   of standard ASCII codes is included in this book in Appendix C.
\par     Output to the modem is a fairly uncomplicated task, aside from the need
\par   for character translation. However, you must know the receiving device
\par   fairly well, especially when writing programs where your computer "talks"
\par   to another computer without human intervention. An example of this would
\par   be a terminal program that automatically types in your account number and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  secret password. To do this successfully, you must carefully count the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  number of characters and RETURN characters. Otherwise, the computer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  receiving the characters won't know what to do with them.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   WORKING WITH CASSETTE TAPE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Cassette tapes have an almost unlimited capacity for data. The longer
\par   the tape, the more information it can store. However, tapes are limited
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in time. The more data on the tape, the longer the time it takes to find
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the information.
\par     The programmer must try to minimize the time factor when working with
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  tape storage. One common practice is to read the entire cassette data
\par   file into RAM, then process it, and then re-write all the data on the
\par   tape. This allows you to sort, edit, and examine your data. However, this
\par   limits the size of your files to the amount of available RAM.
\par     If your data file is larger than the available RAM, it is probably time
\par   to switch to using the floppy disk. The disk can read data at any
\par   position on the disk, without needing to read through all the other data.
\par   You can write data over old data without disturbing the rest of the file.
\par   That's why the disk is used for all business applications like ledgers
\par   and mailing lists.
\par     The PRINT# statement formats data just like the PRINT statement does.
\par   All punctuation works the same. But remember, you're not working with the
\par   screen now. The formatting must be done with the INPUT# statement
\par   constantly in mind.
\par 
\par 
\par   340   INPUT/OUTPUT GUIDE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Consider the statement PRINT# 1, A$, B$, C$. When used with the screen,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the commas between the variables provide enough blank space between items
\par   to format them into columns ten characters wide. On cassette, anywhere
\par   from 1 to 10 spaces will be added, depending on th length of the strings.
\par   This wastes space on your tape.
\par     Even worse is what happens when the INPUT# statement tries to read
\par   these strings. The statement INPUT# 1, A$, B$, C$ will discover no data
\par   for B$ and C$. A$ will contain all three variables, plus the spaces be-
\par   tween them. What happens? Here's a look at the tape file:
\par 
\par     A$="DOG" B$="CAT" C$="TREE"
\par     PRINT# 1, A$, B$, C$
\par 
\par     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
\par     D O G                 C  A  T                       T  R  E  E  RETURN
\par 
\par     The INPUT# statement works like the regular INPUT statement. When
\par   typing data into the INPUT statement, the data items are separated,
\par   either by hitting the <RETURN> key or using commas to separate them. The
\par   PRINT# statement puts a RETURN at the end of a line just like the PRINT
\par   statement. A$ fills up with all three values because there's no separator
\par   on the tape between them, only after all three.
\par     A proper separator would be a comma (,) or a RETURN on the tape. The
\par   RETURN code is automatically put at the end of a PRINT or PRINT#
\par   statement. One way to put the RETURN code between each item is to us only
\par   one item per PRINT# statement. A better way is to set a variable to the
\par   RETURN CHR$ code, which is CHR$(13), or use a comma. The statement for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  this is R$=",":PRINT#1, A$ R$ B$ R$ C$. Don't use commas or any other
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  punctuation between the variable names, since the Commodore 64 can tell
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  them apart and they'll only use up space in your program.
\par     A proper tape file looks like this:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1 2 3 4 5 6 7 8 9 10 11 12 13
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    D O G , C A T , T  R  E  E  RETURN
\par 
\par     The GET# statement will pick data from the tape one character at a
\par   time. It will receive each character, including the RETURN code and other
\par   punctuation. The CHR$(0) code is received as an empty string, not as a
\par   one character string with a code of 0. If you try to use the ASC function
\par   on an empty string, you get the error message ILLEGAL QUANTITY ERROR.
\par 
\par 
\par                                                    INPUT/OUTPUT GUIDE   341
\par \page 
\par 
\par 
\par     The line GET# 1, A$: A= ASC(A$) is commonly used in programs to examine
\par   tape data. To avoid error messages, the line should be modified to
\par   GET#1, A$: A=ASC(A$+CHR$(0)). The CHR$(0) at the end acts as insurance
\par   against empty strings, but doesn't affect the ASC function when there are
\par   other characters in A$.
\par 
\par 
\par 
\par   DATA STORAGE ON FLOPPY DISKETTES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Diskettes allow 3 different forms of data storage. Sequential files are
\par   similar to those on tape, but several can can be used at the same time.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Relative files let you organize the data into records, and then read and
\par   replace individual records within the file. Random files let you work
\par   with data anywhere on the disk. They are organized into 256 byte sections
\par   called blocks.
\par     The PRINT# statement's limitations are discussed in the section on
\par   cassette tape. The same limitations to format apply on the disk. RETURNs
\par   or commas are needed to separate your data. The CHR$(0) is still read by
\par   the GET# statement as an empty string.
\par     Relative and random files both make use of separate data and command
\par   "channels." Data written to the disk goes through the data channel, where
\par   it is stored in a temporary buffer in the disk's RAM. When the record or
\par   block is complete, a command is sent through the command channel that
\par   tells the drive where to put the data, and the entire buffer is written.
\par     Applications that require large amounts of data to be processed are
\par   best stored in relative disk files. These will use the least amount of
\par   time and provide the best flexibility for the programmer. Your disk drive
\par   manual gives a complete programming guide to use of disk files.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   342   INPUT/OUTPUT GUIDE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  THE GAME PORTS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The Commodore 64 has two 9-pin Game Ports which allow the use of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  joysticks, paddies, or a light pen. Each port will accept either one joy-
\par   stick or one paddle pair. A light pen can be plugged into Port A (only)
\par   for special graphic control, etc. This section gives you examples of how
\par   to use the joysticks and paddies from both BASIC and machine language.
\par     The digital joystick is connected to CIA #1 (MOS 6526 Complex Interface
\par   Adapter). This input/output device also handles the paddle fire buttons
\par   and keyboard scanning. The 6526 CIA chip has 16 registers which are in
\par   memory locations 56320 through 56335 inclusive ($DC00 to $DC0F). Port A
\par   data appears at location 56320 (DC00) and Port B data is found at
\par   location 56321 ($DC01).
\par     A digital joystick has five distinct switches, four of the switches are
\par   used for direction and one of the switches is used for the fire button.
\par   The joystick switches are arranged as shown:
\par 
\par 
\par                                     (Top)
\par                 FIRE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {             (Switch 4)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                     UP
\par                                  (Switch 0)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par                                       |
\par                                       |
\par                          LEFT         |         RIGHT
\par                                -------+-------
\par                       (Switch 2)      |       (Switch 3)
\par                                       |
\par                                       |
\par                                       |
\par                                     DOWN
\par                                  (Switch 1)
\par 
\par 
\par     These switches correspond to the lower 5 bits of the data in location
\par   56320 or 56321. Normally the bit is set to a one if a direction is NOT
\par   chosen or the fire button is NOT pressed. When the fire button is
\par 
\par 
\par 
\par 
\par                                                    INPUT/OUTPUT GUIDE   343
\par \page 
\par 
\par 
\par   pressed, the bit (bit 4 in this case) changes to a 0. To read the
\par   joystick from BASIC, the following subroutine should be used:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par start tok64 page344.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 fork=0to10:rem set up direction string
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  20 readdr$(k):next
\par   30 data"","n","s","","w","nw"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  40 data"sw","","e","ne","se"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  50 print"going...";
\par   60 gosub100:rem read the joystick
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  65 ifdr$(jv)=""then80:rem check if a direction was chosen
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  70 printdr$(jv);" ";:rem output which direction
\par   80 iffr=16then60:rem check if fire button was pushed
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  90 print"-----f-----i-----r-----e-----!!!":goto60
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 jv=peek(56320):rem get joystick value
\par   110 fr=jvand16:rem form fire button status
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  120 jv=15-(jvand15):rem form direction value
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  130 return
\par stop tok64
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTE: For the second joystick, set JV = PEEK (56321).                 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The values for JV correspond to these directions:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                        +-------------+---------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       | JV EQUAL TO |   DIRECTION   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       +-------------+---------------+
\par                        |      0      |          NONE |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       |      1      |            UP |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       |      2      |          DOWN |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       |      3      |             - |
\par                        |      4      |          LEFT |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       |      5      |     UP & LEFT |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       |      6      |   DOWN & LEFT |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       |      7      |             - |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       |      8      |         RIGHT |
\par                        |      9      |    UP & RIGHT |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       |     10      |  DOWN & RIGHT |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       +-------------+---------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  344   INPUT/OUTPUT GUIDE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     A small machine code routine which accomplishes the same task is as
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  follows:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      ; joystick - button read routine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      ;
\par                       ; author - bill hindorff
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      ;
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {dx = $c110
\par dy = $c111
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {* = $c200
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {djrr    lda $dc00     ; get input from port a only
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {djrrb   ldy #0        ; this routine reads and decodes the
\par         ldx #0        ; joystick/firebutton input data in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        lsr a         ; the accumulator. this least significant
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        bcs djr0      ; 5 bits contain the switch closure
\par         dey           ; information. if a switch is closed then it
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {djr0    lsr a         ; produces a zero bit. if a switch is open then
\par         bcs djr1      ; it produces a one bit. The joystick dir-
\par         iny           ; ections are right, left, forward, backward
\par djr1    lsr a         ; bit3=right, bit2=left, bit1=backward,
\par         bcs djr2      ; bit0=forward and bit4=fire button.
\par         dex           ; at rts time dx and dy contain 2's compliment
\par djr2    lsr a         ; direction numbers i.e. $ff=-1, $00=0, $01=1.
\par         bcs djr3      ; dx=1 (move right), dx=-1 (move left),
\par         inx           ; dx=0 (no x change). dy=-1 (move up screen),
\par djr3    lsr a         ; dy=0 (move down screen), dy=0 (no y change).
\par         stx dx        ; the forward joystick position corresponds
\par         sty dy        ; to move up the screen and the backward
\par         rts           ; position to move down screen.
\par                       ;
\par                       ; at rts time the carry flag contains the fire
\par                       ; button state. if c=1 then button not pressed.
\par                       ; if c=0 then pressed.
\par .end
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                   INPUT/OUTPUT GUIDE   345
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PADDLES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     A paddle is connected to both CIA #1 and the SID chip (MOS 6581 Sound
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Interface Device) through a game port. The paddle value is read via the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SID registers 54297 ($D419) and 54298 ($D41A). PADDLES ARE NOT RELIABLE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  WHEN READ FROM BASIC ALONE!!!! The best way to use paddles, from BASIC or
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  machine code, is to use the following machine language routine... (SYS to
\par   it from BASIC then PEEK the memory locations used by the subroutine).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                       ; four paddle read routine (can also be used for two)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      ;
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      ; author - bill hindorff
\par                       ;
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {porta=$dc00
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {ciddra=$dc02
\par sid=$d400
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {*=$c100
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {buffer  *=*+1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {pdlx    *=*+2
\par pdly    *=*+2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {btna    *=*+1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {btnb    *=*+1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par * = $c000
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {pdlrd   ldx #1        ; for four paddles or two analog joysticks
\par pdlrd0                ; entry point for one pair (condition x 1st)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        sei
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        lda ciddra    ; get current value of ddr
\par         sta buffer    ; save it away
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        lda #$c0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        sta ciddra    ; set port a for input
\par         lda #$80
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {pdlrd1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        sta porta     ; address a pair of paddles
\par         ldy #$80      ; wait a while
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {pdlrd2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        nop
\par         dey
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        bpl pdlrd2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        lda sid+25    ; get x value
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        sta pdlx,x
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        lda sid+26
\par         sta pdly,x    ; get y value
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        lda porta     ; time to read paddle fire buttons
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        ora #80       ; make it the same as other pair
\par         sta btna      ; bit 2 is pdl x, bit 3 is pdl y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        lda #$40
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        dex           ; all pairs done?
\par         bpl pdlrd1    ; no
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        lda buffer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        sta ciddra    ; restore previous value of ddr
\par         lda porta+1   ; for 2nd pair -
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        sta btnb      ; bit 2 is pdl x, bit 3 is pdl y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        cli
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        rts
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {.end
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The paddles can be read by using the following BASIC program:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par start tok64 page347.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 c=12*4096:rem set paddle routine start
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  11 rem poke in the paddle reading routine
\par   15 fori=0to63:reada:pokec+i,a:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  20 sysc:rem call the paddle routine
\par   30 p1=peek(c+257):rem set paddle one value
\par   40 p2=peek(c+258):rem set paddle two value
\par   50 p3=peek(c+259):rem set paddle three value
\par   60 p4=peek(c+260):rem set paddle four value
\par   61 rem read fire button status
\par   62 s1=peek(c+261):s2=peek(c+262)
\par   70 printp1,p2,p3,p4:rem print paddle values
\par   72 rem print fire button status
\par   75 print:print"fire a ";s1,"fire b ";s2
\par   80 forw=1to50:next:rem wait a while
\par   90 print"\{clear\}":print:goto20:rem clear screen and do again
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  95 rem data for machine code routine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 data162,1,120,173,2,220,141,0,193,169,192,141,2,220,169
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  110 data128,141,0,220,160,128,234,136,16,252,173,25,212,157
\par   120 data1,193,173,26,212,157,3,193,173,0,220,9,128,141,5,193
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  130 data169,64,202,16,222,173,0,193,141,2,220,173,1,220,141
\par   140 data6,193,88,96
\par stop tok64
\par 
\par                                                    INPUT/OUTPUT GUIDE   347
\par \page 
\par 
\par 
\par   LIGHT PEN
\par 
\par     The light pen input latches the current screen position into a pair of
\par   registers (LPX, LPY) on a low-going edge. The X position register 19
\par   ($13) will contain the 8 MSB of the X position at the time of transition.
\par   Since the X position is defined by a 512-state counter (9 bits),
\par   resolution to 2 horizontal dots is provided. Similarly, the Y position is
\par   latched in its register 20 ($14), but here 8 bits provide single raster
\par   resolution within the visible display. The light pen latch may be
\par   triggered only once per frame, and subsequent triggers within the same
\par   frame will have no effect. Therefore, you must take several samples
\par   before turning the pen to the screen (3 or more samples average),
\par   depending upon the characteristics of your light pen.
\par 
\par 
\par 
\par   RS-232 INTERFACE DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  GENERAL OUTLINE
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The Commodore 64 has a built-in RS-232 interface for connection to any
\par   RS-232 modem, printer, or other device. To connect a device to the
\par   Commodore 64, all you need is a cable and a little bit of programming.
\par     RS-232 on the Commodore 64 is set-up in the standard RS-232 format, but
\par   the voltages are TTL levels (0 to 5V) rather than the normal RS-232 -12
\par   to 12 volt range. The cable between the Commodore 64 and the RS-232
\par   device should take care of the necessary voltage conversions. The
\par   Commodore RS-232 interface cartridge handles this properly.
\par     The RS-232 interface software can be accessed from BASIC or from the
\par   KERNAL for machine language programming.
\par     RS-232 on the BASIC level uses the normal BASIC commands: OPEN, CLOSE,
\par   CMD, INPUT#, GET#, PRINT#, and the reserved variable ST. INPUT# and GET#
\par   fetch data from the receiving buffer, while PRINT# and CMD place data
\par   into the transmitting buffer. The use of these commands (and examples)
\par   will be described in more detail later in this chapter.
\par     The RS-232 KERNAL byte and bit level handlers run under the control of
\par   the 6526 CIA #2 device timers and interrupts. The 6526 chip generates
\par 
\par 
\par 
\par 
\par 
\par 
\par   348   INPUT/OUTPUT GUIDE
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  NMI (Non-Maskable Interrupt) requests for RS-232 processing. This allows
\par   background RS-232 processing to take place during BASIC and machine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  language programs. There are built-in hold-offs in the KERNAL, cassette,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and serial bus routines to prevent the disruption of data storage or
\par   transmission by the NMIs that are generated by the RS-232 routines.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  During cassette or serial bus activities, data can NOT be received from
\par   RS-232 devices. But because these hold-offs are only local (assuming
\par   you're careful about your programming) no interference should result.
\par     There are two buffers in the Commodore 64 RS-232 interface to help
\par   prevent the loss of data when transmitting or receiving RS-232 informa-
\par   tion.
\par     The Commodore 64 RS-232 KERNAL buffers consist of two first-in/first-
\par   out (FIFO) buffers, each 256 bytes long, at the top of memory. The
\par   OPENing of an RS-232 channel automatically allocates 512 bytes of memory
\par   for these buffers. If there is not enough free space beyond the end of
\par   your BASIC program no error message will be printed, and the end of your
\par   program will be destroyed. SO BE CAREFUL!
\par     These buffers are automatically removed by using the CLOSE command.
\par 
\par 
\par   OPENING AN RS-232 CHANNEL
\par 
\par     Only one RS-232 channel should be open at any time; a second OPEN
\par   statement will cause the buffer pointers to be reset. Any characters in
\par   either the transmit buffer or the receive buffer will be lost.
\par     Up to 4 characters can be sent in the filename field. The first two are
\par   the control and command register characters; the other two are reserved
\par   for future system options. Baud rate, parity, and other options can be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  selected through this feature.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    No error-checking is done on the control word to detect a non-
\par   implemented baud rate. Any illegal control word will cause the system
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  output to operate at a very slow rate (below 50 baud).
\par 
\par   BASIC SYNTAX:
\par 
\par     OPEN lfn,2,0,"<control register><command register><opt baud low><opt
\par   baud high>"
\par     lfn-The logical file number (lfn) then can be any number from 1 through
\par   255. But be aware of the fact that if you choose a logical file number
\par   that is greater than 127, then a line feed will follow all carriage
\par   returns.
\par 
\par 
\par                                                    INPUT/OUTPUT GUIDE   349
\par \page 
\par 
\par 
\par                    +-+-+-+ +-+ +-+-+-+-+
\par                    |7|6|5| |4| |3|2|1|0|
\par                    +-+-+-+ +-+ +-+-+-+-+   BAUD RATE
\par                     | | |   |  +-+-+-+-+----------------+
\par       STOP BITS ----+ | |   |  |0|0|0|0| USER RATE  [NI]|
\par                       | |   |  +-+-+-+-+----------------+
\par    0 - 1 STOP BIT     | |   |  |0|0|0|1|       50 BAUD  |
\par    1 - 2 STOP BITS    | |   |  +-+-+-+-+----------------+
\par                       | |   |  |0|0|1|0|       75       |
\par                       | |   |  +-+-+-+-+----------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      | |   |  |0|0|1|1|      110       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      | |   |  +-+-+-+-+----------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     WORD LENGTH -----+-+   |  |0|1|0|0|      134.5     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                            |  +-+-+-+-+----------------+
\par   +---+-----------+         |  |0|1|0|1|      150       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |BIT|           |         |  +-+-+-+-+----------------+
\par   +-+-+    DATA   |         |  |0|1|1|0|      300       |
\par   |6|5|WORD LENGTH|         |  +-+-+-+-+----------------+
\par   +-+-+-----------+         |  |0|1|1|1|      600       |
\par   |0|0|  8 BITS   |         |  +-+-+-+-+----------------+
\par   +-+-+-----------+         |  |1|0|0|0|     1200       |
\par   |0|1|  7 BITS   |         |  +-+-+-+-+----------------+
\par   +-+-+-----------+         |  |1|0|0|1|    (1800)  2400|
\par   |1|0|  6 BITS   |         |  +-+-+-+-+----------------+
\par   +-+-+-----------+         |  |1|0|1|0|     2400       |
\par   |1|1|  5 BITS   |         |  +-+-+-+-+----------------+
\par   +-+-+-----------+         |  |1|0|1|1|     3600   [NI]|
\par                             |  +-+-+-+-+----------------+
\par                             |  |1|1|0|0|     4800   [NI]|
\par         UNUSED -------------+  +-+-+-+-+----------------+
\par                                |1|1|0|1|     7200   [NI]|
\par                                +-+-+-+-+----------------+
\par           Figure 6-1.          |1|1|1|0|     9600   [NI]|
\par      Control Register Map.     +-+-+-+-+----------------+
\par                                |1|1|1|1|    19200   [NI]|
\par                                +-+-+-+-+----------------+
\par     <control register>- Is a single byte character (see Figure 6-1, Control
\par   Register Map) required to specify the baud rates. If the lower 4 bits of
\par   the baud rate is equal to zero (0), the <opt baud low><opt baud high>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  characters give you a rate based on the following:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    <opt baud low>=<system frequency/rate/2-100-<opt baud high>*256
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    <opt baud high>=INT((system frequency/rate/2-100)/256
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   350   INPUT/OUTPUT GUIDE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                              +-+-+-+-+-+-+-+-+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                              |7|6|5|4|3|2|1|0|
\par                               +-+-+-+-+-+-+-+-+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                               | | | | | | | |
\par                                | | | | | | | |
\par                                | | | | | | | |
\par                                | | | | | | | |
\par             PARITY OPTIONS ----+-+-+ | | | | +----- HANDSHAKE
\par   +---+---+---+---------------------+| | | |
\par   |BIT|BIT|BIT|     OPERATIONS      || | | |        0 - 3-LINE
\par   | 7 | 6 | 5 |                     || | | |        1 - X-LINE
\par   +---+---+---+---------------------+| | | |
\par   | - | - | 0 |PARITY DISABLED, NONE|| | | |
\par   |   |   |   |GENERATED/RECEIVED   || | | |
\par   +---+---+---+---------------------+| | | +------- UNUSED
\par   | 0 | 0 | 1 |ODD PARITY           || | +--------- UNUSED
\par   |   |   |   |RECEIVER/TRANSMITTER || +----------- UNUSED
\par   +---+---+---+---------------------+|
\par   | 0 | 1 | 1 |EVEN PARITY          ||
\par   |   |   |   |RECEIVER/TRANSMITTER |+------------- DUPLEX
\par   +---+---+---+---------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 1 | 0 | 1 |MARK TRANSMITTED     |               0 - FULL DUPLEX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   |   |   |PARITY CHECK DISABLED|               1 - HALF DUPLEX
\par   +---+---+---+---------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 1 | 1 | 1 |SPACE TRANSMITTED    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   |   |   |PARITY CHECK DISABLED|
\par   +---+---+---+---------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                       Figure 6-2. Command Register Map.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The formulas above are based on the fact that:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    system frequency = 1.02273E6 NTSC (North American TV standard)
\par                      = 0.98525E6 PAL (U.K. and most European TV standard)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    <command register>- Is a single byte character (see Figure 6-2, Command
\par   Register Map) that defines other terminal parameters. This character is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  NOT required.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                     INPUT/OUTPUT GUIDE  351
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  KERNAL ENTRY:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     OPEN ($FFC0) (See KERNAL specifications for more information on entry
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  conditions and instructions.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par   | IMPORTANT NOTE: In a BASIC program, the RS-232 OPEN command should be |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | performed before creating any variables or arrays because an automatic|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | CLR is performed when an RS-232 channel is OPENed (This is due to the |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | allocation of 512 bytes at the top of memory.) Also remember that your|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | program will be destroyed if 512 bytes of space are not available at  |
\par   | the time of the OPEN statement.                                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   GETTING DATA FROM AN RS-232 CHANNEL
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When getting data from an RS-232 channel, the Commodore 64 receiver
\par   buffer will hold up to 255 characters before the buffer overflows. This
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is indicated in the RS-232 status word (ST in BASIC, or RSSTAT in machine
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  language). If an overflow occurs, then all characters received during a
\par   full buffer condition, from that point on, are lost. Obviously, it pays
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to keep the buffer as clear as possible.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    If you wish to receive RS-232 data at high speeds (BASIC can only go so
\par   fast, especially considering garbage collects. This can cause the re-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ceiver buffer to overflow), you will have to use machine language
\par   routines to handle this type of data burst.
\par 
\par   BASIC SYNTAX:
\par 
\par     Recommended: GET#lfn, <string variable>
\par     NOT Recommended: INPUT#lfn <variable list>
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  KERNAL ENTRIES:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     CHKIN ($FFC6)-See Memory Map for more information on entry and exit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  conditions.
\par     GETIN ($FFE4)-See Memory Map for more information on entry and exit
\par   conditions.
\par     CHRIN ($FFCF)-See Memory Map for more information on entry and exit
\par   conditions.
\par 
\par 
\par 
\par   352   INPUT/OUTPUT GUIDE
\par \page 
\par 
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTES:                                                                |
\par   |   If the word length is less than 8 bits, all unused bit(s) will be   |
\par   | assigned a value of zero.                                             |
\par   |   If a GET# does not find any data in the buffer, the character "" (a |
\par   | null) is returned.                                                    |
\par   |   If INPUT# is used, then the system will hang in a waiting condition |
\par   | until a non-null character and a following carriage return is         |
\par   | received. Therefore, if the Clear To Send (CTS) or Data Set Ready     |
\par   | (DSR) line(s) disappear during character INPUT#, the system will hang |
\par   | in a RESTORE-only state. This is why the INPUT# and CHRIN routines are|
\par   | NOT recommended.                                                      |
\par   |   The routine CHKIN handles the x-line handshake which follows the EIA|
\par   | standard (August 1979) for RS-232-C interfaces. (The Request To Send  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | (RTS), CTS, and Received line signal (DCD) lines are implemented with |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | the Commodore 64 computer defined as the Data Terminal device.)       |
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SENDING DATA TO AN RS-232 CHANNEL
\par 
\par     When sending data, the output buffer can hold 255 characters before a
\par   full buffer hold-off occurs. The system will wait in the CHROUT routine
\par   until transmission is allowed or the <RUN/STOP> and <RESTORE> keys are
\par   used to recover the system through a WARM START.
\par 
\par 
\par   BASIC SYNTAX:
\par 
\par     CMD lfn-acts same as in the BASIC specifications.
\par     PRINT#lfn,<variable list>
\par 
\par 
\par   KERNAL ENTRIES:
\par 
\par     CHKOUT ($FFC9)-See Memory Map for more information on entry and exit
\par   conditions.
\par     CHROUT ($FFD2)-See Memory Map for more information on entry conditions.
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                   INPUT/OUTPUT GUIDE   353
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par   | IMPORTANT NOTES: There is no carriage-return delay built into the     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | output channel. This means that a normal RS-232 printer cannot        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | correctly print, unless some form of hold-off (asking the Commodore 64|
\par   | to wait) or internal buffering is implemented by the printer. The     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | hold-off can easily be implemented in your program. If a CTS (x-line) |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | handshake is implemented, the Commodore 64 buffer will fill, and then |
\par   | hold-off more output until transmission is allowed by the RS-232      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | device. X-line handshaking is a handshake routine that uses multi-    |
\par   | lines for receiving and transmitting data.                            |
\par   |   The routine CHKOUT handles the x-line handshake, which follows the  |
\par   | EIA standard (August 1979) for RS-232-C interfaces. The RTS, CTS, and |
\par   | DCD lines are implemented with the Commodore 64 defined as the Data   |
\par   | Terminal Device.                                                      |
\par   +-----------------------------------------------------------------------+
\par 
\par   CLOSING AN RS-232 DATA CHANNEL
\par 
\par     Closing an RS-232 file discards all data in the buffers at the time of
\par   execution (whether or not it had been transmitted or printed out), stops
\par   all RS-232 transmitting and receiving, sets the RTS and transmitted data
\par   (Sout) lines high, and removes both RS-232 buffers.
\par 
\par 
\par   BASIC SYNTAX:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    CLOSE lfn
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  KERNAL ENTRY:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    CLOSE ($FFC3)-See Memory Map for more information on entry and exit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  conditions.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par   | NOTE: Care should be taken to ensure all data is transmitted before   |
\par   | closing the channel. A way to check this from BASIC is:               |
\par   |                                                                       |
\par   | 100 SS=ST: IF(SS=0 OR SS=8) THEN 100                                  |
\par   | 110 CLOSE lfn                                                         |
\par   +-----------------------------------------------------------------------+
\par 
\par 
\par   354   INPUT/OUTPUT GUIDE
\par \page 
\par 
\par 
\par                          Table 6-1. User-Port Lines
\par   +-----------------------------------------------------------------------+
\par   |                   (6526 DEVICE #2 Loc. $DD00-$DD0F)                   |
\par   +---+-----+----------------------+------+-------+-------+---------------+
\par   |PIN| 6526|      DESCRIPTION     | EIA  |  ABV  |  IN/  |     MODES     |
\par   | ID|  ID |                      |      |       |  OUT  |               |
\par   +---+-----+----------------------+------+-------+-------+---------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | C | PB0 | RECEIVED DATA        | (BB) |  Sin  |  IN   |     1 2       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | D | PB1 | REQUEST TO SEND      | (CA) |  RTS  |  OUT  |     1*2       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | E | PB2 | DATA TERMINAL READY  | (CD) |  DTR  |  OUT  |     1*2       |
\par   | F | PB3 | RING INDICATOR       | (CE) |  RI   |  IN   |         3     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | H | PB4 | RECEIVED LINE SIGNAL | (CF) |  DCD  |  IN   |       2       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | I | PB5 | UNASSIGNED           | (  ) |  XXX  |  IN   |         3     |
\par   | K | PB6 | CLEAR TO SEND        | (CB) |  CTS  |  IN   |       2       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | L | PB7 | DATA SET READY       | (CC) |  DSR  |  IN   |       2       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   |     |                      |      |       |       |               |
\par   | B |FLAG2| RECEIVED DATA        | (BB) |  Sin  |  IN   |     1 2       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | M | PA2 | TRANSMITTED DATA     | (BA) |  Sout |  OUT  |     1 2       |
\par   |   |     |                      |      |       |       |               |
\par   | A | GND | PROTECTIVE GROUND    | (AA) |  GND  |       |     1 2       |
\par   | N | GND | SIGNAL GROUND        | (AB) |  GND  |       |     1 2 3     |
\par   +---+-----+----------------------+------+-------+-------+---------------+
\par   | MODES:                                                                |
\par   | 1) 3-LINE INTERFACE (Sin,Sout,GND)                                    |
\par   | 2) X-LINE INTERFACE                                                   |
\par   | 3) USER AVAILABLE ONLY (Unused/unimplemented in code.)                |
\par   | * These lines are held high during 3-LINE mode.                       |
\par   +-----------------------------------------------------------------------+
\par   +-----------------------------------------------------------------------+
\par   | [7] [6] [5] [4] [3] [2] [1] [0] (Machine Lang.-RSSTAT                 |
\par   |  |   |   |   |   |   |   |   +- PARITY ERROR BIT                      |
\par   |  |   |   |   |   |   |   +----- FRAMING ERROR BIT                     |
\par   |  |   |   |   |   |   +--------- RECEIVER BUFFER OVERRUN BIT           |
\par   |  |   |   |   |   +------------- RECEIVER BUFFER-EMPTY                 |
\par   |  |   |   |   |                  (USE TO TEST AFTER A GET#)            |
\par   |  |   |   |   +----------------- CTS SIGNAL MISSING BIT                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  |   |   +--------------------- UNUSED BIT                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  |   +------------------------- DSR SIGNAL MISSING BIT                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  +----------------------------- BREAK DETECTED BIT                    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |                                                                       |
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     Figure 6-3. RS-232 Status Register.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                    INPUT/OUTPUT GUIDE   355
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTES:                                                                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   If the BIT=0, then no error has been detected.                      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   The RS-232 status register can be read from BASIC using the variable|
\par   | ST.                                                                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   If ST is read by BASIC or by using the KERNAL READST routine the    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | RS-232 status word is cleared when you exit. If multiple uses of the  |
\par   | STATUS word are necessary the ST should be assigned to another        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | variable. For example:                                                |
\par   |                                                                       |
\par   | SR=ST: REM ASSIGNS ST TO SR                                           |
\par   |                                                                       |
\par   |   The RS-232 status is read (and cleared) only when the RS-232 channel|
\par   | was the last external I/O used.                                       |
\par   +-----------------------------------------------------------------------+
\par 
\par   SAMPLE BASIC PROGRAMS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {start tok64 page356.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 rem this program sends and receives data to/from a silent 700
\par   11 rem terminal modified for pet ascii
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  20 rem ti silent 700 set-up: 300 baud, 7-bit ascii, mark parity,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  21 rem full duplex
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  30 rem same set-up at computer using 3-line interface
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 open2,2,3,chr$(6+32)+chr$(32+128):rem open the channel
\par   110 get#2,a$:rem turn on the receiver channel (toss a null)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  200 rem main loop
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  210 get b$:rem get from computer keyboard
\par   220 if b$<>""then print#2,b$;:rem if a key pressed, send to terminal
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  230 get#2,c$:rem get a key from the terminal
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  240 print b$;c$;:rem print all inputs to computer screen
\par   250 sr=st:ifsr=0orsr=8then200:rem check status, if good then continue
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  300 rem error reporting
\par   310 print "error: ";
\par   320 if sr and 1 then print"parity"
\par   330 if sr and 2 then print"frame"
\par   340 if sr and 4 then print"receiver buffer full"
\par   350 if sr and 128 then print"break"
\par   360 if (peek(673)and1)then360:rem wait until all chars transmitted
\par   370 close 2:end
\par stop tok64
\par 
\par 
\par   356   INPUT/OUTPUT GUIDE
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {start tok64 page357.prg
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 rem this program sends and receives true ascii data
\par   100 open 5,2,3,chr$(6)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  110 dim f%(255),t%(255)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  200 for j=32 to 64:t%(j)=j:next
\par   210 t%(13)=13:t%(20)=8:rv=18:ct=0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  220 for j=65 to 90:k=j+32:t%=(j)=k:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  230 for j=91 to 95:t%(j)=j:next
\par   240 for j=193 to 218:k=j-128:t%(j)=k:next
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  250 t%(146)=16:t%(133)=16
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  260 for j=0 to 255
\par   270 k=t%(j)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  280 if k<>0then f%(k)=j:f%(k+128)=j
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  290 next
\par   300 print" "chr$(147)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  310 get#5,a$
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  320 if a$=""or st<>0 then 360
\par   330 print" "chr$(157);chr$(f%(asc(a$)));
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  340 if f%(asc(a$))=34 then poke212,0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  350 goto310
\par   360 printchr$(rv)" "chr$(157);chr$(146);:get a$
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  370 if a$<>""then print#5,chr$(t%(asc(a$)));
\par   380 ct=ct+1
\par   390 if ct=8 thenct=0:rv=164-rv
\par   410 goto310
\par stop tok64
\par 
\par 
\par   RECEIVER/TRANSMITTER BUFFER BASE LOCATION POINTERS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     $00F7-REBUF-A two-byte pointer to the Receiver Buffer base location.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    $00F9-ROBUF-A two-byte pointer to the Transmitter Buffer base location.
\par 
\par     The two locations above are set up by the OPEN KERNAL routine, each
\par   pointing to a different 256-byte buffer. They are de-allocated by writing
\par   a zero into the high order bytes ($00F8 and $00FA), which is done by the
\par   CLOSE KERNAL entry. They may also be allocated/de-allocated by the
\par   machine language programmer for his/her own purposes, removing/creating
\par   only the buffer(s) required. When using a machine language program that
\par   allocates these buffers, care must be taken to make sure that the top of
\par   memory pointers stay correct, especially if BASIC programs are expected
\par   to run at the same time.
\par                                                    INPUT/OUTPUT GUIDE   357
\par \page 
\par 
\par 
\par   ZERO-PAGE MEMORY LOCATIONS AND USAGE FOR
\par   RS-232 SYSTEM INTERFACE
\par 
\par     $00A7-INBIT-Receiver input bit temp storage.
\par     $00A8-BITCI-Receiver bit count in.
\par     $00A9-RINONE-Receiver flag Start bit check.
\par     $00AA-RIDATA-Receiver byte buffer/assembly location.
\par     $00AB-RIPRTY-Receiver parity bit storage.
\par     $00B4-BITTS-Transmitter bit count out.
\par     $00B5-NXTBIT-Transmitter next bit to be sent.
\par     $00B6-RODATA-Transmitter byte buffer/disassembly location.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     All the above zero-page locations are used locally and are only given
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  as a guide to understand the associated routines. These cannot be used
\par   directly by the BASIC or KERNAL level programmer to do RS-232 type
\par   things. The system RS-232 routines must be used.
\par 
\par 
\par   NONZERO-PAGE MEMORY LOCATIONS AND USAGE FOR
\par   RS-232 SYSTEM INTERFACE
\par 
\par 
\par     General RS-232 storage:
\par 
\par     $0293-M51CTR-Pseudo 6551 control register (see Figure 6-1).
\par     $0294-M51COR-Pseudo 6551 command register (see Figure 6-2) .
\par     $0295-M51AJB-Two bytes following the control and command registers in
\par           the file name field. These locations contain the baud rate for
\par           the start of the bit test during the interface activity, which,
\par           in turn, is used to calculate baud rate.
\par     $0297-RSSTAT-The RS-232 status register (see Figure 6-3).
\par     $0298-BITNUM-The number of bits to be sent/received.
\par     $0299-BAUDOF-Two bytes that are equal to the time of one bit cell.
\par           (Based on system clock/baud rate.)
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  358   INPUT/OUTPUT GUIDE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    $029B-RIDBE-The byte index to the end of the receiver FIFO buffer.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    $029C-RIDBS-The byte index to the start of the receiver FIFO buffer.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    $029D-RODBS-The byte index to the start of the transmitter FIFO buffer.
\par     $029E-RODBE-The byte index to the end of the transmitter FIFO buffer.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    $02A1-ENABL-Holds current active interrupts in the CIA #2 ICR.
\par           When bit 4 is turned on means that the system is waiting for the
\par           Receiver Edge. When bit 1 is turned on then the system is
\par           receiving data. When bit 0 is turned on then the system is
\par           transmitting data.
\par 
\par 
\par 
\par 
\par   THE USER PORT
\par 
\par     The user port is meant to connect the Commodore 64 to the outside
\par   world. By using the lines available at this port, you can connect the
\par   Commodore 64 to a printer, a Votrax Type and Talk, a MODEM, even another
\par   computer.
\par     The port on the Commodore 64 is directly connected to one of the 6526
\par   CIA chips. By programming, the CIA will connect to many other devices.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PORT PIN DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                              1 1 1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           1 2 3 4 5 6 7 8 9 0 1 2
\par                         +--@-@-@-@-@-@-@-@-@-@-@-@--+
\par                         |                           |
\par                         +--@-@-@-@-@-@-@-@-@-@-@-@--+
\par                            A B C D E F H J K L M N
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                                    INPUT/OUTPUT GUIDE   359
\par \page 
\par 
\par 
\par                             PORT PIN DESCRIPTION
\par   +-----------+-----------+-----------------------------------------------+
\par   |    PIN    |           |                                               |
\par   +-----------+DESCRIPTION|                     NOTES                     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | TOP SIDE  |           |                                               |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------+-----------+-----------------------------------------------+
\par   |     1     |  GROUND   |                                               |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     2     |   +5V     |  (100 mA MAX.)                                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     3     |  RESET    |  By grounding this pin, the Commodore 64 will |
\par   |           |           |  do a COLD START, resetting completely. The   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |           |  pointers to a BASIC program will be reset,   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           |           |  but memory will not be cleared. This is also |
\par   |           |           |  a RESET output for the external devices.     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     4     |    CNT1   |  Serial port counter from CIA#1(SEE CIA SPECS)|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     5     |    SP1    |  Serial port from CIA #l (SEE 6526 CIA SPECS) |
\par   |     6     |    CNT2   |  Serial port counter from CIA#2(SEE CIA SPECS)|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     7     |    SP2    |  Serial port from CIA #l (SEE 6526 CIA SPECS) |
\par   |     8     |    PC2    |  Handshaking line from CIA #2 (SEE CIA SPECS) |
\par   |     9     |SERIAL ATN |  This pin is connected to the ATN line of the |
\par   |           |           |  serial bus.                                  |
\par   |    10     |9 VAC+phase|  Connected directly to the Commodore          |
\par   |    11     |9 VAC-phase|  64 transformer (50 mA MAX.).                 |
\par   |    12     |    GND    |                                               |
\par   |           |           |                                               |
\par   |BOTTOM SIDE|           |                                               |
\par   |           |           |                                               |
\par   |     A     |    GND    |  The Commodore 64 gives you control over      |
\par   |     B     |   FLAG2   |  PORT B on CIA chip #1. Eight lines for input |
\par   |     C     |    PB0    |  or output are available, as well as 2 lines  |
\par   |     D     |    PB1    |  for handshaking with an outside device. The  |
\par   |     E     |    PB2    |  I/O lines for PORT B are controlled by two   |
\par   |     F     |    PB3    |  locations. One is the PORT itself, and is    |
\par   |     H     |    PB4    |  located at 56577 ($DD01 HEX). Naturally you  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     I     |    PB5    |  PEEK it to read an INPUT, or POKE it to set  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     K     |    PB6    |  an OUTPUT. Each of the eight I/O lines can   |
\par   |     L     |    PB7    |  be set up as either an INPUT or an OUTPUT by |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     M     |    PA2    |  by setting the DATA DIRECTION REGISTER       |
\par   |     N     |    GND    |  properly.                                    |
\par   +-----------+-----------+-----------------------------------------------+
\par 
\par 
\par 
\par 
\par   360   INPUT/OUTPUT GUIDE
\par \page 
\par 
\par 
\par     The DATA DIRECTION REGISTER has its location at 56579 ($DD03 hex). Each
\par   of the eight lines in the PORT has a BIT in the eight-bit DATA DIRECTION
\par   REGISTER (DDR) which controls whether that line will be an input or an
\par   output. If a bit in the DDR is a ONE, the corresponding line of the PORT
\par   will be an OUTPUT. If a bit in the DDR is a ZERO, the corresponding line
\par   of the PORT will be an INPUT. For example, if bit 3 of the DDR is set to
\par   1, then line 3 of the PORT will be an output. A further example:
\par     If the DDR is set like this:
\par 
\par                           BIT #: 7 6 5 4 3 2 1 0
\par                           VALUE: 0 0 1 1 1 0 0 0
\par 
\par   You can see that lines 5,4, and 3 will be outputs since those bits are
\par   ones. The rest of the lines will be inputs, since those lines are zeros.
\par     To PEEK or POKE the USER port, it is necessary to use both the DDR and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the PORT itself.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Remember that the PEEK and POKE statements want a number from 0-255.
\par   The numbers given in the example must be translated into decimal before
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  they can be used. The value would be:
\par 
\par                      2^5 + 2^4 + 2^3 = 32 + 16 + 8 = 56
\par 
\par   Notice that the bit # for the DDR is the same number that = 2 raised to
\par   a power to turn the bit value on.
\par 
\par                       (16 = 2^4=2*2*2*2, 8 = 2^3=2*2*2)
\par 
\par     The two other lines, FLAG1 and PA2 are different from the rest of the
\par   USER PORT. These two lines are mainly for HANDSHAKING, and are programmed
\par   differently from port B.
\par     Handshaking is needed when two devices communicate. Since one device
\par   may run at a different speed than another device it is necessary to give
\par   the devices some way of knowing what the other device is doing. Even when
\par   the devices are operating at the same speed, handshaking is necessary to
\par   let the other know when data is to be sent, and if it has been received.
\par   The FLAG1 line has special characteristics which make it well suited for
\par   handshaking.
\par     FLAG1 is a negative edge sensitive input which can be used as a general
\par   purpose interrupt input. Any negative transition on the FLAG line will
\par   set the FLAG interrupt bit. If the FLAG interrupt is enabled, this will
\par 
\par 
\par 
\par                                                    INPUT/OUTPUT GUIDE   361
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cause an INTERRUPT REQUEST. If the FLAG bit is not enabled, it can be
\par   polled from the interrupt register under program control.
\par     PA2 is bit 2 of PORT A of the CIA. It is controlled like any other bit
\par   in the port. The port is located at 56576 ($DD00). The data direction
\par   register is located at 56578 ($DD02.)
\par     FOR MORE INFORMATION ON THE 6526 SEE THE CHIP SPECIFICATIONS IN
\par   APPENDIX M.
\par 
\par 
\par   THE SERIAL BUS
\par 
\par     The serial bus is a daisy chain arrangement designed to let the Com-
\par   modore 64 communicate with devices such as the VIC-1541 DISK DRIVE and
\par   the VIC-1525 GRAPHICS PRINTER. The advantage of the serial bus is that
\par   more than one device can be connected to the port. Up to 5 devices can be
\par   connected to the serial bus at one time.
\par     There are three types of operation over a serial bus-CONTROL, TALK, and
\par   LISTEN. A CONTROLLER device is one which controls operation of the serial
\par   bus. A TALKER transmits data onto the bus. A LISTENER receives data from
\par   the bus.
\par     The Commodore 64 is the controller of the bus. It also acts as a TALKER
\par   (when sending data to the printer, for example) and as a LISTENER (when
\par   loading a program from the disk drive, for example). Other devices may be
\par   either LISTENERS (the printer), TALKERS, or both (the disk drive). Only
\par   the Commodore 64 can act as the controller.
\par     All devices connected on the serial bus will receive all the data
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  transmitted over the bus. To allow the Commodore 64 to route data to its
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  intended destination, each device has a bus ADDRESS. By using this device
\par   address, the Commodore 64 can control access to the bus. Addresses on the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  serial bus range from 4 to 31.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The Commodore 64 can COMMAND a particular device to TALK or LISTEN.
\par   When the Commodore 64 commands a device to TALK, the device will begin
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  putting data onto the serial bus. When the Commodore 64 commands a device
\par   to LISTEN, the device addressed will get ready to receive data (from the
\par   Commodore 64 or from another device on the bus). Only one device can TALK
\par   on the bus at a time; otherwise, the data will collide and the system
\par   will crash in confusion. However, any number of devices can LISTEN at the
\par   same time to one TALKER.
\par 
\par 
\par 
\par 
\par 
\par   362   INPUT/OUTPUT GUIDE
\par \page 
\par 
\par 
\par                          COMMON SERIAL BUS ADDRESSES
\par                     +--------+--------------------------+
\par                     | NUMBER |        DEVICE            |
\par                     +--------+--------------------------+
\par                     | 4 or 5 | VIC-1525 GRAPHIC PRINTER |
\par                     | 8      | VIC-1541 DISK DRIVE      |
\par                     +--------+--------------------------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Other device addresses are possible. Each device has its own address.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Certain devices (like the Commodore 64 printer) provide a choice between
\par   two addresses for the convenience of the user.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The SECONDARY ADDRESS is to let the Commodore 64 transmit setup
\par   information to a device. For example, to OPEN a connection on the bus to
\par   the printer, and have it print in UPPER/LOWER case, use the following
\par 
\par     OPEN 1,4,7
\par 
\par   where,
\par     1 is the logical file number (the number you PRINT# to),
\par     4 is the ADDRESS of the printer, and
\par     7 is the SECONDARY ADDRESS that tells the printer to go into UPPER/
\par       LOWER case mode.
\par 
\par     There are 6 lines used in serial bus operations - input and 3 output.
\par   The 3 input lines bring data, control, and timing signals into the Com-
\par   modore 64. The 3 output lines send data, control, and timing signals from
\par   the Commodore 64 to external devices on the serial bus.
\par 
\par   Serial I/O
\par                                                        ++ ++
\par   +-------+----------------------+                    / +-+ \\
\par   |  Pin  |         Type         |                   /5     1\\
\par   +-------+----------------------+                  +  O   O  +
\par   |   1   |  /SERIAL SRQ IN      |                  |    6    |
\par   |   2   |  GND                 |                  |    O    |
\par   |   3   |  SERIAL ATN OUT      |                  |         |
\par   |   4   |  SERIAL CLK IN/OUT   |                  +  O   O  +
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   5   |  SERIAL DATA IN/OUT  |                   \\4  O  2/
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   6   |  /RESET              |                    \\  3  /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------+----------------------+                     +---+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                   INPUT/OUTPUT GUIDE   363
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SERIAL SRQ IN: (SERIAL SERVICE REQUEST IN)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Any device on the serial bus can bring this signal LOW when it requires
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  attention from the Commodore 64. The Commodore 64 will then take care of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the device. (See Figure 6-4).
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          [THE PICTURE IS MISSING!]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                         Figure 6-4. Serial Bus Timing.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  364   INPUT/OUTPUT GUIDE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SERIAL ATN OUT: (SERIAL ATTENTION OUT)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The Commodore 64 uses this signal to start a command sequence for a
\par   device on the serial bus. When the Commodore 64 brings this signal LOW,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  all other devices on the bus start listening for the Commodore 64 to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  transmit an address. The device addressed must respond in a preset period
\par   of time; otherwise, the Commodore 64 will assume that the device
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  addressed is not on the bus, and will return an error in the STATUS WORD.
\par   (See Figure 6-4).
\par 
\par 
\par 
\par                           [THE PICTURE IS MISSING!]
\par 
\par 
\par                               SERIAL BUS TIMING
\par   +-----------------------------+-------+-------+-------+-----------------+
\par   |     Description             | Symbol|  Min. |  Typ. |       Max.      |
\par   +-----------------------------+-------+-------+-------+-----------------+
\par   | ATN RESPONSE (REQUIRED) (1) |  Tat  |   -   |   -   |     1000us      |
\par   | LISTENER HOLD-OFF           |  Th   |   0   |   -   |    infinite     |
\par   | NON-EOI RESPONSE TO RFD (2) |  Tne  |   -   |  40us |      200us      |
\par   | BIT SET-UP TALKER (4)       |  Ts   |  20us |  70us |        -        |
\par   | DATA VALID                  |  Tv   |  20us |  20us |        -        |
\par   | FRAME HANDSHAKE (3)         |  Tf   |   0   |  20   |     1000us      |
\par   | FRAME TO RELEASE OF ATN     |  Tr   |  20us |   -   |        -        |
\par   | BETWEEN BYTES TIME          |  Tbb  | 100us |   -   |        -        |
\par   | EOI RESPONSE TIME           |  Tye  | 200us | 250us |        -        |
\par   | EOI RESPONSE HOLD TIME (5)  |  Tei  |  60us |   -   |        -        |
\par   | TALKER RESPONSE LIMIT       |  Try  |   0   |  30us |       60us      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | BYTE-ACKNOWLEDGE (4)        |  Tpr  |  20us |  30us |        -        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | TALK-ATTENTION RELEASE      |  Ttk  |  20us |  30us |      100us      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | TALK-ATTENTION ACKNOWLEDGE  |  Tdc  |   0   |   -   |        -        |
\par   | TALK-ATTENTION ACK. HOLD    |  Tda  |  80us |   -   |        -        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | EOI ACKNOWLEDGE             |  Tfr  |  60us |   -   |        -        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------+-------+-------+-------+-----------------+
\par      Notes:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     1. If maximum time exceeded, device not present error.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     2. If maximum time exceeded, EOI response required.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     3. If maximum time exceeded, frame error.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     4. Tv and Tpr minimum must be 60us for external device to be a talker.
\par      5. Tei minimum must be 80us for external device to be a listener.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                   INPUT/OUTPUT GUIDE   365
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SERIAL CLK IN/OUT: (SERIAL CLOCK IN/OUT)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     This signal is used for timing the data sent on the serial bus. (See
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Figure 6-4).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SERIAL DATA IN/OUT:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Data on the serial bus is transmitted one bit at a time on this line.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (See Figure 6-4.)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   THE EXPANSION PORT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The expansion connector is a 44-pin (22122) female edge connector on
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the back of the Commodore 64. With the Commodore 64 facing you, the
\par   expansion connector is on the far right of the back of the computer. To
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  use the connector, a 44-pin (22/22) male edge connector is required.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This port is used for expansions of the Commodore 64 system which
\par   require access to the address bus or the data bus of the computer.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Caution is necessary when using the expansion bus, because it's possible
\par   to damage the Commodore 64 by a malfunction of your equipment.
\par     The expansion bus is arranged as follows:
\par                  2 2 2 1 1 1 1 1 1 1 1 1 1
\par                  2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1
\par              +---@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@---+
\par              |                                                 |
\par              +---@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@---+
\par                  Z Y X W V U T S R P N M L K J H F E D C B A
\par 
\par     The signals available on the connector are as follows:
\par   +---------+---+---------------------------------------------------------+
\par   |   NAME  |PIN|                       DESCRIPTION                       |
\par   +---------+---+---------------------------------------------------------+
\par   |   GND   | 1 |  System ground                                          |
\par   |  +5VDC  | 2 |  (Total USER PORT and CARTRIDGE devices can             |
\par   |  +5VDC  | 3 |  draw no more than 450 mA.)                             |
\par   |  /IRQ   | 4 |  Interrupt Request line to 6502 (active low)            |
\par   |   R/W   | 5 |  Read/Write (write active low)                          |
\par   |DOT CLOCK| 6 |  8.18 MHz video dot clock                               |
\par   |  /I/O1  | 7 |  I/O block 1 @ $ DE00-$DEFF (active low) unbuffered I/O |
\par   |  /GAME  | 8 |  active low ls ttl input                                |
\par   |  /EXROM | 9 |  active low ls ttl input                                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  /I/O2  |10 |  I/O block 2 @ $DF00-$DFFF (active low) buff'ed ls ttl  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                                  output  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  366   INPUT/OUTPUT GUIDE
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +---------+---+---------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   NAME  |PIN|                       DESCRIPTION                       |
\par   +---------+---+---------------------------------------------------------+
\par   |  /ROML  |11 |  8K decoded RAM/ROM block @ $8000 (active low) buffered |
\par   |         |   |  ls ttl output                                          |
\par   |   BA    |12 |  Bus available signal from the VIC-II chip unbuffered   |
\par   |         |   |    1 Is load max.                                       |
\par   |  /DMA   |13 |  Direct memory access request line (active low input)   |
\par   |         |   |  ls ttl input                                           |
\par   |   D7    |14 |  Data bus bit 7 \\                                       |
\par   |   D6    |15 |  Data bus bit 6  +                                      |
\par   |   D5    |16 |  Data bus bit 5  |                                      |
\par   |   D4    |17 |  Data bus bit 4  +-  unbuffered, 1 ls ttl load max      |
\par   |   D3    |18 |  Data bus bit 3  +-                                     |
\par   |   D2    |19 |  Data bus bit 2  |                                      |
\par   |   D1    |20 |  Data bus bit 1  +                                      |
\par   |   D0    |21 |  Data bus bit 0 /                                       |
\par   |   GND   |22 |  System ground                                          |
\par   |   GND   | A |                                                         |
\par   |  /ROMH  | B |  8K decoded RAM/ROM block @ $E000 buffered              |
\par   |  /RESET | C |  6502 RESET pin(active low) buff'ed ttl out/unbuff'ed in|
\par   |  /NMI   | D |  6502 Non Maskable Interrupt (active low) buff'ed ttl   |
\par   |         |   |  out, unbuff'ed in                                      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   02    | E |  Phase 2 system clock                                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   A15   | F |  Address bus bit 15 \\                                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   A14   | H |  Address bus bit 14  +                                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   A13   | J |  Address bus bit 13  |                                  |
\par   |   A12   | K |  Address bus bit 12  |                                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   A11   | L |  Address bus bit 11  |                                  |
\par   |   A10   | M |  Address bus bit 10  |                                  |
\par   |   A9    | N |  Address bus bit 9   |                                  |
\par   |   A8    | P |  Address bus bit 8   +--  unbuffered, 1 ls ttl load max |
\par   |   A7    | R |  Address bus bit 7   +--                                |
\par   |   A6    | S |  Address bus bit 6   |                                  |
\par   |   A5    | T |  Address bus bit 5   |                                  |
\par   |   A4    | U |  Address bus bit 4   |                                  |
\par   |   A3    | V |  Address bus bit 3   |                                  |
\par   |   A2    | W |  Address bus bit 2   |                                  |
\par   |   A1    | X |  Address bus bit 1   +                                  |
\par   |   A0    | Y |  Address bus bit 0  /                                   |
\par   |   GND   | Z |  System ground                                          |
\par   +---------+---+---------------------------------------------------------+
\par 
\par                                                    INPUT/OUTPUT GUIDE   367
\par \page 
\par 
\par 
\par     Following is a description of some important fines on the expansion
\par   port:
\par 
\par     Pins 1,22,A,Z are connected to the system ground.
\par     Pin 6 is the DOT CLOCK. This is the 8.18-MHz video dot clock. All
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  system timing is derived from this clock.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Pin 12 is the BA (BUS AVAILABLE) signal from the VIC-II chip. This line
\par   will go low 3 cycles before the VIC-II takes over the system busses, and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  remains low until the VIC-II is finished fetching display information.
\par     Pin 13 is the DMA (DIRECT MEMORY ACCESS) line. When this line is pulled
\par   low, the address bus, the data bus, and the Read/Write line of the 6510
\par   processor chip enter high-impedance state mode. This allows an external
\par   processor to take control of the system busses. This line should only be
\par   pulled low when the (02 clock is low. Also, since the VIC-II chip will
\par   continue to perform display DMA, the external device must conform to the
\par   VIC-II timing. (See VIC-II timing diagram.) This line is pulled up on the
\par   Commodore 64.
\par 
\par 
\par 
\par   Z-80 MICROPROCESSOR CARTRIDGE
\par 
\par     Reading this book and using your computer has shown you just how
\par   versatile your Commodore 64 really is. But what makes this machine even
\par   more capable of meeting your needs is the addition of peripheral
\par   equipment. Peripherals are things like Datassette(TM) recorders, disk
\par   drives, printers, and modems. All these items can be added to your
\par   Commodore 64 through the various ports and sockets on the back of your
\par   machine. The thing that makes Commodore peripherals so good is the fact
\par   that our peripherals are "intelligent." That means that they don't take
\par   up valuable Random Access Memory space when they're in use. You're free
\par   to use all 64K of memory in your Commodore 64.
\par     Another advantage of your Commodore 64 is the fact most programs you
\par   write on your Commodore 64 today will be upwardly compatible with any new
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Commodore computer you buy in the future. This is partially because of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the qualities of the computer's Operating System (OS).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    However, there is one thing that the Commodore OS can't do: make your
\par   programs compatible with a computer made by another company.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   368   INPUT/OUTPUT GUIDE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Most of the time you won't even have to think about using another com-
\par   pany's computer, because your Commodore 64 is so easy to use. But for the
\par   occasional user who wants to take advantage of software that may not be
\par   available in Commodore 64 format we have created a Commodore CP/M(R)
\par   cartridge.
\par     CP/M(R) is not a "computer dependent" operating system. Instead it uses
\par   some of the memory space normally available for programming to run its
\par   own operating system. There are advantages and disadvantages to this. The
\par   disadvantages are that the programs you write will have to be shorter
\par   than the programs you can write using the Commodore 64's built-in
\par   operating system. In addition, you can NOT use the Commodore 64's
\par   powerful screen editing capabilities. The advantages are that you can now
\par   use a large amount of software that has been specifically designed for
\par   CP/M(R) and the Z-80 microprocessor, and the programs that you write
\par   using the CP/M(R) operating system can be transported and run on any
\par   other computer that has CP/M(R) and a Z-80 card.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    By the way, most computers that have a Z-80 microprocessor require that
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  you go inside the computer to actually install a Z-80 card. With this
\par   method you have to be very careful not to disturb the delicate circuitry
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  that runs the rest of the computer. The Commodore CP/M& cartridge
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  eliminates this hassle because our Z-80 cartridge plugs into the back of
\par   your Commodore 64 quickly and easily, without any messy wires that can
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cause problems later.
\par 
\par 
\par   USING COMMODORE CP/M(R)
\par 
\par     The Commodore Z-80 cartridge let's you run programs designed for a Z-80
\par   microprocessor on your Commodore 64. The cartridge is provided with a
\par   diskette containing the Commodore CP/M(R) operating system.
\par 
\par   RUNNING COMMODORE CP/M(R)
\par 
\par     To run CP/M(R):
\par 
\par       1) LOAD the CP/M(R) program from your disk drive.
\par       2) Type RUN.
\par       3) Hit the <RETURN> key.
\par 
\par 
\par 
\par 
\par 
\par                                                    INPUT/OUTPUT GUIDE   369
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     At this point the 64K bytes of RAM in the Commodore 64 are accessible
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  by the built-in 6510 central processor, OR 48K bytes of RAM are available
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  for the Z-80 central processor. You can shift back and forth between
\par   these two processors, but you can NOT use them at the same time in a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  single program. This is possible because of your Commodore 64's
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sophisticated timing mechanism.
\par     Below is the memory address translation that is performed on the Z-80
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cartridge. You should notice that by adding 4096 bytes to the memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  locations used in CP/M(R) $1000 (hex) you equal the memory addresses of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the normal Commodore 64 operating system. The correspondence between Z-80
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and 6510 memory addresses is as follows:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-----------------------------------+-----------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |          Z-80 ADDRESSES           |           6510 ADDRESSES          |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------+-----------------+-----------------+-----------------+
\par   |     DECIMAL     |       HEX       |     DECIMAL     |       HEX       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------+-----------------+-----------------+-----------------+
\par   |    0000-4095    |    0000-0FFF    |    4096-8191    |    1000-1FFF    |
\par   |    4096-8191    |    1000-1FFF    |    8192-12287   |    2000-2FFF    |
\par   |    8192-12287   |    2000-2FFF    |   12288-16383   |    3000-3FFF    |
\par   |   12288-16383   |    3000-3FFF    |   16384-20479   |    4000-4FFF    |
\par   |   16384-20479   |    4000-4FFF    |   20480-24575   |    5000-5FFF    |
\par   |   20480-24575   |    5000-5FFF    |   24576-28671   |    6000-6FFF    |
\par   |   24576-28671   |    6000-6FFF    |   28672-32767   |    7000-7FFF    |
\par   |   28672-32767   |    7000-7FFF    |   32768-36863   |    8000-SFFF    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   32768-36863   |    8000-8FFF    |   36864-40959   |    9000-9FFF    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   36864-40959   |    9000-9FFF    |   40960-45055   |    A000-AFFF    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   40960-45055   |    A000-AFFF    |   45056-49151   |    B000-BFFF    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   45056-49151   |    B000-BFFF    |   49152-53247   |    C000-CFFF    |
\par   |   49152-53247   |    C000-CFFF    |   53248-57343   |    D000-DFFF    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   53248-57343   |    D000-DFFF    |   57344-61439   |    E000-EFFF    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   57344-61439   |    E000-EFFF    |   61440-65535   |    F000-FFFF    |
\par   |   61440-65535   |    F000-FFFF    |    0000-4095    |    0000-0FFF    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------+-----------------+-----------------+-----------------+
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   370   INPUT/OUTPUT GUIDE
\par \page 
\par 
\par 
\par     To TURN ON the Z-80 and TURN OFF the 6510 chip, type in the following
\par   program:
\par 
\par start tok64 page371.prg
\par   10 rem this program is to be used with the z80 card
\par   20 rem it first stores z80 data at $1000 (Z80=$0000)
\par   30 rem then it turns off the 6510 irq's and enables
\par   40 rem the z80 card. the z80 card must be turned off
\par   50 rem to reenable the 6510 system.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  100 rem store z80 data
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  110 read b: rem get size of z80 code to be moved
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  120 for i=4096 to 4096+b-1:rem move code
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  130 read a:poke i,a
\par   140 next i
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  200 rem run z80 code
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  210 poke 56333,127: rem turn of 6510 irq's
\par   220 poke 56832,00 : rem turn on z80 card
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  230 poke 56333,129: rem turn on 6510 irq's when z80 done
\par   240 end
\par   1000 rem z80 machine language code data section
\par   1010 data 18 : rem size of data to be passed
\par   1100 rem z80 turn on code
\par   1110 data 00,00,00 : rem our z80 card requires turn on time at $0000
\par   1200 rem z80 task data here
\par   1210 data 33,02,245: rem ld hl,nn (location on screen)
\par   1220 data 52 : rem inc hl (increment that location)
\par   1300 rem z80 self-turn off data here
\par   1310 data 62,01 : rem ld a,n
\par   1320 data 50,00,206 : rem ld (nn),a :i/o location
\par   1330 data 00,00,00  : rem nop, nop, nop
\par   1340 data 195,00,00 : rem jmp $0000
\par stop tok64
\par 
\par 
\par     For more details about Commodore CP/M(R) and the Z-80 microprocessor
\par   look for the cartridge and the Z-80 Reference Guide at your local
\par   Commodore computer dealer.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                    INPUT/OUTPUT GUIDE   371
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                APPENDICES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                      373
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  APPENDIX A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ABBREVIATIONS FOR BASIC KEYWORDS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    As a time-saver when typing in programs and commands, Commodore 64
\par   BASIC allows the user to abbreviate most keywords. The abbreviation for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PRINT is a question mark. The abbreviations for other words are made by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  typing the first one or two letters of the word, followed by the SHIFTed
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  next letter of the word. If the abbreviations are used in a program line,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the keyword will LIST in the full form.
\par                           Looks like  |                        Looks like
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Command Abbreviation this on screen | Command Abbreviation this on screen
\par   ------------------------------------+------------------------------------
\par    ABS     A <SHIFT+B>                | END     E <SHIFT+N>
\par                                       |
\par    AND     A <SHIFT+N>                | EXP     E <SHIFT+X>
\par                                       |
\par    ASC     A <SHIFT+S>                | FN      NONE               FN
\par                                       |
\par    ATN     A <SHIFT+T>                | FOR     F <SHIFT+O>
\par                                       |
\par    CHR$    C <SHIFT+H>                | FRE     F <SHIFT+R>
\par                                       |
\par    CLOSE   CL <SHIFT+O>               | GET     G <SHIFT+E>
\par                                       |
\par    CLR     C <SHIFT+L>                | GET#    NONE               GET#
\par                                       |
\par    CMD     C <SHIFT+M>                | GOSUB   GO <SHIFT+S>
\par                                       |
\par    CONT    C <SHIFT+O>                | GOTO    G <SHIFT+O>
\par                                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   COS     NONE               COS     | IF      NONE               IF
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par    DATA    D <SHIFT+A>                | INPUT   NONE               INPUT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par    DEF     D <SHIFT+E>                | INPUT#  I <SHIFT+N>
\par                                       |
\par    DIM     D <SHIFT+I>                | INT     NONE               INT
\par                                       |
\par    LEFT$   LE <SHIFT+F>               | RIGHT$  R <SHIFT+I>
\par                                       |
\par    LEN     NONE               LEN     | RND     R <SHIFT+N>
\par 
\par   374   APPENDIX A
\par \page 
\par 
\par 
\par                           Looks like  |                        Looks like
\par   Command Abbreviation this on screen | Command Abbreviation this on screen
\par   ------------------------------------+------------------------------------
\par    LET     L <SHIFT+E>                | RUN     R <SHIFT+U>
\par                                       |
\par    LIST    L <SHIFT+I>        SAVE    | SAVE    S <SHIFT+A>
\par                                       |
\par    LOAD    L <SHIFT+O>                | SGN     S <SHIFT+G>
\par                                       |
\par    LOG     NONE               LOG     | SIN     S <SHIFT+I>
\par                                       |
\par    MID$    M <SHIFT+I>                | SPC(    S <SHIFT+P>
\par                                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   NEW     NONE               NEW     | SQR     S <SHIFT+Q>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par    NEXT    N <SHIFT+E>                | STATUS  ST                 ST
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   NOT     N <SHIFT+O>                | STEP    ST <SHIFT+E>
\par                                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   ON      NONE               ON      | STOP    S <SHIFT+T>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   OPEN    O <SHIFT+P>                | STR$    ST <SHIFT+R>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par    OR      NONE               OR      | SYS     S <SHIFT+Y>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   PEEK    P <SHIFT+E>                | TAB(    T <SHIFT+A>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   POKE    P <SHIFT+O>                | TAN     NONE               TAN
\par                                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   POS     NONE               POS     | THEN    T <SHIFT+H>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   PRINT   ?                  ?       | TIME    TI                 TI
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par    PRINT#  P <SHIFT+R>                | TIME$   TI$                TI$
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   READ    R <SHIFT+E>                | USR     U <SHIFT+S>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   REM     NONE               REM     | VAL     V <SHIFT+A>
\par                                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   RESTORE RE <SHIFT+S>               | VERIFY  V <SHIFT+E>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   RETURN  RE <SHIFT+T>               | WAIT    W <SHIFT+A>
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX A   375
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   APPENDIX B
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SCREEN DISPLAY CODES
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The following chart lists all of the characters built into the
\par   Commodore 64 character sets. It shows which numbers should be POKED into
\par   screen memory (locations 1024-2023) to get a desired character. Also
\par   shown is which character corresponds to a number PEEKed from the screen.
\par     Two character sets are available, but only one set at a time. This
\par   means that you cannot have characters from one set on the screen at the
\par   same time you have characters from the other set displayed. The sets are
\par   switched by holding down the <SHIFT> and <C=> keys simultaneously.
\par     From BASIC, POKE 53272,21 will switch to upper case mode and
\par   POKE 53272,23 switches to lower case.
\par     Any number on the chart may also be displayed in REVERSE. The reverse
\par   character code may be obtained by adding 128 to the values shown.
\par     If you want to display a solid circle at location 1504, POKE the code
\par   for the circle (81) into location 1504: POKE 1504,81.
\par     There is a corresponding memory location to control the color of each
\par   character displayed on the screen (locations 55296-56295). To change the
\par   color of the circle to yellow (color code 7) you would POKE the corre-
\par   sponding memory location (55776) with the character color: POKE 55776,7.
\par     Refer to Appendix D for the complete screen and color memory maps,
\par   along with color codes.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par   | NOTE: The following POKEs display the same symbol in set 1 and 2: 1,  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 27-64, 91-93, 96-104, 106-121, 123-127.                               |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SCREEN CODES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    SET 1   SET 2   POKE  |  SET 1   SET 2   POKE  |  SET 1   SET 2   POKE
\par   ------------------------+------------------------+-----------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          |                        |
\par       @               0   |    C       c       3   |    F       f       6
\par       A       a       1   |    D       d       4   |    G       g       7
\par       B       b       2   |    E       e       5   |    H       h       8
\par 
\par 
\par 
\par 
\par   376   APPENDIX B
\par \page 
\par 
\par 
\par     SET 1   SET 2   POKE  |  SET 1   SET 2   POKE  |  SET 1   SET 2   POKE
\par   ------------------------+------------------------+-----------------------
\par                           |                        |
\par       I       i       9   |    %              37   |            A      65
\par       J       j      10   |    &              38   |            B      66
\par       K       k      11   |    '              39   |            C      67
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      L       l      12   |    (              40   |            D      68
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      M       m      13   |    )              41   |            E      69
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      N       n      14   |    *              42   |            F      70
\par       O       o      15   |    +              43   |            G      71
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      P       p      16   |    ,              44   |            H      72
\par       Q       q      17   |    -              45   |            I      73
\par       R       r      18   |    .              46   |            J      74
\par       S       s      19   |    /              47   |            K      75
\par       T       t      20   |    0              48   |            L      76
\par       U       u      21   |    1              49   |            M      77
\par       V       v      22   |    2              50   |            N      78
\par       W       w      23   |    3              51   |            O      79
\par       X       x      24   |    4              52   |            P      80
\par       Y       y      25   |    5              53   |            Q      81
\par       Z       z      26   |    6              54   |            R      82
\par       [              27   |    7              55   |            S      83
\par     pound            28   |    8              56   |            T      84
\par       ]              29   |    9              57   |            U      85
\par       ^              30   |    :              58   |            V      86
\par       <-             31   |    ;              59   |            W      87
\par     SPACE            32   |    <              60   |            X      88
\par       !              33   |    =              61   |            Y      89
\par       "              34   |    >              62   |            Z      90
\par       #              35   |    ?              63   |                   91
\par       $              36   |                   64   |                   92
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                            APPENDIX B   377
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    SET 1   SET 2   POKE  |  SET 1   SET 2   POKE  |  SET 1   SET 2   POKE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ------------------------+------------------------+-----------------------
\par                           |                        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     93   |                  105   |                  117
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     94   |                  106   |                  118
\par                      95   |                  107   |                  119
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    SPACE            96   |                  108   |                  120
\par                      97   |                  109   |                  121
\par                      98   |                  110   |                  122
\par                      99   |                  111   |                  123
\par                     100   |                  112   |                  124
\par                     101   |                  113   |                  125
\par                     102   |                  114   |                  126
\par                     103   |                  115   |                  127
\par                     104   |                  116   |
\par 
\par             Codes from 128-255 are reversed images of codes 0-127.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   378   APPENDIX B
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  APPENDIX C
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ASCII AND CHR$ CODES
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This appendix shows you what characters will appear if you PRINT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CHR$(X), for all possible values of X. It will also show the values ob-
\par   tained by typing PRINT ASC("x"), where x is any character you can type.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  This is useful in evaluating the character received in a GET statement,
\par   converting upper/lower case, and printing character based commands (like
\par   switch to upper/lower case) that could not be enclosed in quotes.
\par 
\par 
\par   +-----------------+-----------------+-----------------+-----------------+
\par   |  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |
\par   +-----------------+-----------------+-----------------+-----------------+
\par   |             0   |  \{down\}    17   |    "       34   |    3       51   |
\par   |             1   | \{rvs on\}   18   |    #       35   |    4       52   |
\par   |             2   |  \{home\}    19   |    $       36   |    5       53   |
\par   |             3   |  \{del\}     20   |    %       37   |    6       54   |
\par   |             4   |            21   |    &       38   |    7       55   |
\par   | \{white\}     5   |            22   |    '       39   |    8       56   |
\par   |             6   |            23   |    (       40   |    9       57   |
\par   |             7   |            24   |    )       41   |    :       58   |
\par   | disSHIFT+C= 8   |            25   |    *       42   |    ;       59   |
\par   | enaSHIFT+C= 9   |            26   |    +       43   |    <       60   |
\par   |            10   |            27   |    ,       44   |    =       61   |
\par   |            11   |  \{red\}     28   |    -       45   |    >       62   |
\par   |            12   | \{right\}    29   |    .       46   |    ?       63   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | return     13   | \{green\}    30   |    /       47   |    @       64   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | lower case 14   |  \{blue\}    31   |    0       48   |    A       65   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |            15   |  SPACE     32   |    1       49   |    B       66   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |            16   |    !       33   |    2       50   |    C       67   |
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX C   379
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------+-----------------+-----------------+-----------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |
\par   +-----------------+-----------------+-----------------+-----------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    D       68   |            97   |           126   | \{grey 3\}  155   |
\par   |    E       69   |            98   |           127   | \{purple\}  156   |
\par   |    F       70   |            99   |           128   | \{left\}    157   |
\par   |    G       71   |           100   | \{orange\}  129   | \{yellow\}  158   |
\par   |    H       72   |           101   |           130   |  \{cyan\}   159   |
\par   |    I       73   |           102   |           131   |  SPACE    160   |
\par   |    J       74   |           103   |           132   |           161   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    K       75   |           104   |    f1     133   |           162   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    L       76   |           105   |    f3     134   |           163   |
\par   |    M       77   |           106   |    f5     135   |           164   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    N       78   |           107   |    f7     136   |           165   |
\par   |    O       79   |           108   |    f2     137   |           166   |
\par   |    P       80   |           109   |    f4     138   |           167   |
\par   |    Q       81   |           110   |    f6     139   |           168   |
\par   |    R       82   |           111   |    f8     140   |           169   |
\par   |    S       83   |           112   |shift+ret. 141   |           170   |
\par   |    T       84   |           113   |upper case 142   |           171   |
\par   |    U       85   |           114   |           143   |           172   |
\par   |    V       86   |           115   | \{black\}   144   |           173   |
\par   |    W       87   |           116   |   \{up\}    145   |           174   |
\par   |    X       88   |           117   | \{rvs off\} 146   |           175   |
\par   |    Y       89   |           118   | \{clear\}   147   |           176   |
\par   |    Z       90   |           119   |  \{inst\}   148   |           177   |
\par   |    [       91   |           120   | \{brown\}   149   |           178   |
\par   |  pound     92   |           121   | \{lt. red\} 150   |           179   |
\par   |    ]       93   |           122   | \{grey 1\}  151   |           180   |
\par   |    ^       94   |           123   | \{grey 2\}  152   |           181   |
\par   |\{arrow left\}95   |           124   | \{lt.green\}153   |           182   |
\par   |            96   |           125   | \{lt.blue\} 154   |           183   |
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  380   APPENDIX C
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-----------------+-----------------+-----------------+-----------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------+-----------------+-----------------+-----------------+
\par   |           184   |           186   |           188   |           190   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           185   |           187   |           189   |           191   |
\par   +-----------------+-----------------+-----------------+-----------------+
\par 
\par   CODES 192-223 SAME AS  96-127
\par   CODES 224-254 SAME AS 160-190
\par   CODE 255 SAME AS 126
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX C   381
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  APPENDIX D
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SCREEN AND COLOR MEMORY MAPS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The following charts list which memory locations control placing char-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  acters on the screen, and the locations used to change individual char-
\par   acter colors, as well as showing character color codes.
\par 
\par                              SCREEN MEMORY MAP
\par 
\par                                    COLUMN                             1063
\par         0             10             20             30            39 /
\par        +------------------------------------------------------------/
\par   1024 |                                                            |  0
\par   1064 |                                                            |
\par   1104 |                                                            |
\par   1144 |                                                            |
\par   1184 |                                                            |
\par   1224 |                                                            |
\par   1264 |                                                            |
\par   1304 |                                                            |
\par   1344 |                                                            |
\par   1384 |                                                            |
\par   1424 |                                                            | 10
\par   1464 |                                                            |
\par   1504 |                                                            |   ROW
\par   1544 |                                                            |
\par   1584 |                                                            |
\par   1624 |                                                            |
\par   1664 |                                                            |
\par   1704 |                                                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  1744 |                                                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  1784 |                                                            |
\par   1824 |                                                            | 20
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  1864 |                                                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  1904 |                                                            |
\par   1944 |                                                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  1984 |                                                            | 24
\par        +------------------------------------------------------------\\
\par                                                                      \\
\par                                                                       2023
\par 
\par   382   APPENDIX D
\par \page 
\par 
\par 
\par     The actual values to POKE into a color memory location to change a
\par   character's color are:
\par 
\par              0  BLACK   4  PURPLE     8  ORANGE     12  GRAY 2
\par              1  WHITE   5  GREEN      9  BROWN      13  Light GREEN
\par              2  RED     6  BLUE      10  Light RED  14  Light BLUE
\par              3  CYAN    7  YELLOW    11  GRAY 1     15  GRAY 3
\par 
\par     For example, to change the color of a character located at the upper
\par   left-hand corner of the screen to red, type: POKE 55296,2.
\par 
\par                               COLOR MEMORY MAP
\par                                    COLUMN                             55335
\par         0             10             20             30            39 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       +------------------------------------------------------------/
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  55296|                                                            |  0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  55336|                                                            |
\par   55376|                                                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  55416|                                                            |
\par   55456|                                                            |
\par   55496|                                                            |
\par   55536|                                                            |
\par   55576|                                                            |
\par   55616|                                                            |
\par   55656|                                                            |
\par   55696|                                                            | 10
\par   55736|                                                            |
\par   55776|                                                            |   ROW
\par   55816|                                                            |
\par   55856|                                                            |
\par   55896|                                                            |
\par   55936|                                                            |
\par   55976|                                                            |
\par   56016|                                                            |
\par   56056|                                                            |
\par   56096|                                                            | 20
\par   56136|                                                            |
\par   56176|                                                            |
\par   56216|                                                            |
\par   56256|                                                            | 24
\par        +------------------------------------------------------------\\
\par                                                                      56295
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX D   383
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  APPENDIX E
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   MUSIC NOTE VALUES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This appendix contains a complete list of Note#, actual note, and the
\par   values to be POKED into the HI FREQ and LOW FREQ registers of the sound
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  chip to produce the indicated note.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-----------------------------+-----------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |        MUSICAL NOTE         |             OSCILLATOR FREQ             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------------+---------------+-------------+-------------+-------------+
\par   |     NOTE    |    OCTAVE     |   DECIMAL   |      HI     |     LOW     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------------+---------------+-------------+-------------+-------------+
\par   |       0     |      C-0      |     268     |       1     |      12     |
\par   |       1     |      C#-0     |     284     |       1     |      28     |
\par   |       2     |      D-0      |     301     |       1     |      45     |
\par   |       3     |      D#-0     |     318     |       1     |      62     |
\par   |       4     |      E-0      |     337     |       1     |      81     |
\par   |       5     |      F-0      |     358     |       1     |     102     |
\par   |       6     |      F#-0     |     379     |       1     |     123     |
\par   |       7     |      G-0      |     401     |       1     |     145     |
\par   |       8     |      G#-0     |     425     |       1     |     169     |
\par   |       9     |      A-0      |     451     |       1     |     195     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      10     |      A#-0     |     477     |       1     |     221     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      11     |      B-0      |     506     |       1     |     250     |
\par   |      16     |      C-1      |     536     |       2     |      24     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      17     |      C#-1     |     568     |       2     |      56     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      18     |      D-1      |     602     |       2     |      90     |
\par   |      19     |      D#-1     |     637     |       2     |     125     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      20     |      E-1      |     675     |       2     |     163     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      21     |      F-1      |     716     |       2     |     204     |
\par   |      22     |      F#-1     |     758     |       2     |     246     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      23     |      G-1      |     803     |       3     |      35     |
\par   |      24     |      G#-1     |     851     |       3     |      83     |
\par   |      25     |      A-1      |     902     |       3     |     134     |
\par   |      26     |      A#-1     |     955     |       3     |     187     |
\par   |      27     |      B-1      |    1012     |       3     |     244     |
\par   |      32     |      C-2      |    1072     |       4     |      48     |
\par 
\par 
\par 
\par   384   APPENDIX E
\par \page 
\par 
\par 
\par   +-----------------------------+-----------------------------------------+
\par   |        MUSICAL NOTE         |             OSCILLATOR FREQ             |
\par   +-------------+---------------+-------------+-------------+-------------+
\par   |     NOTE    |    OCTAVE     |   DECIMAL   |      HI     |     LOW     |
\par   +-------------+---------------+-------------+-------------+-------------+
\par   |      33     |      C#-2     |     1136    |       4     |     112     |
\par   |      34     |      D-2      |     1204    |       4     |     180     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      35     |      D#-2     |     1275    |       4     |     251     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      36     |      E-2      |     1351    |       5     |      71     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      37     |      F-2      |     1432    |       5     |     152     |
\par   |      38     |      F#-2     |     1517    |       5     |     237     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      39     |      G-2      |     1607    |       6     |      71     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      40     |      G#-2     |     1703    |       6     |     167     |
\par   |      41     |      A-2      |     1804    |       7     |      12     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      42     |      A#-2     |     1911    |       7     |     119     |
\par   |      43     |      B-2      |     2025    |       7     |     233     |
\par   |      48     |      C-3      |     2145    |       8     |      97     |
\par   |      49     |      C#-3     |     2273    |       8     |     225     |
\par   |      50     |      D-3      |     2408    |       9     |     104     |
\par   |      51     |      D#-3     |     2551    |       9     |     247     |
\par   |      52     |      E-3      |     2703    |      10     |     143     |
\par   |      53     |      F-3      |     2864    |      11     |      48     |
\par   |      54     |      F#-3     |     3034    |      11     |     218     |
\par   |      55     |      G-3      |     3215    |      12     |     143     |
\par   |      56     |      G#-3     |     3406    |      13     |      78     |
\par   |      57     |      A-3      |     3608    |      14     |      24     |
\par   |      58     |      A#-3     |     3823    |      14     |     239     |
\par   |      59     |      B-3      |     4050    |      15     |     210     |
\par   |      64     |      C-4      |     4291    |      16     |     195     |
\par   |      65     |      C#-4     |     4547    |      17     |     195     |
\par   |      66     |      D-4      |     4817    |      18     |     209     |
\par   |      67     |      D#-4     |     5103    |      19     |     239     |
\par   |      68     |      E-4      |     5407    |      21     |      31     |
\par   |      69     |      F-4      |     5728    |      22     |      96     |
\par   |      70     |      F#-4     |     6069    |      23     |     181     |
\par   |      71     |      G-4      |     6430    |      25     |      30     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      72     |      G#-4     |     6812    |      26     |     156     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      73     |      A-4      |     7217    |      28     |      49     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      74     |      A#-4     |     7647    |      29     |     223     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      75     |      B-4      |     8101    |      31     |     165     |
\par   |      80     |      C-5      |     8583    |      33     |     135     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      81     |      C#-5     |     9094    |      35     |     134     |
\par 
\par                                                            APPENDIX E   385
\par \page 
\par 
\par 
\par   +-----------------------------+-----------------------------------------+
\par   |        MUSICAL NOTE         |             OSCILLATOR FREQ             |
\par   +-------------+---------------+-------------+-------------+-------------+
\par   |     NOTE    |    OCTAVE     |   DECIMAL   |      HI     |     LOW     |
\par   +-------------+---------------+-------------+-------------+-------------+
\par   |      82     |      D-5      |     9634    |      37     |     162     |
\par   |      83     |      D#-5     |    10207    |      39     |     223     |
\par   |      84     |      E-5      |    10814    |      42     |      62     |
\par   |      85     |      F-5      |    11457    |      44     |     193     |
\par   |      86     |      F#-5     |    12139    |      47     |     107     |
\par   |      87     |      G-5      |    12860    |      50     |      60     |
\par   |      88     |      G#-5     |    13625    |      53     |      57     |
\par   |      89     |      A-5      |    14435    |      56     |      99     |
\par   |      90     |      A#-5     |    15294    |      59     |     190     |
\par   |      91     |      B-5      |    16203    |      63     |      75     |
\par   |      96     |      C-6      |    17167    |      67     |      15     |
\par   |      97     |      C#-6     |    18188    |      71     |      12     |
\par   |      98     |      D-6      |    19269    |      75     |      69     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      99     |      D#-6     |    20415    |      79     |     191     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     100     |      E-6      |    21629    |      84     |     125     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     101     |      F-6      |    22915    |      89     |     131     |
\par   |     102     |      F#-6     |    24278    |      94     |     214     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     103     |      G-6      |    25721    |     100     |     121     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     104     |      G#-6     |    27251    |     106     |     115     |
\par   |     105     |      A-6      |    28871    |     112     |     199     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     106     |      A#-6     |    30588    |     119     |     124     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     107     |      B-6      |    32407    |     126     |     151     |
\par   |     112     |      C-7      |    34334    |     134     |      30     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |     113     |      C#-7     |    36376    |     142     |      24     |
\par   |     114     |      D-7      |    38539    |     150     |     139     |
\par   |     115     |      D#-7     |    40830    |     159     |     126     |
\par   |     116     |      E-7      |    43258    |     168     |     250     |
\par   |     117     |      F-7      |    45830    |     179     |       6     |
\par   |     118     |      F#-7     |    48556    |     189     |     172     |
\par   |     119     |      G-7      |    51443    |     200     |     243     |
\par   |     120     |      G#-7     |    54502    |     212     |     230     |
\par   |     121     |      A-7      |    57743    |     225     |     143     |
\par   |     122     |      A#-7     |    61176    |     238     |     248     |
\par   |     123     |      B-7      |    64814    |     253     |      46     |
\par   +-------------+---------------+-------------+-------------+-------------+
\par 
\par 
\par 
\par   386   APPENDIX E
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                              FILTER SETTINGS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               +------------+--------------------------------+
\par                |  Location  |            Contents            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               +------------+--------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               |    54293   |  Low cutoff frequency (0-7)    |
\par                |    54294   |  High cutoff frequency (0-255) |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               |    54295   |  Resonance (bits 4-7)          |
\par                |            |  Filter voice 3 (bit 2)        |
\par                |            |  Filter voice 2 (bit 1)        |
\par                |            |  Filter voice 1 (bit 0)        |
\par                |    54296   |  High pass (bit 6)             |
\par                |            |  Bandpass (bit 5)              |
\par                |            |  Low pass (bit 4)              |
\par                |            |  Volume (bits 0-3)             |
\par                +------------+--------------------------------+
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                            APPENDIX E   387
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  APPENDIX F
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BIBLIOGRAPHY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Addison-Wesley          "BASIC and the Personal Computer", Dwyer and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          Critchfield
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Compute                 "Compute's First Book of PET/CBM"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Cowbay Computing        "Feed Me, I'm Your PET Computer", Carol Alexander
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          "Looking Good with Your PET", Carol Alexander
\par 
\par                           "Teacher's PET-Plans, Quizzes, and Answers"
\par 
\par   Creative Computing      "Getting Acquainted With Your VIC 20",
\par                           T. Hartnell
\par 
\par   Dilithium Press         "BASIC Basic-English Dictionary for the PET",
\par                           Lorry Noonan
\par 
\par                           "PET BASIC", Tom Rugg and Phil Feldman
\par 
\par   Faulk Baker Associates  "MOS Programming Manual", MOS Technology
\par 
\par   Hoyden Book Co.         "BASIC From the Ground Up", David E. Simon
\par 
\par                           "I Speak BASIC to My PET", Aubrey Jones, Jr.
\par 
\par                           "Library of PET Subroutines',', Nick Hampshire
\par 
\par                           "PET Graphics", Nick Hampshire
\par 
\par                           "BASIC Conversions Handbook, Apple, TRS-80, and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          PET", David A. Brain, Phillip R. Oviatt,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          Paul J. Paquin, and Chandler P. Stone
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  388   APPENDIX F
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Howard W. Sams          "The Howard W. Sams Crash Course in Mi-
\par                           crocomputers", Louis E. Frenzel, Jr.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          "Mostly BASIC: Applications for Your PET",
\par                           Howard Berenbon
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          "PET Interfacing", James M. Downey and Steven
\par                           M. Rogers
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          "VIC 20 Programmer's Reference Guide", A. Finkel,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          P. Higginbottom, N. Harris, and M. Tomczyk
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Little, Brown & Co.     "Computer Games for Businesses, Schools, and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          Homes", J. Victor Nagigian, and William S. Hodges
\par 
\par                           "The Computer Tutor: Learning Activities for
\par                           Homes and Schools", Gary W. Orwig, University of
\par                           Central Florida, and William S. Hodges
\par 
\par   McGraw-Hill             "Hands-On BASIC With a PET", Herbert D. Peckman
\par 
\par                           "Home and Office Use of VisiCalc", D. Castlewitz,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          and L. Chisauki
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Osborne/McGraw-Hill     "PET/CBM Personal Computer Guide", Carroll
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          S. Donahue
\par 
\par                           "PET Fun and Games", R. Jeffries and G. Fisher
\par 
\par                           "PET and the IEEE", A. Osborne and C. Donahue
\par 
\par                           "Some Common BASIC Programs for the PET",
\par                           L. Poole, M. Borchers, and C. Donahue
\par 
\par                           "Osborne CP/M User Guide", Thorn Hogan
\par 
\par                           "CBM Professional Computer Guide"
\par 
\par                           "The PET Personal Guide"
\par 
\par                           "The 8086 Book", Russell Rector and George Alexy
\par 
\par 
\par                                                            APPENDIX F   389
\par \page 
\par 
\par 
\par   P. C. Publications      "Beginning Self-Teaching Computer Lessons"
\par 
\par   Prentice-Hall           "The PET Personal Computer for Beginners",
\par                           S. Dunn and V. Morgan
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Reston Publishing Co.   "PET and the IEEE 488 Bus (GPIB)", Eugene
\par                           Fisher and C. W. Jensen
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          "PET BASIC-Training Your PET Computer",
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          Roman Zamora, Wm. F. Carrie, and B. Allbrecht
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                           "PET Games and Recreation", M. Ogelsby, L.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          Lindsey, and D. Kunkin
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                           "PET BASIC", Richard Huskell
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          "VIC Games and Recreation"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Telmas Courseware       "BASIC and the Personal Computer", T. A. Dwyer,
\par   Ratings                 and M. Critchfield
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Total Information Ser-  "Understanding Your PET/CBM, Vol. 1, BASIC
\par   vices                   Programming"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          "Understanding Your VIC", David Schultz
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Commodore Magazines provide you with the most up-to-date information
\par   for your Commodore 64. Two of the most popular publications that you
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  should seriously consider subscribing to are:
\par 
\par     COMMODORE-The Microcomputer Magazine is published bimonthly and is
\par   available by subscription ($15.00 per year, U.S., and $25.00 per year,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  worldwide).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     POWER/PLAY-The Home Computer Magazine is, published quarterly and is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  available by subscription ($10.00 per year, U.S,, and $15.00 per year
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  worldwide).
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  390   APPENDIX F
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   APPENDIX G
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VIC CHIP REGISTER MAP
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  53248 ($D000) Starting (Base) Address
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |Register#|     |     |     |     |     |     |     |     |             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Dec Hex | DB7 | DB6 | DB5 | DB4 | DB3 | DB2 | DB1 | DB0 |             |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  0   0  | S0X7|     |     |     |     |     |     | S0X0| SPRITE 0 X  |
\par   |         |     |     |     |     |     |     |     |     |  Component  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   |  1   1  | S0Y7|     |     |     |     |     |     | S0Y0| SPRITE 0 Y  |
\par   |         |     |     |     |     |     |     |     |     |  Component  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  2   2  | S1X7|     |     |     |     |     |     | S1X0| SPRITE 1 X  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  3   3  | S1Y7|     |     |     |     |     |     | S1Y0| SPRITE 1 Y  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  4   4  | S2X7|     |     |     |     |     |     | S2X0| SPRITE 2 X  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   |  5   5  | S2Y7|     |     |     |     |     |     | S2Y0| SPRITE 2 Y  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   |  6   6  | S3X7|     |     |     |     |     |     | S3X0| SPRITE 3 X  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   |  7   7  | S3Y7|     |     |     |     |     |     | S3Y0| SPRITE 3 Y  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   |  8   8  | S4X7|     |     |     |     |     |     | S4X0| SPRITE 4 X  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   |  9   9  | S4Y7|     |     |     |     |     |     | S4Y0| SPRITE 4 Y  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 10   A  | S5X7|     |     |     |     |     |     | S5X0| SPRITE 5 X  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 11   B  | S5Y7|     |     |     |     |     |     | S5Y0| SPRITE 5 Y  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 12   C  | S6X7|     |     |     |     |     |     | S6X0| SPRITE 6 X  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 13   D  | S6Y7|     |     |     |     |     |     | S6Y0| SPRITE 6 Y  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 14   E  | S7X7|     |     |     |     |     |     | S7X0| SPRITE 7 X  |
\par   |         |     |     |     |     |     |     |     |     |  Component  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par 
\par                                                            APPENDIX G   391
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |Register#|     |     |     |     |     |     |     |     |             |
\par   | Dec Hex | DB7 | DB6 | DB5 | DB4 | DB3 | DB2 | DB1 | DB0 |             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 15   F  | S7Y7|     |     |     |     |     |     | S7Y0| SPRITE 7 Y  |
\par   |         |     |     |     |     |     |     |     |     |  Component  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 16  10  | S7X8| S6X8| S5X8| S4X8| S3X8| S2X8| S1X8| S0X8|  MSB of X   |
\par   |         |     |     |     |     |     |     |     |     |   COORD.    |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 17  11  | RC8 | ECM | BMM | BLNK| RSEL|YSCL2|YSCL1|YSCL0|  Y SCROLL   |
\par   |         |     |     |     |     |     |     |     |     |  MODE       |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 18  12  | RC7 | RC6 | RC5 | RC4 | RC3 | RC2 | RC1 | RC0 |   RASTER    |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 19  13  | LPX7|     |     |     |     |     |     | LPX0| LIGHT PEN X |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 20  14  | LPY7|     |     |     |     |     |     |     | LIGHT PEN Y |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 21  15  | SE7 |     |     |     |     |     |     | SE0 |SPRITE ENABLE|
\par   |         |     |     |     |     |     |     |     |     |  (ON/OFF)   |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 22  16  | N.C.| N.C.| RST | MCM | CSEL|XSCL2|XSCL1|XSCL0|  X SCROLL   |
\par   |         |     |     |     |     |     |     |     |     |  MODE       |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 23  17  |SEXY7|     |     |     |     |     |     |SEXY0|   SPRITE    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         |     |     |     |     |     |     |     |     |  EXPAND Y   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 24  18  | VS13| VS12| VS11| VS10| CB13| CB12| CB11| N.C.| SCREEN and  |
\par   |         |     |     |     |     |     |     |     |     |  Character  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         |     |     |     |     |     |     |     |     | Memory Base |
\par   |         |     |     |     |     |     |     |     |     |  Address    |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 25  19  | IRQ | N.C.| N.C.| N.C.|LPIRQ| ISSC| ISBC| RIRQ|  Interrupt  |
\par   |         |     |     |     |     |     |     |     |     |  Request's  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 26  1A  | N.C.| N.C.| N.C.| N.C.| MLPI|MISSC|MISBC|MRIRQ|  IRQ MASKS  |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 27  1B  | BSP7|     |     |     |     |     |     | BSP0| Background- |
\par   |         |     |     |     |     |     |     |     |     | Sprite      |
\par   |         |     |     |     |     |     |     |     |     | PRIORITY    |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par 
\par   392   APPENDIX G
\par \page 
\par 
\par 
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   |Register#|     |     |     |     |     |     |     |     |             |
\par   | Dec Hex | DB7 | DB6 | DB5 | DB4 | DB3 | DB2 | DB1 | DB0 |             |
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 28  1C  | SCM7|     |     |     |     |     |     | SCM0| MULTICOLOR  |
\par   |         |     |     |     |     |     |     |     |     |SPRITE SELECT|
\par   +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par   | 29  1D  |SEXX7|     |     |     |     |     |     |SEXX0|   SPRITE    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         |     |     |     |     |     |     |     |     |  EXPAND X   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 30  1E  | SSC7|     |     |     |     |     |     | SSC0|Sprite-Sprite|
\par   |         |     |     |     |     |     |     |     |     |  COLLISION  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 31  1F  | SBC7|     |     |     |     |     |     | SBC0| Sprite-     |
\par   |         |     |     |     |     |     |     |     |     | Background  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |         |     |     |     |     |     |     |     |     | COLLISION   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-----------------------+   +---------+-----------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |Register#|                       |   |Register#|                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Dec Hex |         Color         |   | Dec Hex |         Color         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 32  20  |  BORDER COLOR         |   | 39  27  |  SPRITE 0 COLOR       |
\par   | 33  21  |  BACKGROUND COLOR 0   |   | 40  28  |  SPRITE 1 COLOR       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 34  22  |  BACKGROUND COLOR 1   |   | 41  29  |  SPRITE 2 COLOR       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 35  23  |  BACKGROUND COLOR 2   |   | 42  2A  |  SPRITE 3 COLOR       |
\par   | 36  24  |  BACKGROUND COLOR 3   |   | 43  2B  |  SPRITE 4 COLOR       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 37  25  |  SPRITE MULTICOLOR 0  |   | 44  2C  |  SPRITE 5 COLOR       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 38  26  |  SPRITE MULTICOLOR 1  |   | 45  2D  |  SPRITE 6 COLOR       |
\par   +---------+-----------------------+   | 46  2E  |  SPRITE 7 COLOR       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  COLOR CODES                           +---------+-----------------------+
\par   +---------+-----------+  +---------+-----------+
\par   | Dec Hex |   Color   |  | Dec Hex |   Color   |
\par   |  0   0  |  BLACK    |  |  8   8  |  ORANGE   |
\par   |  1   1  |  WHITE    |  |  9   9  |  BROWN    |
\par   |  2   2  |  RED      |  | 10   A  |  LT RED   |
\par   |  3   3  |  CYAN     |  | 11   B  |  GRAY 1   |
\par   |  4   4  |  PURPLE   |  | 12   C  |  GRAY 2   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  5   5  |  GREEN    |  | 13   D  |  LT GREEN |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  6   6  |  BLUE     |  | 14   E  |  LT BLUE  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  7   7  |  YELLOW   |  | 15   F  |  GRAY 3   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------+-----------+  +---------+-----------+
\par   LEGEND: ONLY COLORS 0-7 MAY BE USED IN MULTICOLOR CHARACTER MODE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX G   393
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   APPENDIX H
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   DERIVING MATHEMATICAL FUNCTIONS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Functions that are not intrinsic to Commodore 64 BASIC may be calcu-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  lated as follows:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------+----------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |           FUNCTION           |            BASIC EQUIVALENT            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------+----------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  SECANT                      |  SEC(X)=1/COS(X)                       |
\par   |  COSECANT                    |  CSC(X)=1/SIN(X)                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  COTANGENT                   |  COT(X)=1/TAN(X)                       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  INVERSE SINE                |  ARCSIN(X)=ATN(X/SQR(-X*X+1))          |
\par   |  INVERSE COSINE              |  ARCCOS(X)=-ATN(X/SQR(-X*X+1))+\{pi\}/2  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  INVERSE SECANT              |  ARCSEC(X)=ATN(X/SQR(X*X-1))           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  INVERSE COSECANT            |  ARCCSC(X)=ATN(X/SQR(X*X-1))           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |                              |    +(SGN(X)-1*\{pi\}/2                   |
\par   |  INVERSE COTANGENT           |  ARCOT(X)=ATN(X)+\{pi\}/2                |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  HYPERBOLIC SINE             |  SINH(X)=(EXP(X)-EXP(-X))/2            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  HYPERBOLIC COSINE           |  COSH(X)=(EXP(X)+EXP(-X))/2            |
\par   |  HYPERBOLIC TANGENT          |  TANH(X)=EXP(-X)/(EXP(X)+EXP(-X))*2+1  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  HYPERBOLIC SECANT           |  SECH(X)=2/(EXP(X)+EXP(-X))            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  HYPERBOLIC COSECANT         |  CSCH(X)=2/(EXP(X)-EXP(-X))            |
\par   |  HYPERBOLIC  COTANGENT       |  COTH(X)=EXP(-X)/(EXP(X)-EXP(-X))*2+1  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  INVERSE HYPERBOLIC SINE     |  ARCSINH(X)=LOG(X+SQR(X*X+1))          |
\par   |  INVERSE HYPERBOLIC COSINE   |  ARCCOSH(X)=LOG(X+SQR(X*X-1))          |
\par   |  INVERSE HYPERBOLIC TANGENT  |  ARCTANH(X)=LOG((1+X)/(1-X))/2         |
\par   |  INVERSE HYPERBOLIC SECANT   |  ARCSECH(X)=LOG((SQR(-X*X+1)+1/X)      |
\par   |  INVERSE HYPERBOLIC COSECANT |  ARCCSCH(X)=LOG((SGN(X)*SQR(X*X+1/X)   |
\par   |  INVERSE HYPERBOLIC COTANGENT|  ARCCOTH(X)=LOG((X+1)/(X-1))/2         |
\par   +------------------------------+----------------------------------------+
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   394   APPENDIX H
\par \page 
\par 
\par 
\par   APPENDIX I
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   PINOUTS FOR INPUT/OUTPUT DEVICES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This appendix is designed to show you what connections may be made to
\par   the Commodore 64.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par           1) Game I/O             4) Serial I/O (Disk/Printer)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          2) Cartridge Slot       5) Modulator Output
\par           3) Audio/Video          6) Cassette
\par                                   7) User Port
\par 
\par   Control Port 1
\par   +-----+-------------+-----------+
\par   | Pin |    Type     |   Note    |            1 2 3 4 5
\par   |  1  |    JOYA0    |           |            O O O O O
\par   |  2  |    JOYA1    |           |
\par   |  3  |    JOYA2    |           |             O O O O
\par   |  4  |    JOYA3    |           |             6 7 8 9
\par   |  5  |    POT AY   |           |
\par   |  6  | BUTTON A/LP |           |
\par   |  7  |     +5V     | MAX. 50mA |
\par   |  8  |     GND     |           |
\par   |  9  |   POT AX    |           |
\par   +-----+-------------+-----------+
\par 
\par   Control Port 2
\par   +-----+-------------+-----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Pin |    Type     |   Note    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  1  |    JOYB0    |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  2  |    JOYB1    |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  3  |    JOYB2    |           |
\par   |  4  |    JOYB3    |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  5  |    POT BY   |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  6  |  BUTTON B   |           |
\par   |  7  |     +5V     | MAX. 50mA |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  8  |     GND     |           |
\par   |  9  |   POT BX    |           |
\par   +-----+-------------+-----------+
\par 
\par 
\par                                                            APPENDIX I   395
\par \page 
\par 
\par 
\par   Cartridge Expansion Slot
\par     Pin    Type       Pin    Type       Pin    Type       Pin    Type
\par   +----+----------+ +----+----------+ +----+----------+ +----+----------+
\par   |  1 | GND      | | 12 | BA       | |  A | GND      | |  N | A9       |
\par   |  2 | +5V      | | 13 | /DMA     | |  B | /ROMH    | |  P | A8       |
\par   |  3 | +5V      | | 14 | D7       | |  C | /RESET   | |  R | A7       |
\par   |  4 | /IRQ     | | 15 | D6       | |  D | /NMI     | |  S | A6       |
\par   |  5 | R/W      | | 16 | D5       | |  E | 02       | |  T | A5       |
\par   |  6 | Dot Clock| | 17 | D4       | |  F | A15      | |  U | A4       |
\par   |  7 | I/O1     | | 18 | D3       | |  H | A14      | |  V | A3       |
\par   |  8 | /GAME    | | 19 | D2       | |  J | A13      | |  W | A2       |
\par   |  9 | /EXROM   | | 20 | D1       | |  K | A12      | |  X | A1       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 10 | I/O2     | | 21 | D0       | |  L | A11      | |  Y | A0       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 11 | /ROML    | | 22 | GND      | |  M | A10      | |  Z | GND      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----+----------+ +----+----------+ +----+----------+ +----+----------+
\par                  2 2 2 1 1 1 1 1 1 1 1 1 1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1
\par              +---@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@---+
\par              |                                                 |
\par              +---@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@---+
\par                  Z Y X W V U T S R P N M L K J H F E D C B A
\par 
\par   Audio/Video                        Serial I/O
\par      Pin            Type                Pin            Type
\par   +-------+----------------------+   +-------+----------------------+
\par   |   1   |  LUMINANCE           |   |   1   |  /SERIAL SRQ IN      |
\par   |   2   |  GND                 |   |   2   |  GND                 |
\par   |   3   |  AUDIO OUT           |   |   3   |  SERIAL ATN OUT      |
\par   |   4   |  VIDEO OUT           |   |   4   |  SERIAL CLK IN/OUT   |
\par   |   5   |  AUDIO IN            |   |   5   |  SERIAL DATA IN/OUT  |
\par   |   6   |  CHROMINANCE         |   |   6   |  /RESET              |
\par   +-------+----------------------+   +-------+----------------------+
\par                 ++ ++                             ++ ++
\par                / +-+ \\                           / +-+ \\
\par               /       \\                         /5     1\\
\par              +         +                       +  O   O  +
\par              |    6    |                       |    6    |
\par              |3O  O  O1|                       |    O    |
\par              |         |                       |         |
\par              +  O   O  +                       +  O   O  +
\par               \\5  O  4/                         \\4  O  2/
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               \\  2  /                           \\  3  /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                +---+                             +---+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  396   APPENDIX I
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Cassette
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------+--------------------+
\par   |  Pin  |        Type        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------+--------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  A-1  |  GND               |              1 2 3 4 5 6
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  B-2  |  +5V               |          +---@-@-@-@-@-@---+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  C-3  |  CASSETTE MOTOR    |          |                 |
\par   |  D-4  |  CASSETTE READ     |          +---@-@-@-@-@-@---+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  E-5  |  CASSETTE WRITE    |              A B C D E F
\par   |  F-6  |  CASSETTE SENSE    |
\par   +-------+--------------------+
\par 
\par   User I/O
\par 
\par   +-----+---------------+-----------+   +-----+---------------+-----------+
\par   | Pin |      Type     |    Note   |   | Pin |      Type     |    Note   |
\par   +-----+---------------+-----------+   +-----+---------------+-----------+
\par   |   1 |  GND          |           |   |  A  |  GND          |           |
\par   |   2 |  +5V          |MAX. 100 mA|   |  B  |  /FLAG2       |           |
\par   |   3 |  /RESET       |           |   |  C  |  PB0          |           |
\par   |   4 |  CNT1         |           |   |  D  |  PB1          |           |
\par   |   5 |  SP1          |           |   |  E  |  PB2          |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   6 |  CNT2         |           |   |  F  |  PB3          |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   7 |  SP2          |           |   |  H  |  PB4          |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   8 |  /PC2         |           |   |  I  |  PB5          |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   9 |  SER. ATN OUT |           |   |  K  |  PB6          |           |
\par   |  10 |  9 VAC        |MAX. 100 mA|   |  L  |  PB7          |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  11 |  9 VAC        |MAX. 100 mA|   |  M  |  PA2          |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  12 |  GND          |           |   |  N  |  GND          |           |
\par   +-----+---------------+-----------+   +-----+---------------+-----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                              1 1 1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           1 2 3 4 5 6 7 8 9 0 1 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        +--@-@-@-@-@-@-@-@-@-@-@-@--+
\par                         |                           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        +--@-@-@-@-@-@-@-@-@-@-@-@--+
\par                            A B C D E F H J K L M N
\par 
\par 
\par 
\par 
\par                                                            APPENDIX I   397
\par \page 
\par 
\par 
\par   APPENDIX J
\par 
\par 
\par   CONVERTING STANDARD
\par   BASIC PROGRAMS TO
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  COMMODORE 64 BASIC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     If you have programs written in a BASIC other than Commodore BASIC,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  some minor adjustments may be necessary before running them on the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Commodore-64. We've included some hints to make the conversion easier.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  String Dimensions
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Delete all statements that are used to declare the length of strings.
\par   A statement such as DIM A$(I,J), which dimensions a string array for J
\par   elements of length I, should be converted to the Commodore BASIC
\par   statement DIM A$(J).
\par     Some BASICs use a comma or an ampersand for string concatenation. Each
\par   of these must be changed to a plus sign, which is the Commodore BASIC
\par   operator for string concatenation.
\par     In Commodore-64 BASIC, the MID$, RIGHT$, and LEFT$ functions are used
\par   to take substrings of strings. Forms such as A$(I) to access the Ith
\par   character in A$, or A$(I,J) to take a substring of A$ from position I to
\par   J, must be changed as follows:
\par 
\par   Other BASIC     Commodore 64 BASIC
\par 
\par   A$(I)=X$        A$=LEFT$(A$,I-1)+X$+MID$(A$,I+1)
\par   A$(I,J)=X$      A$=LEFT$(A$,I-1)+X$+MID$(A$,J+1)
\par 
\par   Multiple Assignments
\par 
\par     To set B and C equal to zero, some BASICs allow statements of the form:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 LET B=C=0
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  398   APPENDIX J
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Commodore 64 BASIC would interpret the second equal sign as a logical
\par   operator and set B = -1 if C = 0. Instead, convert this statement to:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  10 C=0:B=0
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Multiple Statements
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Some BASICs use a backslash to separate multiple statements on a line.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  With Commodore 64 BASIC, separate all statements by a colon (:).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   MAT Functions
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Programs using the MAT functions available on some BASICs must be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  rewritten using FOR...NEXT loops to execute properly.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX J   399
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   APPENDIX K
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   ERROR MESSAGES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     This appendix contains a complete list of the error messages generated
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  by the Commodore-64, with a description of causes.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BAD DATA            String data was received from an open file, but the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      program was expecting numeric data.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BAD SUBSCRIPT       The program was trying to reference an element of an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      array whose number is outside of the range specified
\par                       in the DIM statement.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BREAK               Program execution was stopped because you hit the
\par                       <STOP> key.
\par   CAN'T CONTINUE      The CONT command will not work, either because the
\par                       program was never RUN, there has been an error, or
\par                       a line has been edited.
\par   DEVICE NOT PRESENT  The required I/O device was not available for an
\par                       OPEN, CLOSE, CMD, PRINT#, INPUT#, or GET#.
\par   DIVISION BY ZERO    Division by zero is a mathematical oddity and not
\par                       allowed.
\par   EXTRA IGNORED       Too many items of data were typed in response to an
\par                       INPUT statement. Only the first few items were
\par                       accepted.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FILE NOT FOUND      If you were looking for a file on tape, and END-OF-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      TAPE marker was found. If you were looking on disk,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      no file with that name exists.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FILE NOT OPEN       The file specified in a CLOSE, CMD, PRINT#, INPUT#,
\par                       or GET#, must first be OPENed.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FILE OPEN           An attempt was made to open a file using the number
\par                       of an already open file.
\par   FORMULA TOO COMPLEX The string expression being evaluated should be split
\par                       into at least two parts for the system to work with,
\par                       or a formula has too many parentheses.
\par   ILLEGAL DIRECT      The INPUT statement can only be used within a pro-
\par                       gram, and not in direct mode.
\par   ILLEGAL QUANTITY    A number used as the argument of a function or
\par                       statement is out of the allowable range.
\par 
\par 
\par   400   APPENDIX K
\par \page 
\par 
\par 
\par   LOAD                There is a problem with the program on tape.
\par   NEXT WITHOUT FOR    This is caused by either incorrectly nesting loops or
\par                       having a variable name in a NEXT statement that
\par                       doesn't correspond with one in a FOR statement.
\par   NOT INPUT FILE      An attempt was made to INPUT or GET data from a file
\par                       which was specified to be for output only.
\par   NOT OUTPUT FILE     An attempt was mode to PRINT data to a file which was
\par                       specified as input only.
\par   OUT OF DATA         A READ statement was executed but there is no data
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      left unREAD in a DATA statement.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  OUT OF MEMORY       There is no more RAM available for program or
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      variables. This may also occur when too many FOR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      loops have been nested, or when there are too many
\par                       GOSUBs in effect.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  OVERFLOW            The result of a computation is larger than the
\par                       largest number allowed, which is 1.70141884E+38.
\par   REDIM'D ARRAY       An array may only be DiMensioned once. If an array
\par                       variable is used before that array is DIM'D, an
\par                       automatic DIM operation is performed on that array
\par                       setting the number of elements to ten, and any
\par                       subsequent DIMs will cause this error.
\par   REDO FROM START     Character data was typed in during an INPUT statement
\par                       when numeric data was expected. Just re-type the
\par                       entry so that it is correct, and the program will
\par                       continue by itself.
\par   RETURN WITHOUT GOSUB  A RETURN statement was encountered, and no GOSUB
\par                       command has been issued.
\par   STRING TOO LONG     A string can contain up to 255 characters.
\par   ?SYNTAX ERROR       A statement is unrecognizable by the Commodore 64. A
\par                       missing or extra parenthesis, misspelled keywords,
\par                       etc.
\par   TYPE MISMATCH       This error occurs when a number is used in place of a
\par                       string, or vice-versa.
\par   UNDEF'D FUNCTION    A user defined function was referenced, but it has
\par                       never been defined using the DEF FN statement.
\par   UNDEF'D STATEMENT   An attempt was made to GOTO or GOSUB or RUN a line
\par                       number that doesn't exist.
\par   VERIFY              The program on tape or disk does not match the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      program currently in memory.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX K   401
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   APPENDIX L
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   6510 MICROPROCESSOR CHIP
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SPECIFICATIONS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The 6510 is a low-cost microcomputer system capable of solving a broad
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  range of small-systems and peripheral-control problems at minimum cost to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the user.
\par     An 8-bit Bi-Directional I/O Port is located on-chip with the Output
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Register at Address 0000 and the Data-Direction Register at Address 0001.
\par   The I/O Port is bit-by-bit programmable.
\par     The Three-State sixteen-bit Address Bus allows Direct Memory Accessing
\par   (DMA) and multiprocessor systems sharing a common memory.
\par     The internal processor architecture is identical to the MOS Technology
\par   6502 to provide software compatibility.
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FEATURES OF THE 6510...
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   o Eight-Bit Bi-Directional I/O Port
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o Single +5-volt supply
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o N-channel, silicon gate, depletion load technology
\par   o Eight-bit parallel processing
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o 56 Instructions
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o Decimal and binary arithmetic
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o Thirteen addressing modes
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o True indexing capability
\par   o Programmable stack pointer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o Variable length stack
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o Interrupt capability
\par   o Eight-Bit Bi-Directional Data Bus
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o Addressable memory range of up to 64K bytes
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o Direct memory access capability
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o Bus compatible with M6800
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o Pipeline architecture
\par   o 1-MHz and 2-MHz operation
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o Use with any type or speed memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  402  APPENDIX L
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                               PIN CONFIGURATION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                +----+ +----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     01 IN   1 @|    +-+    |@ 40  /RES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                        RDY   2 @|           |@ 39  02 IN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      /IRQ   3 @|           |@ 38  R/W
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      /NMI   4 @|           |@ 37  D0
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       AEC   5 @|           |@ 36  D1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       VCC   6 @|           |@ 35  D2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                         A0   7 @|           |@ 34  D3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        A1   8 @|           |@ 33  D4
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        A2   9 @|           |@ 32  D5
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        A3  10 @|           |@ 31  D6
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |    6510   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        A4  11 @|           |@ 30  D7
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                         A5  12 @|           |@ 29  P0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        A6  13 @|           |@ 28  P1
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        A7  14 @|           |@ 27  P2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        A8  15 @|           |@ 26  P3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                         A9  16 @|           |@ 25  P4
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       A10  17 @|           |@ 24  P5
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       A11  18 @|           |@ 23  A15
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       A12  19 @|           |@ 22  A14
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                        A13  20 @|           |@ 21  GND
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                +-----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX L   403
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         [THE PICTURE IS MISSING!]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                             6510 BLOCK DIAGRAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  404   APPENDIX L
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   6510 CHARACTERISTICS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  MAXIMUM RATINGS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +--------------------------+------------+-----------------+-------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |          RATING          |   SYMBOL   |      VALUE      |    UNIT     |
\par   +--------------------------+------------+-----------------+-------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  SUPPLY VOLTAGE          |    Vcc     |   -0.3 to +7.0  |     VDC     |
\par   |  INPUT VOLTAGE           |    Vin     |   -0.3 to +7.0  |     VDC     |
\par   |  OPERATING TEMPERATURE   |    Ta      |    0 to +70     |   Celsius   |
\par   |  STORAGE TEMPERATURE     |    Tstg    |   -55 to +150   |   Celsius   |
\par   +--------------------------+------------+-----------------+-------------+
\par   +-----------------------------------------------------------------------+
\par   | NOTE: This device contains input protection against damage due to high|
\par   | static voltages or electric fields; however, precautions should be    |
\par   | taken to avoid application of voltages higher than the maximum rating.|
\par   +-----------------------------------------------------------------------+
\par 
\par   ELECTRICAL CHARACTERISTICS  (VCC=5.0V +-5%, VSS=0, Ta=0 to +70 Celsius)
\par   +------------------------------------+--------+-------+---+-------+-----+
\par   |           CHARACTERISTIC           | SYMBOL |  MIN. |TYP|  MAX. |UNIT |
\par   +------------------------------------+--------+-------+---+-------+-----+
\par   | Input High Voltage                 |        |       |   |       |     |
\par   |   01, 02(in)                       |  Vih   |Vcc-0.2| - |Vcc+1.0| VDC |
\par   | Input High Voltage                 |        |       |   |       |     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | /RES, P0-P7, /IRQ, Data            |        |Vss+2.0| - |   -   | VDC |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------------+--------+-------+---+-------+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Input Low Voltage                  |        |       |   |       |     |
\par   | 01,02(in)                          |  Vil   |Vss-0.3| - |Vss+0.2| VDC |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | /RES, P0-P7, /IRQ, Data            |        |   -   | - |Vss+0.8| VDC |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------------+--------+-------+---+-------+-----+
\par   | Input Leakage Current              |        |       |   |       |     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   (Vin=0 to 5.25V, Vcc=5.25V       |        |       |   |       |     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   Logic                            |  Iin   |   -   | - |  2.5  |  uA |
\par   |   01, 02(in)                       |        |   -   | - |  100  |  uA |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------------+--------+-------+---+-------+-----+
\par   | Three State(Off State)Input Current|        |       |   |       |     |
\par   | (Vin=0.4 to 2.4V, Vcc=5.25V)       |        |       |   |       |     |
\par   |   Data Lines                       |  Itsi  |   -   | - |   10  |  uA |
\par   +------------------------------------+--------+-------+---+-------+-----+
\par   | Output High Voltage                |        |       |   |       |     |
\par   | (Ioh=-100uADC, Vcc=4.75V)          |        |       |   |       |     |
\par   |   Data, A0-A15, R/W, P0-P7         |  Voh   |Vss+2.4| - |   -   | VDC |
\par   +------------------------------------+--------+-------+---+-------+-----+
\par                                                            APPENDIX L   405
\par \page 
\par 
\par 
\par   +------------------------------------+--------+-------+---+-------+-----+
\par   |           CHARACTERISTIC           | SYMBOL |  MIN. |TYP|  MAX. |UNIT |
\par   +------------------------------------+--------+-------+---+-------+-----+
\par   | Out Low Voltage                    |        |       |   |       |     |
\par   | (Iol=1.6mADC, Vcc=4.75V)           |        |       |   |       |     |
\par   |   Data, A0-A15, R/W, P0-P7         |   Vol  |   -   | - |Vss+0.4| VDC |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------------+--------+-------+---+-------+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Power Supply Current               |   Icc  |   -   |125|       |  mA |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------------+--------+-------+---+-------+-----+
\par   | Capacitance                        |   C    |       |   |       |  pF |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Vin=0, Ta=25 Celsius, f=1MHz)      |        |       |   |       |     |
\par   |   Logic, P0-P7                     |   Cin  |   -   | - |   10  |     |
\par   |   Data                             |        |   -   | - |   15  |     |
\par   |   A0-A15, R/W                      |   Cout |   -   | - |   12  |     |
\par   |   01                               |   C01  |   -   | 30|   50  |     |
\par   |   02                               |   C02  |   -   | 50|   80  |     |
\par   +------------------------------------+--------+-------+---+-------+-----+
\par 
\par                                CLOCK TIMING
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                           [THE PICTURE IS MISSING!]
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               TIMING FOR READING DATA FROM MEMORY OR PERIPHERALS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   406   APPENDIX L
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                CLOCK TIMING
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         [THE PICTURE IS MISSING!]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                TIMING FOR WRITING DATA TO MEMORY OR PERIPHERALS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                            APPENDIX L   407
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  AC CHARACTERISTICS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ELECTRICAL CHARACTERISTICS (Vcc=5V +-5%, Vss=0V, Ta=0-70 Celsius)
\par 
\par         CLOCK TIMING                        1 MHz TIMING 2 MHz TIMING
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | CHARACTERISTIC                  |SYMBOL|MIN.|TYP|MAX|MIN|TYP|MAX|UNITS|
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Cycle Time                      | Tcyc |1000| - | - |500| - | - | ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Clock Pulse Width 01            |PWH01 | 430| - | - |215| - | - | ns  |
\par   | (Measured at Vcc-0.2V) 02       |PWH02 | 470| - | - |235| - | - | ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Fall Time, Rise Time            |      |    |   |   |   |   |   |     |
\par   | (Measured from 0.2V to Vcc-0.2V)|Tf, Tr|  - | - | 25| - | - | 15| ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Delay Time between Clocks       |      |    |   |   |   |   |   |     |
\par   | (Measured at 0.2V)              |  Td  |  0 | - | - | 0 | - | - | ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par 
\par   READ/WRITE TIMING (LOAD=1TTL)             1 MHz TIMING 2 MHz TIMING
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | CHARACTERISTIC                  |SYMBOL|MIN.|TYP|MAX|MIN|TYP|MAX|UNITS|
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Read/Write Setup Time from 6508 | Trws |  - |100|300| - |100|150| ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Address Setup Time from 6508    | Tads |  - |100|300| - |100|150| ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Memory Read Access Time         | Tacc |  - | - |575| - | - |300| ns  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Data Stability Time Period      | Tdsu | 100| - | - | 50|   |   | ns  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Data Hold Time-Read             | Thr  |    | - | - |   |   |   | ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Data Hold Time-Write            | Thw  |  10| 30| - | 10| 30|   | ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Data Setup Time from 6510       | Tmds |  - |150|200| - | 75|100| ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Address Hold Time               | Tha  |  10| 30| - | 10| 30|   | ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | R/W Hold Time                   | Thrw |  10| 30| - | 10| 30|   | ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par 
\par   408   APPENDIX L
\par \page 
\par 
\par 
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Delay Time, Address valid to    |      |    |   |   |   |   |   |     |
\par   | 02 positive transition          | Taew | 180| - | - |   |   |   | ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Delay Time, 02 positive         |      |    |   |   |   |   |   |     |
\par   | transition to Data valid on bus | Tedr |  - | - |395|   |   |   | ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Delay Time, data valid to 02    |      |    |   |   |   |   |   |     |
\par   | negative transition             | Tdsu | 300| - | - |   |   |   | ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Delay Time, R/W negative        |      |    |   |   |   |   |   |     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | transition to 02 positive trans.| Twe  | 130| - | - |   |   |   | ns  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Delay Time, 02 negative trans.  |      |    |   |   |   |   |   |     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | to Peripheral data valid        | Tpdw |  - | - | 1 |   |   |   | us  |
\par   +---------------------------------+------+----+---+---+---+---+---+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Peripheral Data Setup Time      | Tpdsu| 300| - | - |   |   |   | ns  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------------------------------+------+----+---+---+---+---+---+-----+
\par   | Address Enable Setup Time       | Taes |    |   | 60|   |   | 60| ns  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---------------------------------+------+----+---+---+---+---+---+-----+
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX L   409
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SIGNAL DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Clocks (01, 02)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The 6510 requires a two-phase non-overlapping clock that runs at the
\par   Vcc voltage level.
\par 
\par   Address Bus (A0-A15)
\par 
\par     These outputs are TTL compatible, capable of driving one standard TTL
\par   load and 130 pf.
\par 
\par   Data Bus (D0-D7)
\par 
\par     Eight pins are used for the data bus. This is a Bi-Directional bus,
\par   transferring data to and from the device and peripherals. The outputs are
\par   tri-state buffers capable of driving one standard TTL load and 130 pf.
\par 
\par   Reset
\par 
\par     This input is used to reset or start the microprocessor from a power
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  down condition. During the time that this line is held low, writing to or
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  from the microprocessor is inhibited. When a positive edge is detected on
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the input, the microprocessor will immediately begin the reset sequence.
\par     After a system initialization time of six clock cycles, the mask
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  interrupt flag will be set and the microprocessor will load the program
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  counter from the memory vector locations FFFC and FFFD. This is the start
\par   location for program control.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    After Vcc reaches 4.75 volts in a power-up routine, reset must be held
\par   low for at least two clock cycles. At this time the R/W signal will
\par   become valid.
\par     When the reset signal goes high following these two clock cycles, the
\par   microprocessor will proceed with the normal reset procedure detailed
\par   above.
\par 
\par   Interrupt Request (/IRQ)
\par 
\par     This TTL level input requests that an interrupt sequence begin within
\par   the microprocessor. The microprocessor will complete the current in-
\par   struction being executed before recognizing the request. At that time,
\par   the interrupt mask bit in the Status Code Register will be examined. If
\par   the interrupt mask flag is not set, the microprocessor will begin an
\par 
\par   410   APPENDIX L
\par \page 
\par 
\par 
\par   interrupt sequence. The Program Counter and Processor Status Register are
\par   stored in the stack. The microprocessor will then set the interrupt mask
\par   flag high so that no further interrupts may occur. At the end of this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cycle, the program counter low will be loaded from address FFFE, and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  program counter high from location FFFF, therefore transferring program
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  control to the memory vector located at these addresses.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Address Enable Control (AEC)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The Address Bus is valid only when the Address Enable Control line is
\par   high. When low, the Address Bus is in a high-impedance state. This
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  feature allows easy DMA and multiprocessor systems.
\par 
\par   I/O Port (P0-P7)
\par 
\par     Six pins are used for the peripheral port, which can transfer data to
\par   or from peripheral devices. The Output Register is located in RAM at
\par   address 0001, and the Data Direction Register is at Address 0000. The
\par   outputs are capable at driving one standard TTL load and 130 pf.
\par 
\par   Read/Write (R/W)
\par 
\par     This signal is generated by the microprocessor to control the direction
\par   of data transfers on the Data Bus. This line is high except when the
\par   microprocessor is writing to memory or a peripheral device.
\par 
\par   ADDRESSING MODES
\par 
\par   ACCUMULATOR ADDRESSING - This form of addressing is represented with a
\par   one byte instruction, implying an operation on the accumulator.
\par 
\par   IMMEDIATE ADDRESSING - In immediate addressing, the operand is contained
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in the second byte of the instruction, with no further memory addressing
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  required.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ABSOLUTE ADDRESSING - In absolute addressing, the second byte of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  instruction specifies the eight low order bits of the effective address
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  while the third byte specifies the eight high order bits. Thus, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  absolute addressing mode allows access to the entire 64K bytes of
\par   addressable memory.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ZERO PAGE ADDRESSING - The zero page instructions allow for shorter code
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX L   411
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and execution times by only fetching the second byte of the instruction
\par   and assuming a zero high address byte. Careful use of the zero page can
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  result in significant increase in code efficiency.
\par 
\par   INDEXED ZERO PAGE ADDRESSING - (X, Y indexing)-This form of addressing is
\par   used in conjunction with the index register and is referred to as "Zero
\par   Page, X" or "Zero Page, Y." The effective address is calculated by adding
\par   the second byte to the contents of the index register. Since this is a
\par   form of "Zero Page" addressing, the content of the second byte references
\par   a location in page zero. Additionally, due to the "Zero Page" addressing
\par   nature of this mode, no carry is added to the high order 8 bits of memory
\par   and crossing of page boundaries does not occur.
\par 
\par   INDEXED ABSOLUTE ADDRESSING - (X, Y indexing)-This form of addressing is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  used in conjunction with X and Y index register and is referred to as
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  "Absolute, X," and "Absolute, Y." The effective address is formed by
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  adding the contents of X and Y to the address contained in the second and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  third bytes of the instruction. This mode allows the index register to
\par   contain the index or count value and the instruction to contain the base
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  address. This type of indexing allows any location referencing and the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  index to modify multiple fields resulting in reduced coding and execution
\par   time.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  IMPLIED ADDRESSING - In the implied addressing mode, the address
\par   containing the operand is implicitly stated in the operation code of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  instruction.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   RELATIVE ADDRESSING - Relative addressing is used only with branch
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  instructions and establishes a destination for the conditional branch.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   The second byte of the instruction becomes the operand which is an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  "Offset" added to the contents of the lower eight bits of the program
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  counter when the counter is set at the next instruction. The range of the
\par   offset is -128 to +127 bytes from the next instruction.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INDEXED INDIRECT ADDRESSING - In indexed indirect addressing (referred to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  as [Indirect, X]), the second byte of the instruction is added to the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  contents of the X index register, discarding the carry. The result of
\par   this addition points to a memory location on page zero whose contents is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the low order eight bits of the effective address. The next memory loca-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  tion in page zero contains the high order eight bits of the effective ad-
\par   dress. Both memory locations specifying the high and low order bytes of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  412   APPENDIX L
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the effective address must be in page zero.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   INDIRECT INDEXED ADDRESSING - In indirect indexed addressing (referred to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  as [Indirect], Y), the second byte of the instruction points to a memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  location in page zero. The contents of this memory location is added to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the contents of the Y index register, the result being the low order
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  eight bits of the effective address. The carry from this addition is
\par   added to the contents of the next page zero memory location, the result
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  being the high order eight bits of the effective address.
\par 
\par   ABSOLUTE INDIRECT - The second byte of the instruction contains the low
\par   order eight bits of a memory location. The high order eight bits of that
\par   memory location is contained in the third byte of the instruction. The
\par   contents of the fully specified memory location is the low order byte of
\par   the effective address. The next memory location contains the high order
\par   byte of the effective address which is loaded into the sixteen bits of
\par   the program counter.
\par 
\par   INSTRUCTION SET - ALPHABETIC SEQUENCE
\par 
\par           ADC   Add Memory to Accumulator with Carry
\par           AND   "AND" Memory with Accumulator
\par           ASL   Shift left One Bit (Memory or Accumulator)
\par 
\par           BCC   Branch on Carry Clear
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          BCS   Branch on Carry Set
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          BEQ   Branch on Result Zero
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          BIT   Test Bits in Memory with Accumulator
\par           BMI   Branch on Result Minus
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          BNE   Branch on Result not Zero
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          BPL   Branch on Result Plus
\par           BRK   Force Break
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          BVC   Branch on Overflow Clear
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          BVS   Branch on Overflow Set
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          CLC   Clear Carry Flag
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          CLD   Clear Decimal Mode
\par           CLI   Clear Interrupt Disable Bit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          CLV   Clear Overflow Flag
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          CMP   Compare Memory and Accumulator
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          CPX   Compare Memory and Index X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          CPY   Compare Memory and Index Y
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX L   413
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          DEC   Decrement Memory by One
\par           DEX   Decrement Index X by One
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          DEY   Decrement Index Y by One
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par           EOR   "Exclusive-OR" Memory with Accumulator
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          INC   Increment Memory by One
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          INX   Increment Index X by one
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          INY   Increment Index Y by one
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          JMP   Jump to New location
\par           JSR   Jump to New Location Saving Return Address
\par 
\par           LDA   Load Accumulator with Memory
\par           LDX   Load Index X with Memory
\par           LDY   Load Index Y with Memory
\par           LSR   Shift One Bit Right (Memory or Accumulator)
\par 
\par           NOP   No Operation
\par 
\par           ORA   "OR" Memory with Accumulator
\par 
\par           PHA   Push Accumulator on Stack
\par           PHP   Push Processor Status on Stack
\par           PLA   Pull Accumulator from Stack
\par           PLP   Pull Processor Status from Stack
\par 
\par           ROL   Rotate One Bit Left (Memory or Accumulator)
\par           ROR   Rotate One Bit Right (Memory or Accumulator)
\par           RTI   Return from Interrupt
\par           RTS   Return from Subroutine
\par 
\par           SBC   Subtract Memory from Accumulator with Borrow
\par           SEC   Set Carry Flag
\par           SED   Set Decimal Mode
\par           SEI   Set Interrupt Disable Status
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          STA   Store Accumulator in Memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          STX   Store Index X in Memory
\par           STY   Store Index Y in Merrory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  414   APPENDIX L
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par           TAX   Transfer Accumulator to Index X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          TAY   Transfer Accumulator to Index Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          TSX   Transfer Stack Pointer to Index X
\par           TXA   Transfer Index X to Accumulator
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {          TXS   Transfer Index X to Stack Register
\par           TYA   Transfer Index Y to Accumulator
\par 
\par 
\par   PROGRAMMING MODEL
\par                         +---------------+
\par                         |       A       |  ACCUMULATOR           A
\par                         +---------------+
\par 
\par                         +---------------+
\par                         |       Y       |  INDEX REGISTER        Y
\par                         +---------------+
\par 
\par                         +---------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        |       X       |  INDEX REGISTER        X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        +---------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        15               7             0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        +---------------+---------------+
\par         |      PCH      |      PCL      |  PROGRAM COUNTER     "PC"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        +---------------+---------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       8 7             0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      +-+---------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      |1|       S       |  STACK POINTER        "S"
\par                       +-+---------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         7             0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        +-+-+-+-+-+-+-+-+
\par                         |N|V| |B|D|I|Z|C|  PROCESSOR STATUS REG "P"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        +-+-+-+-+-+-+-+-+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         | |   | | | | |
\par                          | |   | | | | +>  CARRY         1=TRUE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         | |   | | | +-->  ZERO          1=RESULT ZERO
\par                          | |   | | +---->  IRQ DISABLE   1=DISABLE
\par                          | |   | +------>  DECIMAL MODE  1=TRUE
\par                          | |   +-------->  BRK COMMAND
\par                          | |
\par                          | +------------>  OVERFLOW      1=TRUE
\par                          +-------------->  NEGATIVE      1=NEG
\par 
\par 
\par                                                            APPENDIX L   415
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      INSTRUCTION SET - OP CODES, EXECUTION TIME, MEMORY REQUIREMENTS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          [THE PICTURE IS MISSING!]
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTE: COMMODORE SEMICONDUCTOR GROUP cannot assume liability for the   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | use of undefined OP CODES.                                            |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  416   APPENDIX L
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      INSTRUCTION SET - OP CODES, EXECUTION TIME, MEMORY REQUIREMENTS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          [THE PICTURE IS MISSING!]
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX L   417
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  6510 MEMORY MAP
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       +-------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FFFF |                   |
\par        |    ADDRESSABLE    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       /      EXTERNAL     /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       /       MEMORY      /
\par        |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  0200 |                   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       +-------------------+           STACK
\par   01FF |  |    STACK    |  | 01FF <--- POINTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  0100 | \\|/   Page 1  \\|/ |           INITIALIZED
\par        +-------------------+
\par   00FF |                   |
\par        |       Page 0      |
\par        +-------------------+
\par        |  OUTPUT REGISTER  | 0001 <-+- Used For
\par        +-------------------+        |  Internal
\par   0000 |DATA DIRECTION REG.| 0000 <-+  I/O Port
\par        +-------------------+
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  APPLICATIONS NOTES
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Locating the Output Register at the internal I/O Port in Page Zero
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  enhances the powerful Zero Page Addressing instructions of the 6510.
\par     By assigning the I/O Pins as inputs (using the Data Direction Register)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the user has the ability to change the contents of address 0001 (the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Output Register) using peripheral devices. The ability to change these
\par   contents using peripheral inputs, together with Zero Page Indirect
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Addressing instructions, allows novel and versatile programming tech-
\par   niques not possible earlier.
\par 
\par   +-----------------------------------------------------------------------+
\par   | COMMODORE SEMICONDUCTOR GROUP reserves the right to make changes to   |
\par   | any products herein to improve reliability, function or design.       |
\par   | COMMODORE SEMICONDUCTOR GROUP does not assume any liability arising   |
\par   | out of the application or use of any product or circuit described     |
\par   | herein; neither does it convey any license under its patent rights nor|
\par   | the rights of others.                                                 |
\par   +-----------------------------------------------------------------------+
\par 
\par   418   APPENDIX L
\par \page 
\par 
\par 
\par   APPENDIX M
\par 
\par 
\par   6526 COMPLEX INTERFACE ADAPTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (CIA) CHIP SPECIFICATIONS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The 6526 Complex Interface Adapter (CIA) is a 65XX bus compatible
\par   peripheral interface device with extremely flexible timing and I/O
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  capabilities.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FEATURES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   o 16 Individually programmable 110 lines
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o 8 or 16-Bit handshaking on read or write
\par   o 2 independent, linkable 16-Bit interval timers
\par   o 24-hour (AM/PM) time of day clock with programmable alarm
\par   o 8-Bit shift register for serial I/O
\par   o 2 TTL load capability
\par   o CMOS compatible I/O lines
\par   o 1 or 2 MHz operation available
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX M   419
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                               PIN CONFIGURATION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                +----+ +----+
\par                        Vss   1 @|    +-+    |@ 40  CNT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       PA0   2 @|           |@ 39  SP
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       PA1   3 @|           |@ 38  RS0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       PA2   4 @|           |@ 37  RS1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                        PA3   5 @|           |@ 36  RS2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       PA4   6 @|           |@ 35  RS3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       PA5   7 @|           |@ 34  /RES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                        PA6   8 @|           |@ 33  D0
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                        PA7   9 @|           |@ 32  D1
\par                                 |           |
\par                        PB0  10 @|           |@ 31  D2
\par                                 |    6526   |
\par                        PB1  11 @|           |@ 30  D3
\par                                 |           |
\par                        PB2  12 @|           |@ 29  D4
\par                                 |           |
\par                        PB3  13 @|           |@ 28  D5
\par                                 |           |
\par                        PB4  14 @|           |@ 27  D6
\par                                 |           |
\par                        PB5  15 @|           |@ 26  D7
\par                                 |           |
\par                        PB6  16 @|           |@ 25  02
\par                                 |           |
\par                        PB7  17 @|           |@ 24  /FLAG
\par                                 |           |
\par                        /PC  18 @|           |@ 23  /CS
\par                                 |           |
\par                        TOD  19 @|           |@ 22  R/W
\par                                 |           |
\par                        Vcc  20 @|           |@ 21  /IRQ
\par                                 +-----------+
\par   420   APPENDIX M
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                             6526 BLOCK DIAGRAM
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                           [THE PICTURE IS MISSING!]
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                            APPENDIX M   421
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  MAXIMUM RATINGS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Supply Voltage, Vcc                   -0.3V to +7.0V
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Input/Output Voltage, Vin             -0.3V to +7.0V
\par   Operating Temperature, Top             0 to 70 Celsius
\par   Storage Temperature, Tstg             -55 to 150 Celsius
\par 
\par     All inputs contain protection circuitry to prevent damage due to high
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  static discharges. Care should be exercised to prevent unnecessary ap-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  plication of voltages in excess of the allowable limits.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  COMMENT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Stresses above those listed under "Absolute Maximum Ratings" may cause
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  permanent damage to the device. These are stress ratings oily. Functional
\par   operation of this device at these or any other conditions above those
\par   indicated in the operational sections of this specification is not
\par   implied and exposure to absolute maximum rating conditions for extended
\par   periods may affect device reliability.
\par 
\par 
\par 
\par 
\par 
\par   ELECTRICAL CHARACTERISTICS (Vcc +-5%, Vss=0V, Ta=0-70 Celsius)
\par 
\par   +-------------------------------+--------+-------+-------+-------+------+
\par   | CHARACTERISTIC                | SYMBOL | MIN.  | TYP.  | MAX.  | UNIT |
\par   +-------------------------------+--------+-------+-------+-------+------+
\par   | Input High Voltage            |  Vih   | +2.4  |   -   |  Vcc  |   V  |
\par   +-------------------------------+--------+-------+-------+-------+------+
\par   | Input Low Voltage             |  Vil   | -0.3  |   -   |   -   |   V  |
\par   +-------------------------------+--------+-------+-------+-------+------+
\par   | Input Leakage Current;        |  Iin   |   -   |  1.0  |  2.5  |  uA  |
\par   | Vin=Vss+5V                    |        |       |       |       |      |
\par   | (TOD, R/W, /FLAG, 02,         |        |       |       |       |      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | /RES, RS0-RS3, /CS)           |        |       |       |       |      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------------------------------+--------+-------+-------+-------+------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  422   APPENDIX M
\par \page 
\par 
\par 
\par   +-------------------------------+--------+-------+-------+-------+------+
\par   | CHARACTERISTIC                | SYMBOL | MIN.  | TYP.  | MAX.  | UNIT |
\par   +-------------------------------+--------+-------+-------+-------+------+
\par   | Port Input Pull-up Resistance |  Rpi   |  3.1  |  5.0  |   -   | kohms|
\par   +-------------------------------+--------+-------+-------+-------+------+
\par   | Output Leakage Current for    |  Itsi  |   -   |+-1.0  |+-10.0 |  uA  |
\par   | High Impedance State (Three   |        |       |       |       |      |
\par   | State); Vin=4V to 2.4V;       |        |       |       |       |      |
\par   | (D0-D7, SP, CNT, /IRQ)        |        |       |       |       |      |
\par   +-------------------------------+--------+-------+-------+-------+------+
\par   | Output High Voltage           |  Voh   | +2.4  |   -   |  Vcc  |   V  |
\par   | Vcc=MIN, Iload <              |        |       |       |       |      |
\par   | -200uA (PA0-PA7, /PC,         |        |       |       |       |      |
\par   | PB0-PB7, D0-D7)               |        |       |       |       |      |
\par   +-------------------------------+--------+-------+-------+-------+------+
\par   | Output Low Voltage            |  Vol   |   -   |   -   | +0.40 |   V  |
\par   | Vcc=MIN, Iload < 3.2 mA       |        |       |       |       |      |
\par   +-------------------------------+--------+-------+-------+-------+------+
\par   | Output High Current (Sourcing)|  Ioh   | -200  | -1000 |   -   |  uA  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Voh > 2.4V (PA0-PA7,          |        |       |       |       |      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | PB0-PB7, /PC, D0-D7           |        |       |       |       |      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------------------------------+--------+-------+-------+-------+------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Output Low Current (Sinking); |  Iol   |  3.2  |   -   |   -   |  mA  |
\par   | Vol <  .4V (PA0-PA7, /PC,     |        |       |       |       |      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | PB0-PB7, D0-D7                |        |       |       |       |      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------------------------------+--------+-------+-------+-------+------+
\par   | Input Capacitance             |  Cin   |   -   |    7  |   10  |  pf  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-------------------------------+--------+-------+-------+-------+------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Output Capacitance            |  Cout  |   -   |    7  |   10  |  pf  |
\par   +-------------------------------+--------+-------+-------+-------+------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Power Supply Current          |  Icc   |   -   |   70  |  100  |  mA  |
\par   +-------------------------------+--------+-------+-------+-------+------+
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                                            APPENDIX M   423
\par \page 
\par 
\par 
\par                          6526 WRITE TIMING DIAGRAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                           [THE PICTURE IS MISSING!]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  424   APPENDIX M
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                           6526 READ TIMING DIAGRAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          [THE PICTURE IS MISSING!]
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                            APPENDIX M   425
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  6526 INTERFACE SIGNALS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   02-Clock Input
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The 02 clock is a TTL compatible input used for internal device opera-
\par   tion and as a timing reference for communicating with the system data
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  bus.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   /CS-Chip Select Input
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The /CS input controls the activity of the 6526. A low level on /CS
\par   while 02 is high causes the device to respond to signals on the R/W and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  address (RS) lines. A high on /CS prevents these lines from controlling
\par   the 6526. The /CS line is normally activated (low) at 02 by the
\par   appropriate address combination.
\par 
\par   R/W-Read/Write Input
\par 
\par     The R/W signal is normally supplied by the microprocessor and controls
\par   the direction of data transfers of the 6526. A high on R/W indicates
\par   a read (data transfer out of the 6526), while a low indicates a write
\par   (data transfer into the 6526).
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RS3-RS0-Address Inputs
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The address inputs select the internal registers as described by the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Register Map.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   DB7-DB0-Data Bus Inputs/Outputs
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The eight data bus pins transfer information between the 6526 and the
\par   system data bus. These pins are high impedance inputs unless CS is low
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and R/W and 02 are high to read the device. During this read, the data
\par   bus output buffers are enabled, driving the data from the selected
\par   register onto the system data bus.
\par 
\par   IRQ-Interrupt Request Output
\par 
\par     IRQ is an open drain output normally connected to the processor inter-
\par   rupt input. An external pullup resistor holds the signal high, allowing
\par   multiple IRQ outputs to be connected together. The IRQ output is normally
\par 
\par 
\par   426   APPENDIX M
\par \page 
\par 
\par 
\par   off (high impedance) and is activated low as indicated in the functional
\par   description.
\par 
\par   /RES-Reset Input
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    A low on the RES pin resets all internal registers. The port pins are
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  set as inputs and port registers to zero (although a read of the ports
\par   will return all highs because of passive pullups). The timer control
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  registers are set to zero and the timer latches to all ones. All other
\par   registers are reset to zero.
\par 
\par                         6526 TIMING CHARACTERISTICS
\par   +--------+-----------------------+---------------+---------------+------+
\par   |        |                       |      1MHz     |      2MHz     |      |
\par   |        |                       +-------+-------+-------+-------+      |
\par   | Symbol |    Characteristic     |  MIN  |  MAX  |  MIN  |  MAX  | Unit |
\par   +--------+-----------------------+-------+-------+-------+-------+------+
\par   |        | 02 CLOCK              |       |       |       |       |      |
\par   | Tcyc   | Cycle Time            |  1000 |20,000 |   500 |20,000 |  ns  |
\par   | Tr, Tf | Rise and Fall Time    |   -   |    25 |   -   |    25 |  ns  |
\par   | Tchw   | Clock Pulse Width     |       |       |       |       |      |
\par   |        |   (High)              |   420 |10,000 |   200 |10,000 |  ns  |
\par   | Tclw   | Clock Pulse Width     |       |       |       |       |      |
\par   |        |   (Low)               |   420 |10,000 |   200 |10,000 |  ns  |
\par   +--------+-----------------------+-------+-------+-------+-------+------+
\par   |        | WRITE CYCLE           |       |       |       |       |      |
\par   | Tpd    | Output Delay From 02  |    -  |  1000 |   -   |   500 |  ns  |
\par   | Twcs   | /CS low while 02 high |   420 |   -   |   200 |   -   |  ns  |
\par   | Tads   | Address Setup Time    |     0 |   -   |     0 |   -   |  ns  |
\par   | Tadh   | Address Hold Time     |    10 |   -   |     5 |   -   |  ns  |
\par   | Trws   | R/W Setup Time        |     0 |   -   |     0 |   -   |  ns  |
\par   | Trwh   | R/W Hold Time         |     0 |   -   |     0 |   -   |  ns  |
\par   | Tds    | Data Bus Setup Time   |   150 |   -   |    75 |   -   |  ns  |
\par   | Tdh    | Data Bus Hold Time    |     0 |   -   |     0 |   -   |  ns  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +--------+-----------------------+-------+-------+-------+-------+------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |        | READ CYCLE            |       |       |       |       |      |
\par   | Tps    | Port Setup Time       |   300 |   -   |   150 |   -   |  ns  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Twcs(2)| /CS low while 02 high |   420 |   -   |    20 |   -   |  ns  |
\par   | Tads   | Address Setup Time    |     0 |   -   |     0 |   -   |  ns  |
\par   | Tadh   | Address Hold Time     |    10 |   -   |     5 |   -   |  ns  |
\par   | Trws   | R/W Setup Time        |     0 |   -   |     0 |   -   |  ns  |
\par   | Trwh   | R/W Hold Time         |     0 |   -   |     0 |   -   |  ns  |
\par 
\par                                                            APPENDIX M   427
\par \page 
\par 
\par 
\par   +--------+-----------------------+---------------+---------------+------+
\par   |        |                       |      1MHz     |      2MHz     |      |
\par   |        |                       +-------+-------+-------+-------+      |
\par   | Symbol |    Characteristic     |  MIN  |  MAX  |  MIN  |  MAX  | Unit |
\par   +--------+-----------------------+-------+-------+-------+-------+------+
\par   | Tacc   | Data Access from      |       |       |       |       |      |
\par   |        | RS3-RS0               |   -   |   550 |   -   |   275 |  ns  |
\par   | Tco(3) | Data Access from /CS  |   -   |   320 |   -   |   150 |  ns  |
\par   | Tdr    | Data Release Time     |    50 |   -   |    25 |   -   |  ns  |
\par   +--------+-----------------------+-------+-------+-------+-------+------+
\par 
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTES: 1 -All timings are referenced from Vil max and Vih min on      |
\par   | inputs and Vol max and Voh min on outputs.                            |
\par   |        2 -Twcs is measured from the later of 02 high or /CS low. /CS  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | must be low at least until the end of 02 high.                        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |        3 -Tco is measured from the later of 02 high or /CS low.       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |        Valid data is available only after the later of Tacc or Tco.   |
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                REGISTER MAP
\par   +---+---+---+---+---+----------+----------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |RS3|RS2|RS1|RS0|REG|   NAME   |                                        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +---+---+---+---+---+----------+----------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 0 | 0 | 0 | 0 | 0 | PRA      |  PERIPHERAL DATA REG A                 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 0 | 0 | 0 | 1 | 1 | PRB      |  PERIPHERAL DATA REG B                 |
\par   | 0 | 0 | 1 | 0 | 2 | DDRA     |  DATA DIRECTION REG A                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 0 | 0 | 1 | 1 | 3 | DDRB     |  DATA DIRECTION REG B                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 0 | 1 | 0 | 0 | 4 | TA LO    |  TIMER A LOW REGISTER                  |
\par   | 0 | 1 | 0 | 1 | 5 | TA HI    |  TIMER A HIGH REGISTER                 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 0 | 1 | 1 | 0 | 6 | TB LO    |  TIMER B LOW REGISTER                  |
\par   | 0 | 1 | 1 | 1 | 7 | TB HI    |  TIMER B HIGH REGISTER                 |
\par   | 1 | 0 | 0 | 0 | 8 | TOD 10THS|  10THS OF SECONDS REGISTER             |
\par   | 1 | 0 | 0 | 1 | 9 | TOD SEC  |  SECONDS REGISTER                      |
\par   | 1 | 0 | 1 | 0 | A | TOD MIN  |  MINUTES REGISTER                      |
\par   | 1 | 0 | 1 | 1 | B | TOD HR   |  HOURS-AM/PM REGISTER                  |
\par   | 1 | 1 | 0 | 0 | C | SDR      |  SERIAL DATA REGISTER                  |
\par   | 1 | 1 | 0 | 1 | 0 | ICR      |  INTERRUPT CONTROL REGISTER            |
\par   | 1 | 1 | 1 | 0 | E | CRA      |  CONTROL REG A                         |
\par   | 1 | 1 | 1 | 1 | F | CRB      |  CONTROL REG B                         |
\par   +---+---+---+---+---+----------+----------------------------------------+
\par 
\par   428   APPENDIX M
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   6526 FUNCTIONAL DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  I/O Ports (PRA, PRB, DDRA, DDRB).
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Ports A and B each consist of an 8-bit Peripheral Data Register (PR)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and an 8-bit Data Direction Register (DDR). If a bit in the DDR is set to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a one, the corresponding bit in the PR is an output; if a DDR bit is set
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to a zero, the corresponding PR bit is defined as an input. On a READ,
\par   the PR reflects the information present on the actual port pins (PA0-PA7,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PB0-PB7) for both input and output bits. Port A and Port B have passive
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  pull-up devices as well as active pull-ups, providing both CMOS and TTL
\par   compatibility. Both ports have two TTL load drive capability. In addition
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to normal I/O operation, PB6 and PB7 also provide timer output functions.
\par 
\par   Handshaking
\par 
\par     Handshaking on data transfers can be accomplished using the /PC output
\par   pin and the FLAG input pin. PC will go low for one cycle following a read
\par   or write of PORT B. This signal can be used to indicate "data ready" at
\par   PORT B or "data accepted" from PORT B. Handshaking on 16-bit data
\par   transfers (using both PORT A and PORT B) is possible by always reading or
\par   writing PORT A first. /FLAG is a negative edge sensitive input which can
\par   be used for receiving the /PC output from another 6526, or as a general
\par   purpose interrupt input. Any negative transition of /FLAG will set the
\par   /FLAG interrupt bit.
\par   +-----+---------+------+------+------+------+------+------+------+------+
\par   | REG |  NAME   |  D7  |  D6  |  D5  |  D4  |  D3  |  D2  |  D1  |  D0  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----+---------+------+------+------+------+------+------+------+------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  0  |   PRA   |  PA7 |  PA6 |  PA5 |  PA4 |  PA3 |  PA2 |  PA1 |  PA0 |
\par   |  1  |   PRB   |  PB7 |  PB6 |  PB5 |  PB4 |  PB3 |  PB2 |  PB1 |  PB0 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  2  |  DDRA   | DPA7 | DPA6 | DPA5 | DPA4 | DPA3 | DPA2 | DPA1 | DPA0 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  3  |  DDRB   | DPB7 | DPB6 | DPB5 | DPB4 | DPB3 | DPB2 | DPB1 | DPB0 |
\par   +-----+---------+------+------+------+------+------+------+------+------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Interval Timers (Timer A, Timer B)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Each interval timer consists of a 16-bit read-only Timer Counter and a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  16-bit write-only Timer Latch. Data written to the timer are latched in
\par   the Timer Latch, while data read from the timer are the present contents
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of the Time Counter. The timers can be used independently or linked for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  extended operations. The various timer modes allow generation of long
\par   time delays, variable width pulses, pulse trains and variable frequency
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX M   429
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  waveforms. Utilizing the CNT input, the timers can count external pulses
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  or measure frequency, pulse width and delay times of external signals.
\par   Each timer has an associated control register, providing independent
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  control of the following functions:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Start/Stop
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    A control bit allows the timer to be started or stopped by the micro-
\par   processor at any time.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PB On/Off:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    A control bit allows the timer output to appear on a PORT B output line
\par   (PB6 for TIMER A and PB7 for TIMER B). This function overrides the DDRB
\par   control bit and forces the appropriate PB line to an output.
\par 
\par   Toggle/Pulse
\par 
\par     A control bit selects the output applied to PORT B. On every timer
\par   underflow the output can either toggle or generate a single positive
\par   pulse of one cycle duration. The Toggle output is set high whenever the
\par   timer is started and is set low by /RES.
\par 
\par   One-Shot/Continuous
\par 
\par     A control bit selects either timer mode. In one-shot mode, the timer
\par   will count down from the latched value to zero, generate an interrupt,
\par   reload the latched value, then stop. In continuous mode, the timer will
\par   count from the latched value to zero, generate' an interrupt, reload the
\par   latched value and repeat the procedure continuously.
\par 
\par   Force Load
\par 
\par     A strobe bit allows the timer latch to be loaded into the timer counter
\par   at any time, whether the timer is running or not.
\par 
\par   Input Mode:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Control bits allow selection of the clock used to decrement the timer.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TIMER A can count 02 clock pulses or external pulses applied to the CNT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  pin. TIMER B can count (02 pulses, external CNT pulses, TIMER A underflow
\par   pulses or TIMER A underflow pulses while the CNT pin is held high.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  430   APPENDIX M
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The timer latch is loaded into the timer on any timer underflow, on a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  force load or following a write to the high byte of the prescaler while
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the timer is stopped. If the timer is running, a write to the high byte
\par   will load the timer latch, but not reload the counter.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  READ (TIMER)
\par     REG    NAME
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----+---------+------+------+------+------+------+------+------+------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  4  |  TA LO  | TAL7 | TAL6 | TAL5 | TAL4 | TAL3 | TAL2 | TAL1 | TAL0 |
\par   |  5  |  TA HI  | TAH7 | TAH6 | TAH5 | TAH4 | TAH3 | TAH2 | TAH1 | TAH0 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  6  |  TB LO  | TBL7 | TBL6 | TBL5 | TBL4 | TBL3 | TBL2 | TBL1 | TBL0 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  7  |  TB HI  | TBH7 | TBH6 | TBH5 | TBH4 | TBH3 | TBH2 | TBH1 | TBH0 |
\par   +-----+---------+------+------+------+------+------+------+------+------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  WRITE (PRESCALER)
\par     REG    NAME
\par   +-----+---------+------+------+------+------+------+------+------+------+
\par   |  4  |  TA LO  | PAL7 | PAL6 | PAL5 | PAL4 | PAL3 | PAL2 | PAL1 | PAL0 |
\par   |  5  |  TA HI  | PAH7 | PAH6 | PAH5 | PAH4 | PAH3 | PAH2 | PAH1 | PAH0 |
\par   |  6  |  TB LO  | PBL7 | PBL6 | PBL5 | PBL4 | PBL3 | PBL2 | PBL1 | PBL0 |
\par   |  7  |  TB HI  | PBH7 | PBH6 | PBH5 | PBH4 | PBH3 | PBH2 | PBH1 | PBH0 |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----+---------+------+------+------+------+------+------+------+------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Time of Day Clock (TOD)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The TOD clock is a special purpose timer for real-time applications.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TOD consists of a 24-hour (AM/PM) clock with 1/10th second resolution. It
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is organized into 4 registers: 10ths of seconds, Seconds, Minutes and
\par   Hours. The AM/PM flag is in the MSB of the Hours register for easy bit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  testing. Each register reads out in BCD format to simplify conversion for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  driving displays, etc. The clock requires an external 60 Hz or 50 Hz
\par   (programmable) TTL level input on the TOD pin for accurate time-keeping.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  In addition to time-keeping, a programmable ALARM is provided for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  generating an interrupt at a desired time. The ALARM registers or located
\par   at the same addresses as the corresponding TOD registers. Access to the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ALARM is governed by a Control Register bit. The ALARM is write-only; any
\par   read of a TOD address will read time regardless of the state of the ALARM
\par   access bit.
\par     A specific sequence of events must be followed for proper setting and
\par   reading of TOD. TOD is automatically stopped whenever a write to the
\par   Hours register occurs. The clock will not start again until after a write
\par   to the 10ths of seconds register. This assures TOD will always start at
\par   the desired time. Since a carry from one stage to the next can occur at
\par 
\par                                                            APPENDIX M   431
\par \page 
\par 
\par 
\par   any time with respect to a read operation, a latching function is
\par   included to keep all Time Of Day information constant during a read
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sequence. All four TOD registers latch on a read of Hours and remain
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  latched until after a read of 10ths of seconds. The TOD clock continues
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to count when the output registers are latched. If only one register is
\par   to be read, there is no carry problem and the register can be read "on
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the fly," provided that any read of Hours is followed by a read of 10ths
\par   of seconds to disable the latching.
\par 
\par   READ
\par     REG    NAME
\par   +-----+---------+------+------+------+------+------+------+------+------+
\par   |  8  |TOD 10THS|  0   |  0   |  0   |  0   |  T8  |  T4  |  T2  |  T1  |
\par   |  9  |TOD SEC  |  0   |  SH4 |  SH2 |  SH1 |  SL8 |  SL4 |  SL2 |  SL1 |
\par   |  A  |TOD MIN  |  0   |  MH4 |  MH2 |  MH1 |  ML8 |  ML4 |  ML2 |  ML1 |
\par   |  B  |TOD HR   |  PM  |  0   |  0   |  HH  |  HL8 |  HL4 |  HL2 |  HL1 |
\par   +-----+---------+------+------+------+------+------+------+------+------+
\par 
\par   WRITE
\par 
\par   CRB7=0 TOD
\par   CRB7=1 ALARM
\par   (SAME FORMAT AS READ)
\par 
\par   Serial Port (SDR)
\par 
\par     The serial port is a buffered, 8-bit synchronous shift register system.
\par   A control bit selects input or output mode. In input mode, data on the SP
\par   pin is shifted into the shift register on the rising edge of the signal
\par   applied to the CNT pin. After 8 CNT pulses, the data in the shift
\par   register is dumped into the Serial Data Register and an interrupt is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  generated. In the output mode, TIMER A is used for the baud rate
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  generator. Data is shifted out on the SP pin at 1/2 the underflow rate of
\par   TIMER A. The maximum baud rate possible is 02 divided by 4, but the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  maximum useable baud rate will be determined by line loading and the
\par   speed at which the receiver responds to input data. Transmission will
\par   start following a write to the Serial Data Register (provided TIMER A is
\par   running and in continuous mode). The clock signal derived from TIMER A
\par   appears as an output on the CNT pin. The data in the Serial Data Register
\par   will be loaded into the shift register then shift out to the SP pin when
\par   a CNT pulse occurs. Data shifted out becomes valid on the falling edge of
\par   CNT and remains valid until the next falling edge. After 8 CNT pulses, an
\par 
\par   432   APPENDIX M
\par \page 
\par 
\par 
\par   interrupt is generated to indicate more data can be sent. If the Serial
\par   Data Register was loaded with new information prior to this interrupt,
\par   the new data will automatically be loaded into the shift register and
\par   transmission will continue. If the microprocessor stays one byte ahead of
\par   the shift register, transmission will be continuous. If no further data
\par   is to be transmitted, after the 8th CNT pulse, CNT will return high and
\par   SP will remain at the level of the last data bit transmitted. SDR data is
\par   shifted out MSB first and serial input data should also appear in this
\par   format.
\par     The bidirectional capability of the Serial Port and CNT clock allows
\par   many 6526 devices to be connected to a common serial communication bus on
\par   which one 6526 acts as a master, sourcing data and shift clock, while all
\par   other 6526 chips act as slaves. Both CNT and SP outputs are open drain to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  allow such a common bus. Protocol for master/slave selection can be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  transmitted over the serial bus, or via dedicated handshaking lines.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     REG    NAME
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----+---------+------+------+------+------+------+------+------+------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  C  |   SDR   |  S7  |  S6  |  S5  |  S4  |  S3  |  S2  |  S1  |  S0  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----+---------+------+------+------+------+------+------+------+------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Interrupt Control (ICR)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    There are five sources of interrupts on the 6526: underflow from TIMER
\par   A, underflow from TIMER B, TOD ALARM, Serial Port full/empty and /FLAG.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  A single register provides masking and interrupt information. The
\par   interrupt Control Register consists of a write-only MASK register and a
\par   read-only DATA register. Any interrupt will set the corresponding bit in
\par   the DATA register. Any interrupt which is enabled by the MASK register
\par   will set the IR bit (MSB) of the DATA register and bring the /IRQ pin
\par   low. In a multi-chip system, the IR bit can be polled to detect which
\par   chip has generated an interrupt request. The interrupt DATA register is
\par   cleared and the /IRQ line returns high following a read of the DATA
\par   register. Since each interrupt sets an interrupt bit regardless of the
\par   MASK, and each interrupt bit can be selectively masked to prevent the
\par   generation of a processor interrupt, it is possible to intermix polled
\par   interrupts with true interrupts. However, polling the IR bit will cause
\par   the DATA register to clear, therefore, it is up to the user to preserve
\par   the information contained in the DATA register if any polled interrupts
\par   were present.
\par     The MASK register provides convenient control of individual mask bits.
\par   When writing to the MASK register, if bit 7 (SET/CLEAR) of the data
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX M   433
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   written is a ZERO, any mask bit written with a one will be cleared, while
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  those mask bits written with a zero will be unaffected. If bit 7 of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  data written is a ONE, any mask bit written with a one will be set, while
\par   those mask bits written with a zero will be unaffected. In order for an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  interrupt flag to set IR and generate an Interrupt Request, the corre-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sponding MASK bit must be set.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  READ (INT DATA)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    REG    NAME
\par   +-----+---------+------+------+------+------+------+------+------+------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  D  |   ICR   |  IR  |   0  |   0  |  FLG |  SP  | ALRM |  TB  |  TA  |
\par   +-----+---------+------+------+------+------+------+------+------+------+
\par 
\par   WRITE (INT MASK)
\par     REG    NAME
\par   +-----+---------+------+------+------+------+------+------+------+------+
\par   |  D  |   ICR   |  S/C |   X  |   X  |  FLG |  SP  | ALRM |  TB  |  TA  |
\par   +-----+---------+------+------+------+------+------+------+------+------+
\par 
\par   CONTROL REGISTERS
\par 
\par     There are two control registers in the 6526, CRA and CRB. CRA is
\par   associated with TIMER A and CRB is associated with TIMER B. The register
\par   format is as follows:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CRA:
\par   Bit  Name    Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   0  START    1=START TIMER A, 0=STOP TIMER A. This bit is automatically
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               reset when underflow occurs during one-shot mode.
\par    1  PBON     1=TIMER A output appears on PB6, 0=PB6 normal operation.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   2  OUTMODE  1=TOGGLE, 0=PULSE
\par    3  RUNMODE  1=ONE-SHOT, 0=CONTINUOUS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   4  LOAD     1=FORCE LOAD (this is a STROBE input, there is no data
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               storage, bit 4 will always read back a zero and writing a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               zero has no effect).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   5  INMODE   1=TIMER A counts positive CNT transitions, 0=TIMER A counts
\par                02 pulses.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   6  SPMODE   1=SERIAL PORT output (CNT sources shift clock),
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               0=SERIAL PORT input (external shift clock required).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   7  TODIN    1=50 Hz clock required on TOD pin for accurate time,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               0=60 Hz clock required on TOD pin for accurate time.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  434   APPENDIX M
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CRB:
\par   Bit  Name    Function
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               (Bits CRB0-CRB4 are identical to CRA0-CRA4 for TIMER B with
\par                the exception that bit 1 controls the output of TIMER B on
\par                PB7).
\par   5,6 INMODE   Bits CRB5 and CRB6 select one of four input modes for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               TIMER B as:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {               CRB6   CRB5
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                0      0       TIMER B counts 02 pulses.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                0      1       TIMER B counts positive CNT transistions.
\par                 1      0       TIMER B counts TIMER A underflow pulses.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                1      1       TIMER B counts TIMER A underflow pulses
\par                                while CNT is high.
\par   7   ALARM     1=writing to TOD registers sets ALARM, 0=writing to TOD
\par                 registers sets TOD clock.
\par 
\par   REGNAME TODIN SP MODE IN MODE   LOAD  RUN MODE OUT MODE   PB ON   START
\par   +-+---+------+-------+-------+--------+-------+--------+--------+-------+
\par   |E|CRA|0=60Hz|0=INPUT| 0=02  |1=FORCE |0=CONT.|0=PULSE |0=PB6OFF|0=STOP |
\par   | |   |      |       |       |  LOAD  |       |        |        |       |
\par   | |   |1=50Hz|1=OUTP.| 1=CNT |(STROBE)|1=O.S. |1=TOGGLE|1=PB6ON |1=START|
\par   +-+---+------+-------+-------+--------+-------+--------+--------+-------+
\par                        +------------------ TA ----------------------------+
\par 
\par   REGNAME ALARM    IN MODE        LOAD  RUN MODE OUT MODE   PB ON   START
\par   +-+---+------+------+--------+--------+-------+--------+--------+-------+
\par   |E|CRB|0=TOD |   0  |0=02    |1=FORCE |0=CONT.|0=PULSE |0=PB7OFF|0=STOP |
\par   | |   |      |   1  |1=CNT   |LOAD    |       |        |        |       |
\par   | |   |1=    |   1  |0=TA    |        |       |        |        |       |
\par   | |   | ALARM|   1  |1=CNT&TA|(STROBE)|1=O.S. |1=TOGGLE|1=PB7ON |1=START|
\par   +-+---+------+------+--------+--------+-------+--------+--------+-------+
\par                +-------------------------- TB ----------------------------+
\par 
\par   All unused register bits are unaffected by a write and are forced to zero
\par   on a read.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | COMMODORE SEMICONDUCTOR GROUP reserves the right to make changes to   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | any products herein to improve reliability, function or design.       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | COMMODORE SEMICONDUCTOR GROUP does not assume any liability arising   |
\par   | out of the application or use of any product or circuit described     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | herein; neither does it convey any license under its patent rights nor|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | the rights of others.                                                 |
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX M   435
\par \page 
\par 
\par 
\par   APPENDIX N
\par 
\par   6566/6567 (VIC-II) CHIP
\par   SPECIFICATIONS
\par 
\par 
\par 
\par     The 6566/6567 are multi-purpose color video controller devices for use
\par   in both computer video terminals and video game applications. Both
\par   devices contain 47 control registers which are accessed via a standard
\par   8-bit microprocessor bus (65XX) and will access up to 16K of memory for
\par   display information. The various operating modes and options within each
\par   mode are described.
\par 
\par 
\par 
\par   CHARACTER DISPLAY MODE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    In the character display mode, the 6566/6567 fetches CHARACTER POINTERs
\par   from the VIDEO MATRIX area of memory and translates the pointers to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  character dot location addresses in the 2048 byte CHARACTER BASE area of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  memory. The video matrix is comprised of 1000 consecutive locations in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  memory which each contain an eight-bit character pointer. The location of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the video matrix within memory is defined by VM13-VM10 in register 24
\par   ($18) which are used as the 4 MSB of the video matrix address. The lower
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  order 10 bits are provided by an internal counter (VC9-VC0) which steps
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  through the 1000 character locations. Note that the 6566/6567 provides 14
\par   address outputs; therefore, additional system hardware may be required
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  for complete system memory decodes.
\par 
\par 
\par 
\par                           CHARACTER POINTER ADDRESS
\par 
\par      A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
\par   ------+----+----+----+----+----+----+----+----+----+----+----+----+------
\par     VM13|VM12|VM11|VM10| VC9| VC8| VC7| VC6| VC5| VC4| VC3| VC2| VC1| VC0
\par 
\par 
\par 
\par 
\par 
\par 
\par   436   APPENDIX N
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The eight-bit character pointer permits up to 256 different character
\par   definitions to be available simultaneously. Each character is an 8*8 dot
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  matrix stored in the character base as eight consecutive bytes. The loca-
\par   tion of the character base is defined by CB13-CB11 also in register 24
\par   ($18) which are used for the 3 most significant bits (MSB) of the char-
\par   acter base address. The 11 lower order addresses are formed by the 8-bit
\par   character pointer from the video matrix (D7-D0) which selects a
\par   particular character, and a 3-bit raster counter (RC2-RC0) which selects
\par   one of the eight character bytes. The resulting characters are formatted
\par   as 25 rows of 40 characters each. In addition to the 8-bit character
\par   pointer, a 4-bit COLOR NYBBLE is associated with each video matrix
\par   location (the video matrix memory must be 12 bits wide) which defines one
\par   of sixteen colors for each character.
\par 
\par 
\par                            CHARACTER DATA ADDRESS
\par 
\par      A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
\par   ------+----+----+----+----+----+----+----+----+----+----+----+----+------
\par     CB13|CB12|CB11| D7 | D6 | D5 | D4 | D3 | D2 | D1 | D0 | RC2| RC1| RC0
\par 
\par 
\par   STANDARD CHARACTER MODE (MCM = BMM = ECM = 0)
\par 
\par     In the standard character mode, the 8 sequential bytes from the
\par   character base are displayed directly on the 8 lines in each character
\par   region. A "0" bit causes the background #0 color (from register 33 ($21))
\par   to be displayed while the color selected by the color nybble (foreground)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is displayed for a "1" bit (see Color Code Table).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                 | CHARACTER |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     FUNCTION   |    BIT    |               COLOR DISPLAYED
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  --------------+-----------+----------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Background  |     0     |  Background #0 color
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                |           |  (register 33 ($21)
\par     Foreground  |     1     |  Color selected by 4-bit color nybble
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Therefore, each character has a unique color determined by the 4-bit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  color nybble (1 of 16) and all characters share the common background
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  color.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX N   437
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   MULTI-COLOR CHARACTER MODE (MCM = 1, BMM = ECM = 0 )
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Multi-color mode provides additional color flexibility allowing up to
\par   four colors within each character but with reduced resolution. The multi-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  color mode is selected by setting the MCM bit in register 22 ($16) to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  "1," which causes the dot data stored in the character base to be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  interpreted in a different manner. If the MSB of the color nybble is a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  "0," the character will be displayed as described in standard character
\par   mode, allowing the two modes to be inter-mixed (however, only the lower
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  order 8 colors are available). When the MSB of the color nybble is a "1"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (if MCM:MSB(CM) = 1) the character bits are interpreted in the multi-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  color mode:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                | CHARACTER  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     FUNCTION   |  BIT PAIR  |               COLOR DISPLAYED
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  --------------+------------+---------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Background  |     00     |  Background #0 Color
\par                 |            |  (register 33 ($21))
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Background  |     01     |  Background #1 Color
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                |            |  (register 34 ($22)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Foreground  |     10     |  Background #2 Color
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                |            |  (register 35 ($23)
\par     Foreground  |     11     |  Color specified by 3 LSB
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                |            |  of color nybble
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Since two bits are required to specify one dot color, the character is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  now displayed as a 4*8 matrix with each dot twice the horizontal size as
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in standard mode. Note, however, that each character region can now
\par   contain 4 different colors, two as foreground and two as background (see
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  MOB priority).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EXTENDED COLOR MODE (ECM = 1, Bmm = MCM = 0)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The extended color mode allows the selection of individual, background
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  colors for each character region with the normal 8*8 character
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  resolution. This mode is selected by setting the ECM bit of register 17
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ($11) to "1". The character dot data is displayed as in the standard mode
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  (foreground color determined by the color nybble is displayed for a "1"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  438   APPENDIX N
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   data bit), but the 2 MSB of the character pointer are used to select the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  background color for each character region as follows:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       CHAR. POINTER  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        MS BIT PAIR   |       BACKGROUND COLOR DISPLAYED FOR 0 BIT
\par   --------------------+----------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           00         |  Background #0 color (register 33 ($21))
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           01         |  Background #l color (register 34 ($22))
\par            10         |  Background #2 color (register 35 ($23))
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           11         |  Background #3 color (register 36 ($24))
\par 
\par   Since the two MSB of the character pointers are used for color informa-
\par   tion, only 64 different character definitions are available. The 6566/
\par   6567 will force CB10 and CB9 to "0" regardless of the original pointer
\par   values, so that only the first 64 character definitions will be accessed.
\par   With extended color mode each character has one of sixteen individually
\par   defined foreground colors and one of the four available background
\par   colors.
\par 
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTE: Extended color mode and multi-color mode should not be enabled  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | simultaneously.                                                       |
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BIT MAP MODE
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    In bit map mode, the 6566/6567 fetches data from memory in a different
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  fashion, so that a one-to-one correspondence exists between each
\par   displayed dot and a memory bit. The bit map mode provides a screen
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  resolution of 320H * 200V individually controlled display dots. Bit map
\par   mode is selected by setting the BMM bit in register 17 ($11) to a "1".
\par   The VIDEO MATRIX is still accessed as in character mode, but the video
\par   matrix data is no longer interpreted as character pointers, but rather as
\par   color data. The VIDEO MATRIX COUNTER is then also used as an address to
\par   fetch the dot data for display from the 8000-byte DISPLAY BASE. The
\par   display base address is formed as follows:
\par 
\par 
\par      A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
\par   ------+----+----+----+----+----+----+----+----+----+----+----+----+------
\par     CB13| VC9| VC8| VC7| VC6| VC5| VC4| VC3| VC2| VC1| VC0| RC2| RC1| RC0
\par 
\par                                                            APPENDIX N   439
\par \page 
\par 
\par 
\par   VCx denotes the video matrix counter outputs, RCx denotes the 3-bit
\par   raster line counter and CB13 is from register 24 ($18). The video matrix
\par   counter steps through the same 40 locations for eight raster lines, con-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  tinuing to the next 40 locations every eighth line, while the raster
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  counter increments once for each horizontal video line (raster line).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  This addressing results in each eight sequential memory locations being
\par   formatted as an 8*8 dot block on the video display.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   STANDARD BIT MAP MODE (BMM =1, MCM = 0)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    When standard bit map mode is in use, the color information is derived
\par   only from the data stored in the video matrix (the color nybble is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  disregarded). The 8 bits are divided into two 4-bit nybbles which allow
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  two colors to be independently selected in each 8*8 dot block. When a bit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  in the display memory is a "0" the color of the output dot is set by the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  least significant (lower) nybble (LSN). Similarly, a display memory bit
\par   of "1" selects the output color determined by the MSN (upper nybble).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      BIT    |            DISPLAY COLOR
\par   -----------+-------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       0     |   Lower nybble of video matrix pointer
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       1     |   Upper nybble of video matrix pointer
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  MULTI-COLOR BIT MAP MODE (BMM = MCM = 1)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Multi-colored bit map mode is selected by setting the MCM bit in
\par   register 22 ($16) to a "1" in conjunction with the BMM bit. Multi-color
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  mode uses the same memory access sequences as standard bit map mode, but
\par   interprets the dot data as follows:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        BIT PAIR      |                   DISPLAY COLOR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  --------------------+----------------------------------------------------
\par            00         |  Background #0 color (register 33 ($21))
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           01         |  Upper nybble of video matrix pointer
\par            10         |  Lower nybble of video matrix pointer
\par            11         |  Video matrix color nybble
\par 
\par   Note that the color nybble (DB11-DB8) IS used for the multi-color bit map
\par   mode. Again, as two bits are used to select one dot color, the horizontal
\par 
\par 
\par   440   APPENDIX N
\par \page 
\par 
\par 
\par   dot size is doubled, resulting in a screen resolution of 160H*200V.
\par   Utilizing multi-color bit map mode, three independently selected colors
\par   can be displayed in each 8*8 block in addition to the background color.
\par 
\par 
\par   MOVABLE OBJECT BLOCKS
\par 
\par     The movable object block (MOB) is a special type of character which can
\par   be displayed at any one position on the screen without the block
\par   constraints inherent in character and bit map mode. Up to 8 unique MOBs
\par   can be displayed simultaneously, each defined by 63 bytes in memory which
\par   are displayed as a 24*21 dot array (shown below). A number of special
\par   features make MOBs especially suited for video graphics and game
\par   applications.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                               MOB DISPLAY BLOCK
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        +--------+--------+--------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        |  BYTE  |  BYTE  |  BYTE  |
\par                         +--------+--------+--------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        |   00   |   01   |   02   |
\par                         |   03   |   04   |   05   |
\par                         |    .   |    .   |    .   |
\par                         |    .   |    .   |    .   |
\par                         |    .   |    .   |    .   |
\par                         |   57   |   58   |   59   |
\par                         |   60   |   61   |   62   |
\par                         +--------+--------+--------+
\par 
\par 
\par   ENABLE
\par 
\par     Each MOB can be selectively enabled for display by setting its corre-
\par   sponding enable bit (MnE) to "1" in register 21 ($15). If the MnE bit is
\par   "0," no MOB operations will occur involving the disabled MOB.
\par 
\par   POSlTlON
\par 
\par     Each MOB is positioned via its X and Y position register (see register
\par   map) with a resolution of 512 horizontal and 256 vertical positions. The
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX N   441
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  position of a MOB is determined by the upper-left corner of the array. X
\par   locations 23 to 347 ($17-$157) and Y locations 50 to 249 ($32-$F9) are
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  visible. Since not all available MOB positions are entirely visible on
\par   the screen, MOBs may be moved smoothly on and off the display screen.
\par 
\par   COLOR
\par 
\par     Each MOB has a separate 4-bit register to determine the MOB color. The
\par   two MOB color modes are:
\par 
\par   STANDARD MOB (MnMC = 0)
\par 
\par     In the standard mode, a "0" bit of MOB data allows any background data
\par   to show through (transparent) and a "1" bit is displayed as the MOB color
\par   determined by the corresponding MOB Color register.
\par 
\par   MULTI-COLOR MOB (MnMC = 1)
\par 
\par     Each MOB can be individually selected as a multi-color MOB via MnMC
\par   bits in the MOB Multi-color register 28 ($1C). When the MnMC bit is "1",
\par   the corresponding MOB is displayed in the multi-color mode. In the multi-
\par   color mode, the MOB data is interpreted in pairs (similar to the other
\par   multi-color modes) as follows:
\par 
\par         BIT PAIR      |                   COLOR DISPLAYED
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  --------------------+----------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           00         |  Transparent
\par            01         |  MOB Multi-color #0 (register 37 ($25))
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           10         |  MOB Color (registers 39-46 ($27-$2E))
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           11         |  MOB Multi-color #1 (register 38 ($26))
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Since two bits of data are required for each color, the resolution of the
\par   MOB is reduced to 12X21, with each horizontal dot expanded to twice
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  standard size so that the overall MOB size does not change. Note that up
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  to 3 colors can be displayed in each MOB (in addition to transparent) but
\par   that two of the colors are shared among all the MOBs in the multi-color
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  mode.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  442   APPENDIX N
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  MAGNIFICATION
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Each MOB can be selectively expanded (2X) in both the horizontal and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  vertical directions. Two registers contain the control bits (MnXE,MnYE)
\par   for the magnification control.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    REGISTER  |                        FUNCTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ------------+------------------------------------------------------------
\par      23 ($17) | Horizontal expand MnXE-"1"=expand; "0"=normal
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     29 ($1D) | Vertical expand MnYE-"1"=expand; "0"=normal
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   When MOBs are expanded, no increase in resolution is realized. The same
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  24*21 array (12X21 if multi-colored) is displayed, but the overall MOB
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  dimension is doubled in the desired direction (the smallest MOB dot may
\par   be up to 4X standard dot dimension if a MOB is both multi-colored and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  expanded).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PRIORITY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The priority of each MOB may be individually controlled with respect to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the other displayed information from character or bit map modes. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  priority of each MOB is set by the corresponding bit (MnDP) of register
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  27 ($1B) as follows:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par      REG BIT  |          PRIORITY TO CHARACTER OR BIT MAP DATA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ------------+------------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        0     |  Non-transparent MOB data will be displayed (MOB in front)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        1     |  Non-transparent MOB data will be displayed only instead of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {              |  Bkgd #0 or multi-color bit pair 01 (MOB behind)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          MOB-DISPLAY DATA PRIORITY
\par                        +--------------+--------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       |   MnDP = 1   |   MnDP = 0   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       +--------------+--------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       |  MOBn        |  Foreground  |
\par                        |  Foreground  |  MOBn        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       |  Background  |  Background  |
\par                        +--------------+--------------+
\par 
\par 
\par                                                            APPENDIX N   443
\par \page 
\par 
\par 
\par   MOB data bits of "0" ("00" in multi-color mode) are transparent, always
\par   permitting any other information to be displayed.
\par     The MOBs have a fixed priority with respect to each other, with MOB 0
\par   having the highest priority and MOB 7 the lowest. When MOB data (except
\par   transparent data) of two MOBs are coincident, the data from the lower
\par   number MOB will be displayed. MOB vs. MOB data is prioritized before
\par   priority resolution with character or bit map data.
\par 
\par 
\par   COLLISION DETECTION
\par 
\par 
\par     Two types of MOB collision (coincidence) are detected, MOB to MOB
\par   collision and MOB to display data collision:
\par 
\par 
\par     1) A collision between two MOBs occurs when non-transparent output data
\par        of two MOBs are coincident. Coincidence of MOB transparent areas
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       will not generate a collision. When a collision occurs, the MOB bits
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       (MnM) in the MOB-MOB COLLISION register 30 ($1E) will be set to "1"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       for both colliding MOBS. As a collision between two (or more) MOBs
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       occurs, the MOB-MOB collision bit for each collided MOB will be set.
\par        The collision bits remain set until a read of the collision
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       register, when all bits are automatically cleared. MOBs collisions
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       are detected even if positioned off-screen.
\par     2) The second type of collision is a MOB-DATA collision between a MOB
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       and foreground display data from the character or bit map modes. The
\par        MOB-DATA COLLISION register 31 ($1F) has a 'bit (MnD) for each MOB
\par        which is set to "1" when both the MOB and non-background display
\par        data are coincident. Again, the coincidence of only transparent data
\par        does not generate a collision. For special applications, the display
\par        data from the 0-1 multicolor bit pair also does not cause a
\par        collision. This feature permits their use as background display data
\par        without interfering with true MOB collisions. A MOB-DATA collision
\par        can occur off-screen in the horizontal direction if actual display
\par        data has been scrolled to an off-screen position (see scrolling).
\par        The MOB-DATA COLLISION register also automatically clears when read.
\par 
\par 
\par 
\par 
\par 
\par 
\par   444   APPENDIX N
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The collision interrupt latches are set whenever the first bit of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   either register is set to "1". Once any collision bit within a register
\par    is set high, subsequent collisions will not set the interrupt latch
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   until that collision register has been cleared to all "0s" by a read.
\par 
\par   MOB MEMORY ACCESS
\par 
\par     The data for each MOB is Stored in 63 consecutive bytes of memory. Each
\par   block of MOB data is defined by a MOB pointer, located at the end of the
\par   VIDEO MATRIX. Only 1000 bytes of the video matrix are used in the normal
\par   display modes, allowing the video matrix locations 1016-1023 (VM base+
\par   $3F8 to VM base+$3FF) to be used for MOB pointers 0-7, respectively. The
\par   eight-bit MOB pointer from the video matrix together with the six bits
\par   from the MOB byte counter (to address 63 bytes) define the entire 14-bit
\par   address field:
\par 
\par 
\par      A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
\par   ------+----+----+----+----+----+----+----+----+----+----+----+----+------
\par      MP7| MP6| MP5| MP4| MP3| MP2| MP1| MP0| MC5| MC4| MC3| MC2| MC1| MC0
\par 
\par   Where MPx are the MOB pointer bits from the video matrix and MCx are the
\par   internally generated MOB counter bits. The MOB pointers are read from the
\par   video matrix at the end of every raster line. When the Y position
\par   register of a MOB matches the current raster line count, the actual
\par   fetches of MOB data begin. Internal counters automatically step through
\par   the 63 bytes of MOB data, displaying three bytes on each raster line.
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  OTHER FEATURES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SCREEN BLANKING
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The display screen may be blanked by setting the DEN bit in register
\par   17 ($11) to a "0". When the screen is blanked, the entire screen will be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  filled with the exterior color as set in register 32 ($20). When blanking
\par   is active, only transparent (Phase 1) memory accesses are required, per-
\par   mitting full processor utilization of the system bus. MOB data, however,
\par   will be accessed if the MOBs are not also disabled. The DEN bit must be
\par   set to "1" for normal video display.
\par 
\par 
\par 
\par                                                            APPENDIX N   445
\par \page 
\par 
\par 
\par   ROW/COLUMN SELECT
\par 
\par     The normal display consists of 25 rows of 40 characters (or character
\par   regions) per row. For special display purposes, the display window may be
\par   reduced to 24 rows and 38 characters. There is no change in the format of
\par   the displayed information, except that characters (bits) adjacent to the
\par   exterior border area will now be covered by the border. The select bits
\par   operate as follows:
\par 
\par 
\par     RSEL |      NUMBER OF ROWS        |  CSEL |     NUMBER OF COLUMNS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  -------+----------------------------+-------+----------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     0   |          24 rows           |   0   |         38 columns
\par      1   |          25 rows           |   1   |         40 columns
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The RSEL bit is in register 17 ($11) and the CSEL bit is in register 22
\par   ($16). For standard display the larger display window is normally used,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  while the smaller display window is normally used in conjunction with
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  scrolling.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SCROLLING
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The display data may be scrolled up to one entire character space in
\par   both the horizontal and vertical direction. When used in conjunction with
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the smaller display window (above), scrolling can be used to create a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  smooth panning motion of display data while updating the system memory
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  only when a new character row (or column) is required. Scrolling is also
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  used to center a fixed display within the display window.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {           BITS         |      REGISTER      |          FUNCTION
\par   ----------------------+--------------------+-----------------------------
\par          X2,X1,X0       |      22 ($16)      |     Horizontal Position
\par          Y2,Y1,Y0       |      17 ($11)      |     Vertical Position
\par 
\par   LIGHT PEN
\par 
\par     The light pen input latches the current screen position into a pair of
\par   registers (LPX,LPY) on a low-going edge. The X position register 19 ($13)
\par   will contain the 8 MSB of the X position at the time of transition. Since
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the X position is defined by a 512-state counter (9 bits) resolution to 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  horizontal dots is provided. Similarly, the Y position is latched to its
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   446   APPENDIX N
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  register 20 ($14) but here 8 bits provide single raster resolution within
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the visible display. The light pen latch may be triggered only once per
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  frame, and subsequent triggers within the same frame will have no effect.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Therefore, you must take several samples before turning the light pen to
\par   the screen (3 or more samples, average), depending upon the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  characteristics of your light pen.
\par 
\par 
\par   RASTER REGISTER
\par 
\par     The raster register is a dual-function register. A read of the raster
\par   register 18 ($12) returns the lower 8 bits of the current raster position
\par   (the MSB-RC8 is located in register 17 ($11)). The raster register can be
\par   interrogated to implement display changes outside the visible area to
\par   prevent display flicker. The visible display window is from raster 51
\par   through raster 251 ($033-$0FB). A write to the raster bits (including
\par   RC8) is latched for use in an internal raster compare. When the current
\par   raster matches the written value, the raster interrupt latch is set.
\par 
\par 
\par   INTERRUPT REGISTER
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The interrupt register shows the status of the four sources of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  interrupt. An interrupt latch in register 25 ($19) is set to "1" when an
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  interrupt source has generated an interrupt request. The four sources of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  interrupt are:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   LATCH |ENABLE|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    BIT  | BIT  |                       WHEN SET
\par   -------+------+----------------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    IRST | ERST | Set when (raster count) = (stored raster count)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    IMDC | EMDC | Set by MOB-DATA collision register (first collision only)
\par     IMMC | EMMC | Set by MOB-MOB collision register (first collision only)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    ILP  | ELP  | Set by negative transition of LP input (once per frame)
\par     IRQ  |      | Set high by latch set and enabled (invert of /IRQ output)
\par 
\par     To enable an interrupt request to set the /IRQ output to "0", the
\par   corresponding interrupt enable bit in register 26 ($1A) must be set to
\par   "1". Once an interrupt latch has been set, the latch may be cleared only
\par   by writing a "1" to the desired latch in the interrupt register. This
\par   feature allows selective handling of video interrupts without software
\par   required to "remember" active interrupts.
\par 
\par                                                            APPENDIX N   447
\par \page 
\par 
\par 
\par   DYNAMIC RAM REFRESH
\par 
\par     A dynamic ram refresh controller is built in to the 6566/6567 devices.
\par   Five 8-bit row addresses are refreshed every raster line. This rate
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  guarantees a maximum delay of 2.02 ms between the refresh of any single
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  row address in a 128 refresh scheme. (The maximum delay is 3.66 ms in a
\par   256 address refresh scheme.) This refresh is totally transparent to the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  system, since the refresh occurs during Phase 1 of the system clock. The
\par   6567 generates both /RAS and /CAS which are normally connected directly
\par   to the dynamic rams. /RAS and /CAS are generated for every Phase 2 and
\par   every video data access (including refresh) so that external clock
\par   generation is not required.
\par 
\par 
\par   RESET
\par 
\par 
\par 
\par 
\par 
\par 
\par   THEORY OF OPERATION
\par 
\par   SYSTEM INTERFACE
\par 
\par     The 6566/6567 video controller devices interact with the system data
\par   bus in a special way. A 65XX system requires the system buses only during
\par   the Phase 2 (clock high) portion of the cycle. The 6566/6567 devices take
\par   advantage of this feature by normally accessing system memory during the
\par   Phase 1 (clock low) portion of the clock cycle. Therefore, operations
\par   such as character data fetches and memory refresh are totally transparent
\par   to the processor and do not reduce the processor throughput. The video
\par   chips provide the interface control signals required to maintain this bus
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sharing.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The video devices provide the signal AEC (address enable control) which
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is used to disable the processor address bus drivers allowing the video
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  device to access the address bus. AEC is active low which, permits direct
\par   connection to the AEC input of the 65XX family. The AEC signal is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   448   APPENDIX N
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  normally activated during Phase 1 so that processor operation is not
\par   affected. Because of this bus "sharing", all memory accesses must be
\par   completed in 1/2 cycle. Since the video chips provide a 1-MHz clock
\par   (which must be used as system Phase 2), a memory cycle is 500 ns
\par   including address setup, data access and, data setup to the reading
\par   device.
\par     Certain operations of the 6566/6567 require data at a faster rate than
\par   available by reading only during the Phase 1 time; specifically, the ac-
\par   cess of character pointers from the video matrix and the fetch of MOB
\par   data. Therefore, the processor must be disabled and the data accessed
\par   during the Phase 2 clock. This is accomplished via the BA (bus available)
\par   signal. The BA line is normally high but is brought low during Phase 1 to
\par   indicate that the video chip will require a Phase 2 data access. Three
\par   Phase-2 times are allowed after BA low for the processor to complete any
\par   current memory accesses. On the fourth Phase 2 after BA low, the AEC
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  signal will remain low during Phase 2 as the video chip fetches data. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BA line is normally connected to the RDY input of a 65XX processor. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  character pointer fetches occur every eighth raster line during the
\par   display window and require 40 consecutive Phase 2 accesses to fetch the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  video matrix pointers. The MOB data fetches require 4 memory accesses as
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  follows:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    PHASE |     DATA    |                    CONDITION
\par   --------+-------------+--------------------------------------------------
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {      1   | MOB Pointer |  Every raster
\par       2   | MOB Byte 1  |  Each raster while MOB is displayed
\par       1   | MOB Byte 2  |  Each raster while MOB is displayed
\par       2   | MOB Byte 3  |  Each raster while MOB is displayed
\par 
\par 
\par   The MOB pointers are fetched every other Phase 1 at the end of each
\par   raster line. As required, the additional cycles are used for MOB data
\par   fetches. Again, all necessary bus control is provided by the 6566/6567
\par   devices.
\par 
\par 
\par   MEMORY INTERFACE
\par 
\par     The two versions of the video interface chip, 6566 and 6567, differ in
\par   address output configurations. The 6566 has thirteen fully decoded
\par 
\par 
\par                                                            APPENDIX N   449
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  addresses for direct connection to the system address bus. The 6567 has
\par   multiplexed addresses for direct connection to 64K dynamic RAMS. The
\par   least significant address bits, A06-A00, are present on A06-A00 while
\par   /RAS is brought low, while the most significant bits, A13-A08, are pres-
\par   ent on A05-A00 while /CAS is brought low. The pins A11-A07 on the 6567
\par   are static address outputs to allow direct connection of these bits to a
\par   conventional 16K (2K*8) ROM. (The lower order addresses require external
\par   latching.)
\par 
\par   PROCESSOR INTERFACE
\par 
\par     Aside from the special memory accesses described above, the 6566/6567
\par   registers can be accessed similar to any other peripheral device. The
\par   following processor interface signals are provided:
\par 
\par   DATA BUS (DB7-DB0)
\par 
\par     The eight data bus pins are the bidirectional data port, controlled by
\par   /CS, RW, and Phase 0. The data bus can only be accessed while AEC and
\par   Phase 0 are high and /CS is low.
\par 
\par   CHIP SELECT (/CS)
\par 
\par     The chip select pin, /CS, is brought low to enable access to the device
\par   registers in conjunction with the address and RW pins. /CS low is recog-
\par   nized only while AEC and Phase 0 are high.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  READ/WRITE (R/W)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The read/write input, R/W, is used to determine the direction of data
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  transfer on the data bus, in conjunction with /CS. When R/W is high ("1")
\par   data is transferred from the selected register to the data bus output.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  When R/W is low ("0") data presented on the data bus pins is loaded into
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the selected register.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ADDRESS BUS (A05-A00)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The lower six address pins, A5-A0, are bidirectional. During a pro-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cessor read or write of the video device, these address pins are inputs.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The data on the address inputs selects the register for read or write as
\par   defined in the register map.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   450   APPENDIX N
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CLOCK OUT (PH0)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The clock output, Phase 0, is the 1-MHz clock used as the 65XX pro-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cessor Phase 0 in. All system bus activity is referenced to this clock.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  The clock frequency is generated by dividing the 8-MHz video input clock
\par   by eight.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INTERRUPTS (/IRQ)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The interrupt output, /IRQ, is brought low when an enabled source of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  interrupt occurs within the device. The /IRQ output is open drain,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  requiring an external pull-up resistor.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VIDEO INTERFACE
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The video output signal from the 6566/6567 consists of two signals
\par   which must be externally mixed together. SYNC/LUM output contains all the
\par   video data, including horizontal and vertical syncs, as well as the
\par   luminance information of the video display. SYNC/LUM is open drain,
\par   requiring an external pull-up of 500 ohms. The COLOR output contains all
\par   the chrominance information, including the color reference burst and the
\par   color of all display data. The COLOR output is open source and should be
\par   terminated with 1000 ohms to ground. After appropriate mixing of these
\par   two signals, the resulting signal can directly drive a video monitor or
\par   be fed to a modulator for use with a standard television.
\par 
\par 
\par                       SUMMARY OF 6566/6567 BUS ACTIVITY
\par   +-----+-----+-----+-----+-----------------------------------------------+
\par   | AEC | PH0 | /CS | R/W |                    ACTION                     |
\par   +-----+-----+-----+-----+-----------------------------------------------+
\par   |  0  |  0  |  X  |  X  |  PHASE 1 FETCH, REFRESH                       |
\par   |  0  |  1  |  X  |  X  |  PHASE 2 FETCH (PROCESSOR OFF)                |
\par   |  1  |  0  |  X  |  X  |  NO ACTION                                    |
\par   |  1  |  1  |  0  |  0  |  WRITE TO SELECTED REGISTER                   |
\par   |  1  |  1  |  0  |  1  |  READ FROM SELECTED REGISTER                  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  1  |  1  |  1  |  X  |  NO ACTION                                    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----+-----+-----+-----+-----------------------------------------------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX N   451
\par \page 
\par 
\par 
\par                               PIN CONFIGURATION
\par 
\par                                 +----+ +----+
\par                         D6   1 @|    +-+    |@ 40  Vcc
\par                                 |           |
\par                         D5   2 @|           |@ 39  D7
\par                                 |           |
\par                         D4   3 @|           |@ 38  D8
\par                                 |           |
\par                         D3   4 @|           |@ 37  D9
\par                                 |           |
\par                         D2   5 @|           |@ 36  D10
\par                                 |           |
\par                         D1   6 @|           |@ 35  D11
\par                                 |           |
\par                         D0   7 @|           |@ 34  A10
\par                                 |           |
\par                       /IRQ   8 @|           |@ 33  A9
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        LP   9 @|           |@ 32  A8
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                        /CS  10 @|           |@ 31  A7
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |    6567   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       R/W  11 @|           |@ 30  A6("1")
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        BA  12 @|           |@ 29  A5(A13)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       Vdd  13 @|           |@ 28  A4(A12)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                      COLOR  14 @|           |@ 27  A3(A11)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     S/LUM  15 @|           |@ 26  A2(A10)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       AEC  16 @|           |@ 25  A1(A9)
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       PH0  17 @|           |@ 24  A0(A8)
\par                                 |           |
\par                       /RAS  18 @|           |@ 23  A11
\par                                 |           |
\par                       /CAS  19 @|           |@ 22  PHIN
\par                                 |           |
\par                        Vss  20 @|           |@ 21  PHCL
\par                                 +-----------+
\par   452   APPENDIX N  (Multiplexed addresses in parentheses)
\par \page 
\par 
\par 
\par                               PIN CONFIGURATION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                +----+ +----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        D6   1 @|    +-+    |@ 40  Vcc
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                         D5   2 @|           |@ 39  D7
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        D4   3 @|           |@ 38  D8
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        D3   4 @|           |@ 37  D9
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        D2   5 @|           |@ 36  D10
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                         D1   6 @|           |@ 35  D11
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        D0   7 @|           |@ 34  A13
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      /IRQ   8 @|           |@ 33  A12
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        LP   9 @|           |@ 32  A11
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                        /CS  10 @|           |@ 31  A10
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |    6567   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       R/W  11 @|           |@ 30  A9
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        BA  12 @|           |@ 29  A8
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       Vdd  13 @|           |@ 28  A7
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     COLOR  14 @|           |@ 27  A6
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     S/LUM  15 @|           |@ 26  A5
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       AEC  16 @|           |@ 25  A4
\par                                 |           |
\par                        PH0  17 @|           |@ 24  A3
\par                                 |           |
\par                       PHIN  18 @|           |@ 23  A2
\par                                 |           |
\par                      PHCOL  19 @|           |@ 22  A1
\par                                 |           |
\par                        Vss  20 @|           |@ 21  A0
\par                                 +-----------+
\par                                                            APPENDIX N   453
\par \page 
\par 
\par 
\par                                 REGISTER MAP
\par   +----------+------------------------------------------------------------+
\par   | ADDRESS  | DB7  DB6  DB5  DB4  DB3  DB2  DB1  DB0     DESCRIPTION     |
\par   +----------+------------------------------------------------------------+
\par   | 00 ($00) | M0X7 M0X6 M0X5 M0X4 M0X3 M0X2 M0X1 M0X0  MOB 0 X-position  |
\par   | 01 ($01) | M0Y7 M0Y6 M0Y5 M0Y4 M0Y3 M0Y2 M0Y1 M0Y0  MOB 0 Y-position  |
\par   | 02 ($02) | M1X7 M1X6 M1X5 M1X4 M1X3 M1X2 M1Xl M1X0  MOB 1 X-position  |
\par   | 03 ($03) | M1Y7 M1Y6 M1Y5 M1Y4 M1Y3 M1Y2 M1Y1 M1Y0  MOB 1 Y-position  |
\par   | 04 ($04) | M2X7 M2X6 M2X5 M2X4 M2X3 M2X2 M2X1 M2X0  MOB 2 X-position  |
\par   | 05 ($05) | M2Y7 M2Y6 M2Y5 M2Y4 M2Y3 M2Y2 M2Y1 M2Y0  MOB 2 Y-position  |
\par   | 06 ($06) | M3X7 M3X6 M3X5 M3X4 M3X3 M3X2 M3X1 M3X0  MOB 3 X-position  |
\par   | 07 ($07) | M3Y7 M3Y6 M3Y5 M3Y4 M3Y3 M3Y2 M3Y1 M3Y0  MOB 3 Y-position  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 08 ($08) | M4X7 M4X6 M4X5 M4X4 M4X3 M4X2 M4X1 M4X0  MOB 4 X-position  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 09 ($09) | M4Y7 M4Y6 M4Y5 M4Y4 M4Y3 M4Y2 M4Y1 M4Y0  MOB 4 Y-position  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 10 ($0A) | M5X7 M5X6 M5X5 M5X4 M5X3 M5X2 M5X1 M5X0  MOB 5 X-position  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 11 ($0B) | M5Y7 M5Y6 M5Y5 M5Y4 M5Y3 M5Y2 M5Y1 M5Y0  MOB 5 Y-position  |
\par   | 12 ($0C) | M6X7 M6X6 M6X5 M6X4 M6X3 M6X2 M6X1 M6X0  MOB 6 X-position  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 13 ($0D) | M6Y7 M6Y6 M6Y5 M6Y4 M6Y3 M6Y2 M6Y1 M6Y0  MOB 6 Y-position  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 14 ($0E) | M7X7 M7X6 M7X5 M7X4 M7X3 M7X2 M7Xl M7X0  MOB 7 X-position  |
\par   | 15 ($0F) | M7Y7 M7Y6 M7Y5 M7Y4 M7Y3 M7Y2 M7Y1 M6Y0  MOB 7 Y-position  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 16 ($10) | M7X8 M6X8 M5X8 M4X8 M3X8 M2X8 M1X8 M0X8  MSB of X-position |
\par   | 17 ($11) | RC8  ECM  BMM  DEN  RSEL Y2   Y1   Y0      See text        |
\par   | 18 ($12) | RC7  RC6  RC5  RC4  RC3  RC2  RC1  RC0   Raster register   |
\par   | 19 ($13) | LPX8 LPX7 LPX6 LPX5 LPX4 LPX3 LPX2 LPX1  Light Pen X       |
\par   | 20 ($14) | LPY7 LPY6 LPY5 LPY4 LPY3 LPY2 LPY1 LPY0  Light Pen Y       |
\par   | 21 ($15) | M7E  M6E  M5E  M4E  M3E  M2E  M1E  M0E   MOB Enable        |
\par   | 22 ($16) |  -    -   RES  MCM  CSEL X2   X1   X0      See text        |
\par   | 23 ($17) | M7YE M6YE M5YE M4YE M3YE M2YE M1YE M0YE  MOB Y-expand      |
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   454   APPENDIX N
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 24 ($18) | VM13 VM12 VM11 VM10 CB13 CB12 CB11  -    Memory Pointers   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 25 ($19) | IRQ   -    -    -   ILP  IMMC IMBC IRST  Interrupt Register|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 26 ($1A) |  -    -    -    -   ELP  EMMC EMBC ERST  Enable Interrupt  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 27 ($1B) | M7DP M6DP M5DP M4DP M3DP M2DP M1DP M0DP  MOB-DATA Priority |
\par   | 28 ($1C) | M7MC M6MC M5MC M4MC M3MC M2MC M1MC M0MC  MOB Multicolor Sel|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 29 ($1D) | M7XE M6XE M5XE M4XE M3XE M2XE M1XE M0XE  MOB X-expand      |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 30 ($1E) | M7M  M6M  M5M  M4M  M3M  M2M  M1M  M0M   MOB-MOB Collision |
\par   | 31 ($1F) | M7D  M6D  M5D  M4D  M3D  M2D  M1D  M0D   MOB-DATA Collision|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | 32 ($20) |  -    -    -    -   EC3  EC2  EC1  EC0   Exterior Color    |
\par   | 33 ($21) |  -    -    -    -   B0C3 B0C2 B0C1 B0C0  Bkgd #0 Color     |
\par   | 34 ($22) |  -    -    -    -   B1C3 B1C2 B1C1 B1C0  Bkgd #1 Color     |
\par   | 35 ($23) |  -    -    -    -   B2C3 B2C2 B2C1 B2C0  Bkgd #2 Color     |
\par   | 36 ($24) |  -    -    -    -   B3C3 B3C2 B3C1 B3C0  Bkgd #3 Color     |
\par   | 37 ($25) |  -    -    -    -   MM03 MM02 MM01 MM00  MOB Multicolor #0 |
\par   | 38 ($26) |  -    -    -    -   MM13 MM12 MM11 MM10  MOB Multicolor #1 |
\par   | 39 ($27) |  -    -    -    -   M0C3 M0C2 M0C1 M0C0  MOB 0 Color       |
\par   | 40 ($28) |  -    -    -    -   M1C3 M1C2 M1C1 M1C0  MOB 1 Color       |
\par   | 41 ($29) |  -    -    -    -   M2C3 M2C2 M2C1 M2C0  MOB 2 Color       |
\par   | 42 ($2A) |  -    -    -    -   M3C3 M3C2 M3C1 M3C0  MOB 3 Color       |
\par   | 43 ($2B) |  -    -    -    -   M4C3 M4C2 M4C1 M4C0  MOB 4 Color       |
\par   | 44 ($2C) |  -    -    -    -   M5C3 M5C2 M5C1 M5C0  MOB 5 Color       |
\par   | 45 ($2D) |  -    -    -    -   M6C3 M6C2 M6C1 M6C0  MOB 6 Color       |
\par   | 46 ($2E) |  -    -    -    -   M7C3 M7C2 M7C1 M7C0  MOB 7 Color       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------+------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | NOTE: A dash indicates a no connect. All no connects are read as a    |
\par   | "1"                                                                   |
\par   +-----------------------------------------------------------------------+
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                                                            APPENDIX N   455
\par \page 
\par 
\par 
\par                                  COLOR CODES
\par   +--------+--------+--------+--------+--------+--------+-----------------+
\par   |   D3   |   D2   |   D1   |   D0   |   HEX  |   DEC  |      COLOR      |
\par   +--------+--------+--------+--------+--------+--------+-----------------+
\par   |    0   |    0   |    0   |    0   |    0   |    0   |    BLACK        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    0   |    0   |    0   |    1   |    1   |    1   |    WHITE        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    0   |    0   |    1   |    0   |    2   |    2   |    RED          |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    0   |    0   |    1   |    1   |    3   |    3   |    CYAN         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    0   |    1   |    0   |    0   |    4   |    4   |    PURPLE       |
\par   |    0   |    1   |    0   |    1   |    5   |    5   |    GREEN        |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    0   |    1   |    1   |    0   |    6   |    6   |    BLUE         |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    0   |    1   |    1   |    1   |    7   |    7   |    YELLOW       |
\par   |    1   |    0   |    0   |    0   |    8   |    8   |    ORANGE       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |    1   |    0   |    0   |    1   |    9   |    9   |    BROWN        |
\par   |    1   |    0   |    1   |    0   |    A   |   10   |    LT RED       |
\par   |    1   |    0   |    1   |    1   |    B   |   11   |    DARK GREY    |
\par   |    1   |    1   |    0   |    0   |    C   |   12   |    MED GREY     |
\par   |    1   |    1   |    0   |    1   |    0   |   13   |    LT GREEN     |
\par   |    1   |    1   |    1   |    0   |    E   |   14   |    LT BLUE      |
\par   |    1   |    1   |    1   |    1   |    F   |   15   |    LT GREY      |
\par   +--------+--------+--------+--------+--------+--------+-----------------+
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  456   APPENDIX N
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  APPENDIX O
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  6581 SOUND INTERFACE DEVICE (SID)
\par   CHIP SPECIFICATIONS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   CONCEPT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    The 6581 Sound Interface Device (SID) is a single-chip, 3-voice elec-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  tronic music synthesizer/sound effects generator compatible with the 65XX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and similar microprocessor families. SID provides wide-range, high-
\par   resolution control of pitch (frequency), tone color (harmonic content),
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and dynamics (volume). Specialized control circuitry minimizes software
\par   overhead, facilitating use in arcade/home video games and low-cost
\par   musical instruments.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   FEATURES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o 3 TONE OSCILLATORS
\par         Range: 0-4 kHz
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o 4 WAVEFORMS PER OSCILLATOR
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        Triangle, Sawtooth,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        Variable Pulse, Noise
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o 3 AMPLITUDE MODULATORS
\par         Range: 48 dB
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o 3 ENVELOPE GENERATORS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        Exponential response
\par         Attack Rate: 2 ms-8 s
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        Decay Rate: 6 ms-24 s
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        Sustain Level: 0-peak volume
\par         Release Rate: 6 ms-24 s
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o OSCILLATOR SYNCHRONIZATION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o RING MODULATION
\par   o PROGRAMMABLE FILTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        Cutoff range: 30 Hz-12 kHz
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        12 dB/octave Rolloff
\par         Low pass, Bandpass,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        High pass, Notch outputs
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        Variable Resonance
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX O   457
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   o MASTER VOLUME CONTROL
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o 2 A/D POT INTERFACES
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  o RANDOM NUMBER/MODULATION GENERATOR
\par   o EXTERNAL AUDIO INPUT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                              PIN CONFIGURATION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                +----+ +----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     CAP1A   1 @|    +-+    |@ 28  Vdd
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                      CAP1B   2 @|           |@ 27  AUDIO OUT
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     CAP2A   3 @|           |@ 26  EXT IN
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                     CAP2B   4 @|           |@ 25  Vcc
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                      /RES   5 @|           |@ 24  POT X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        02   6 @|           |@ 23  POT Y
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                        R/W   7 @|           |@ 22  D7
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |    6581   |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       /CS   8 @|    SID    |@ 21  D6
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        A0   9 @|           |@ 20  D5
\par                                 |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        A1  10 @|           |@ 19  D4
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        A2  11 @|           |@ 18  D3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par                         A3  12 @|           |@ 17  D2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        A4  13 @|           |@ 16  D1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                |           |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       GND  14 @|           |@ 15  D0
\par                                 +-----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  458   APPENDIX O
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          [THE PICTURE IS MISSING!]
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                             6581 BLOCK DIAGRAM
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                            APPENDIX O   459
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The 6581 consists of three synthesizer "voices" which can be used
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  independently or in conjunction with each other (or external audio
\par   sources) to create complex sounds. Each voice consists of a Tone
\par   Oscillator/Waveform Generator, an Envelope Generator and an Amplitude
\par   Modulator. The Tone Oscillator controls the pitch of the voice over a
\par   wide range. The Oscillator produces four waveforms at the selected
\par   frequency, with the unique harmonic content of each waveform providing
\par   simple control of tone color. The volume dynamics of the oscillator are
\par   controlled by the Amplitude Modulator under the direction of the Envelope
\par   Generator. When triggered, the Envelope Generator creates an amplitude
\par   envelope with programmable rates of increasing and decreasing volume. In
\par   addition to the three voices, a programmable Filter is provided for
\par   generating complex, dynamic tone colors via subtractive synthesis.
\par     SID allows the microprocessor to read the changing output of the third
\par   Oscillator and third Envelope Generator. These outputs can be used as a
\par   source of modulation information for creating vibrato, frequency/filter
\par   sweeps and similar effects. The third oscillator can also act as a random
\par   number generator for games. Two A/D converters are provided for inter-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  facing SID with potentiometers. These can be used for "paddles" in a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  game environment or as front panel controls in a music synthesizer. SID
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  can process external audio signals, allowing multiple SID chips to be
\par   daisy-chained or mixed in complex polyphonic systems.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   SID CONTROL REGISTERS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    There are 29 eight-bit registers in SID which control the generation of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sound. These registers are either WRITE-only or READ-only and are listed
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  below in Table 1.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   460   APPENDIX O
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         Table 1. SID Register Map            WO=WRITE-ONLY
\par                                                               RO=READ-ONLY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    REG#                      DATA
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    (HEX) D7    D6    D5    D4    D3    D2    D1    D0   REG NAME       REG
\par                                                          Voice 1       TYPE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   0 00   F7    F6    F5    F4    F3    F2    F1    F0   FREQ LO         WO
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   1 01   F15   F14   F13   F12   F11   F10   F9    F8   FREQ HI         WO
\par    2 02   PW7   PW6   PW5   PW4   PW3   PW2   PW1   PW0  PW LO           WO
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   3 03    -     -     -     -   PW11  PW10   PW9   PW8  PW HI           WO
\par    4 04  NOISE PULSE  SAW TRIANG TEST  RING  SYNC  GATE  CONTROL REG     WO
\par    5 05  ATK3  ATK2  ATK1  ATK0  DCY3  DCY2  DCY1  DCY0  ATTACK/DECAY    WO
\par    6 06  STN3  STN2  STN1  STN0  RLS3  RLS2  RLS1  RLS0  SUSTAIN/RELEASE WO
\par 
\par                                                          Voice 2
\par    7 07   F7    F6    F5    F4    F3    F2    F1    F0   FREQ LO         WO
\par    8 08   F15   F14   F13   F12   F11   F10   F9    F8   FREQ HI         WO
\par    9 09   PW7   PW6   PW5   PW4   PW3   PW2   PW1   PW0  PW LO           WO
\par   10 0A    -     -     -     -   PW11  PW10   PW9   PW8  PW HI           WO
\par   11 0B  NOISE PULSE  SAW TRIANG TEST  RING  SYNC  GATE  CONTROL REG     WO
\par   12 0C  ATK3  ATK2  ATK1  ATK0  DCY3  DCY2  DCY1  DCY0  ATTACK/DECAY    WO
\par   13 0D  STN3  STN2  STN1  STN0  RLS3  RLS2  RLS1  RLS0  SUSTAIN/RELEASE WO
\par 
\par                                                          Voice 3
\par   14 0E   F7    F6    F5    F4    F3    F2    F2    F1   FREQ LO         WO
\par   15 0F   F15   F14   F13   F12   F11   F10   F9    F8   FREQ HI         WO
\par   16 10   PW7   PW6   PW5   PW4   PW3   PW2   PW1   PW0  PW LO           WO
\par   17 11    -     -     -     -   PW11  PW10   PW9   PW8  PW HI           WO
\par   18 12  NOISE PULSE  SAW TRIANG TEST  RING  SYNC  GATE  CONTROL REG     WO
\par   19 13  ATK3  ATK2  ATK1  ATK0  DCY3  DCY2  DCY1  DCY0  ATTACK/DECAY    WO
\par   20 14  STN3  STN2  STN1  STN0  RLS3  RLS2  RLS1  RLS0  SUSTAIN/RELEASE WO
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                         Filter
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  21 15    -     -     -     -     -    FC2   FC1   FC0  FC LO           WO
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  22 16  FC10   FC9   FC8   FC7   FC6   FC5   FC4   FC3  FC HI           WO
\par   23 17  RES3  RES2  RES1  RES0 FILTEX FILT3 FILT2 FILT1 RES/FILT        WO
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  24 18  3OFF   HP    BP    LP   VOL3  VOL2  VOL1  VOL0  MODE/VOL        WO
\par 
\par                                                          Misc.
\par   25 19   PX7   PX6   PX5   PX4   PX3   PX2   PX1   PX0  POT X           RO
\par   26 1A   PY7   PY6   PY5   PY4   PY3   PY2   PY1   PY0  POT Y           RO
\par   27 1B   O7    O6    O5    O4    O3    O2    O1    O0   OSC3/RANDOM     RO
\par   28 1C   E7    E6    E5    E4    E3    E2    E1    E0   ENV3            RO
\par 
\par                                                            APPENDIX O   461
\par \page 
\par 
\par 
\par   SID REGISTER DESCRIPTION
\par 
\par   VOICE 1
\par 
\par   FREQ LO/FREQ HI (Registers 00,01)
\par 
\par     Together these registers form a 16-bit number which linearly controls
\par   the frequency of Oscillator 1 . The frequency is determined by the
\par   following equation:
\par 
\par                        Fout = (Fn*Fclk/16777216) Hz
\par 
\par     Where Fn is the 16-bit number in the Frequency registers and Fclk is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the system clock applied to the 02 input (pin 6). For a standard 1.0-MHz
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  clock, the frequency is given by:
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                       Fout = (Fn*0.059604645) Hz
\par 
\par     A complete table of values for generating 8 octaves of the equally
\par   tempered musical scale with concert A (440 Hz) tuning is provided in
\par   Appendix E. It should be noted that the frequency resolution of SID is
\par   sufficient for any tuning scale and allows sweeping from note to note
\par   (portamento) with no discernable frequency steps.
\par 
\par   PW LO/PW HI (Registers 02,03)
\par 
\par     Together these registers form a 12-bit number (bits 4-7 of PW HI are
\par   not used) which linearly controls the Pulse Width (duty cycle) of the
\par   Pulse waveform on Oscillator 1. The pulse width is determined by the
\par   following equation:
\par 
\par                             PWout = (PWn/40.95) %
\par 
\par   Where PWn is the 12-bit number in the Pulse Width registers.
\par     The pulse width resolution allows the width to be smoothly swept with
\par   no discernable stepping. Note that the Pulse waveform on Oscillator 1
\par   must be selected in order for the Pulse Width registers to have any au-
\par   dible effect. A value of 0 or 4095 ($FF) in the Pulse Width registers
\par   will produce a constant DC output, while a value of 2048 ($800) will
\par   produce a square wave.
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  462   APPENDIX O
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   CONTROL REGISTER (Register 04)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This register contains eight control bits which select various options
\par   on Oscillator 1.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    GATE (Bit 0): The GATE bit controls the Envelope Generator for Voice 1.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  When this bit is set to a one, the Envelope Generator is Gated
\par   (triggered) and the ATTACK/DECAY/SUSTAIN cycle is initiated. When the bit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is reset to a zero, the RELEASE cycle begins. The Envelope Generator
\par   controls the amplitude of Oscillator I appearing at the audio output,
\par   therefore, the GATE bit must be set (along with suitable envelope pa-
\par   rameters) for the selected output of Oscillator 1 to be audible. A de-
\par   tailed discussion of the Envelope Generator can be found at the end of
\par   this Appendix.
\par     SYNC (Bit 1): The SYNC bit, when set to a one, synchronizes the
\par   fundamental frequency of Oscillator 1 with the fundamental frequency of
\par   Oscillator 3, producing "Hard Sync" effects.
\par     Varying the frequency of Oscillator 1 with respect to Oscillator 3 pro-
\par   duces a wide range of complex harmonic structures from Voice I at the
\par   frequency of Oscillator 3. In order for sync to occur, Oscillator 3 must
\par   be set to some frequency other than zero but preferably lower than the
\par   frequency of Oscillator 1. No other parameters of Voice 3 have any effect
\par   on sync.
\par     RING MOD (Bit 2): The RING MOD bit, when set to a one, replaces the
\par   Triangle waveform output of Oscillator 1 with a "Ring Modulated"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  combination of Oscillators 1 and 3. Varying the frequency of Oscillator 1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  with respect to Oscillator 3 produces a wide range of non-harmonic
\par   overtone structures for creating bell or gong sounds and for special ef-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  fects. In order for ring modulation to be audible, the Triangle waveform
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of Oscillator 1 must be selected and Oscillator 3 must be set to some
\par   frequency other than zero. No other parameters of Voice 3 have any effect
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  on ring modulation.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    TEST (Bit 3): The TEST bit, when set to a one, resets and locks Oscil-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  lator 1 at zero until the TEST bit is cleared. The Noise waveform output
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of Oscillator 1 is also reset and the Pulse waveform output is held at a
\par   DC level. Normally this bit is used for testing purposes, however, it can
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  be used to synchronize Oscillator 1 to external events, allowing the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  generation of highly complex waveforms under real-time software control.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                            APPENDIX O   463
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    (Bit 4): When set to a one, the Triangle waveform output of Oscillator
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  1 is selected. The Triangle waveform is low in harmonics and has a
\par   mellow, flute-like quality.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    (Bit 5): When set to a one, the Sawtooth waveform output of Oscillator
\par   1 is selected. The Sawtooth waveform is rich in even and odd harmonics
\par   and has a bright, brassy quality.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    (Bit 6): When set to a one, the Pulse waveform output of Oscillator 1
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is selected. The harmonic content of this waveform can be adjusted by the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Pulse Width registers, producing tone qualities ranging from a bright,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  hollow square wave to a nasal, reedy pulse. Sweeping the pulse width in
\par   real-time produces a dynamic "phasing" effect which adds a sense of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  motion to the sound. Rapidly jumping between different pulse widths can
\par   produce interesting harmonic sequences.
\par     NOISE (Bit 7): When set to a one, the Noise output waveform of
\par   Oscillator 1 is selected. This output is a random signal which changes at
\par   the frequency of Oscillator 1. The sound quality can be varied from a low
\par   rumbling to hissing white noise via the Oscillator 1 Frequency registers.
\par   Noise is useful in creating explosions, gunshots, jet engines, wind, surf
\par   and other unpitched sounds, as well as snore drums and cymbals. Sweeping
\par   the oscillator frequency with Noise selected produces a dramatic rushing
\par   effect.
\par     One of the output waveforms must be selected for Oscillator 1 to be
\par   audible, however, it is NOT necessary to de-select waveforms to silence
\par   the output of Voice 1. The amplitude of Voice 1 at the final output is a
\par   function of the Envelope Generator only.
\par 
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE: The oscillator output waveforms are NOT additive. If more than  |
\par   | one output waveform is selected simultaneously, the result will be a  |
\par   | logical ANDing of the waveforms. Although this technique can be used  |
\par   | to generate additional waveforms beyond the four listed above, it must|
\par   | be used with care. If any other waveform is selected while Noise is   |
\par   | on, the Noise output can "lock up " If this occurs, the Noise output  |
\par   | will remain silent until reset by the TEST bit or by bringing RES     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | (pin 5) low.                                                          |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  464   APPENDIX O
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   ATTACK/DECAY (Register 05)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Bits 4-7 of this register (ATK0-ATK3) select 1 of 16 ATTACK rates for
\par   the Voice 1 Envelope Generator. The ATTACK rate determines how rapidly
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the output of Voice 1 rises from zero to peak amplitude when the Envelope
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Generator is Gated. The 16 ATTACK rates are listed in Table 2.
\par     Bits 0-3 (DCY0-DCY3) select 1 of 16 DECAY rates for the Envelope
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Generator. The DECAY cycle follows the ATTACK cycle and the DECAY rate
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  determines how rapidly the output fails from the peak amplitude to the
\par   selected SUSTAIN level. The 16 DECAY rates are listed in Table 2.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SUSTAIN/RELEASE (Register 06)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Bits 4-7 of this register (STN0-STN3) select 1 of 16 SUSTAIN levels for
\par   the Envelope Generator. The SUSTAIN cycle follows the DECAY cycle and the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  output of Voice 1 will remain at the selected SUSTAIN amplitude as long
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  as the Gate bit remains set. The SUSTAIN levels range from zero to peak
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  amplitude in 16 linear steps, with a SUSTAIN value of 0 selecting zero
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  amplitude and a SUSTAIN value of 15 ($F) selecting the peak amplitude. A
\par   SUSTAIN value of 8 would cause Voice I to SUSTAIN at an amplitude one-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  half the peak amplitude reached by the ATTACK cycle.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Bits 0-3 (RLS0-RLS3) select 1 of 16 RELEASE rates for the Envelope
\par   Generator. The RELEASE cycle follows the SUSTAIN cycle when the Gate bit
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  is reset to zero. At this time, the output of Voice 1 will fall from the
\par   SUSTAIN amplitude to zero amplitude at the selected RELEASE rate. The 16
\par   RELEASE rates are identical to the DECAY rates.
\par 
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE: The cycling of the Envelope Generator can be altered at any     |
\par   | point via the Gate bit. The Envelope Generator can be Gated and       |
\par   | Released without restriction. For example, if the Gate bit is reset   |
\par   | before the envelope has finished the ATTACK cycle, the RELEASE cycle  |
\par   | will immediately begin, starting from whatever amplitude had been     |
\par   | reached. if the envelope is then Gated again (before the RELEASE cycle|
\par   | has reached zero amplitude), another ATTACK cycle will begin, starting|
\par   | from whatever amplitude had been reached. This technique can be used  |
\par   | to generate complex amplitude envelopes via real-time software        |
\par   | control.                                                              |
\par   +-----------------------------------------------------------------------+
\par 
\par 
\par 
\par                                                            APPENDIX O   465
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                           Table 2. Envelope Rates
\par   +-----------------+--------------------------+--------------------------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |      VALUE      |        ATTACK RATE       |    DECAY/RELEASE RATE    |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------+--------------------------+--------------------------+
\par   |   DEC   (HEX)   |       (Time/Cycle)       |       (Time/Cycle)       |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------+--------------------------+--------------------------+
\par   |     0    (0)    |            2 ms          |            6 ms          |
\par   |     1    (1)    |            8 ms          |           24 ms          |
\par   |     2    (2)    |           16 ms          |           48 ms          |
\par   |     3    (3)    |           24 ms          |           72 ms          |
\par   |     4    (4)    |           38 ms          |          114 ms          |
\par   |     5    (5)    |           56 ms          |          168 ms          |
\par   |     6    (6)    |           68 ms          |          204 ms          |
\par   |     7    (7)    |           80 ms          |          240 ms          |
\par   |     8    (8)    |          100 ms          |          300 ms          |
\par   |     9    (9)    |          250 ms          |          750 ms          |
\par   |    10    (A)    |          500 ms          |          1.5 s           |
\par   |    11    (B)    |          800 ms          |          2.4 s           |
\par   |    12    (C)    |            1 s           |            3 s           |
\par   |    13    (D)    |            3 s           |            9 s           |
\par   |    14    (E)    |            5 s           |           15 s           |
\par   |    15    (F)    |            8 s           |           24 s           |
\par   +-----------------+--------------------------+--------------------------+
\par 
\par   +-----------------------------------------------------------------------+
\par   | NOTE: Envelope rates are based on a 1.0-MHz 02 clock. For other 02    |
\par   | frequencies, multiply the given rate by 1 MHz/02. The rates refer to  |
\par   | the amount of time per cycle. For example, given an ATTACK value of 2,|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | the ATTACK cycle would take 16 ms to rise from zero to peak amplitude.|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | The DECAY/RELEASE rates refer to the amount of time these cycles would|
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | take to fall from peak amplitude to zero.                             |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VOICE 2
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Registers 07-$0D control Voice 2 and are functionally identical to reg-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  isters 00-06 with these exceptions:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    1) When selected, SYNC synchronizes Oscillator 2 with Oscillator 1.
\par     2) When selected, RING MOD replaces the Triangle output of Oscillator 2
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {       with the ring modulated combination of Oscillators 2 and 1.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   466   APPENDIX O
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VOICE 3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     Registers $0E-$14 control Voice 3 and are functionally identical to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  registers 00-06 with these exceptions:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     1) When selected, SYNC synchronizes Oscillator 3 with Oscillator 2.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    2) When selected, RING MOD replaces the Triangle output of Oscillator 3
\par        with the ring modulated combination of Oscillators 3 and 2.
\par 
\par     Typical operation of a voice consists of selecting the desired parame-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ters: frequency, waveform, effects (SYNC, RING MOD) and envelope rates,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  then gating the voice whenever the sound is desired. The sound can be
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sustained for any length of time and terminated by clearing the Gate bit.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Each voice can be used separately, with independent parameters and
\par   gating, or in unison to create a single, powerful voice. When used in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  unison, a slight detuning of each oscillator or tuning to musical
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  intervals creates a rich, animated sound.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  FILTER
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   FC LO/FC HI (Registers $15,$16)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Together these registers form an 11-bit number (bits 3-7 of FC LO are
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  not used) which linearly controls the Cutoff (or Center) Frequency of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  programmable Filter. The approximate Cutoff Frequency ranges from 30
\par   Hz to 12 KHz.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RES/FILT (Register $17)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Bits 4-7 of this register (RES0-RES3) control the resonance of the
\par   filter. Resonance is a peaking effect which emphasizes frequency com-
\par   ponents at the Cutoff Frequency of the Filter, causing a sharper sound.
\par   There are 16 resonance settings ranging linearly from no resonance (0) to
\par   maximum resonance (15 or $F). Bits 0-3 determine which signals will be
\par   routed through the Filter:
\par     FILT 1 (Bit 0): When set to a zero, Voice 1 appears directly at the
\par   audio output and the Filter has no effect on it. When set to a one, Voice
\par   1 will be processed through the Filter and the harmonic content of Voice
\par   1 will be altered according to the selected Filter parameters.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    FILT 2 (Bit 1): Same as bit 0 for Voice 2.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    FILT 3 (Bit 2): Same as bit 0 for Voice 3.
\par     FILTEX (Bit 3): Same as bit 0 for External audio input (pin 26).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX O   467
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   MODE/VOL (Register $18)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Bits 4-7 of this register select various Filter mode and output
\par   options:
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    LP (Bit 4): When set to a one, the Low-Pass output of the Filter is
\par   selected and sent to the audio output. For a given Filter input signal,
\par   all frequency components below the Filter Cutoff Frequency are passed
\par   unaltered, while all frequency components above the Cutoff are attenuated
\par   at a rate of 12 dB/Octave. The Low-Pass mode produces fullbodied sounds.
\par     BP (Bit 5): Same as bit 4 for the Bandpass output. All frequency
\par   components above and below the Cutoff are attenuated at a rate of 6
\par   dB/Octave. The Bandpass mode produces thin, open sounds.
\par     HP (Bit 6): Same as bit 4 for the High-Pass output. All frequency
\par   components above the Cutoff are passed unaltered, while all frequency
\par   components below the Cutoff are attenuated at a rate of 12 dB/Octave.
\par   The High-Pass mode produces tinny, buzzy sounds.
\par     3 OFF (Bit 7): When set to a one, the output of Voice 3 is disconnected
\par   from the direct audio path. Setting Voice 3 to bypass the Filter
\par   (FILT 3 = 0) and setting 3 OFF to a one prevents Voice 3 from reaching
\par   the audio output. This allows Voice 3 to be used for modulation purposes
\par   without any undesirable output.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +-----------------------------------------------------------------------+
\par   | NOTE: The Filter output modes ARE additive and multiple Filter modes  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | may be selected simultaneously. For example, both LP and HP modes can |
\par   | be selected to produce a Notch (or Band Reject) Filter response. In   |
\par   | order for the Filter to have any audible effect, at least one Filter  |
\par   | output must be selected and at least one Voice must be routed through |
\par   | the Filter. The Filter is, perhaps, the most important element in SID |
\par   | as it allows the generation of complex tone colors via subtractive    |
\par   | synthesis (the Filter is used to eliminate specific frequency         |
\par   | components from a harmonically rich input signal). The best results   |
\par   | are achieved by varying the Cutoff Frequency in real-time.            |
\par   +-----------------------------------------------------------------------+
\par 
\par     Bits 0-3 (VOL0-VOL3) select 1 of 16 overall Volume levels for the final
\par   composite audio output. The output volume levels range from no output (0)
\par   to maximum volume (15 or $F) in 16 linear steps. This control can be used
\par   as a static volume control for balancing levels in multi-chip systems or
\par   for creating dynamic volume effects, such as Tremolo. Some Volume level
\par   other than zero must be selected in order for SID to produce any sound.
\par 
\par 
\par   468   APPENDIX O
\par \page 
\par 
\par 
\par   MISCELLANEOUS
\par 
\par   POTX (Register $19)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This register allows the microprocessor to read the position of the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  potentiometer tied to POTX (pin 24), with values ranging from 0 at
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  minimum resistance, to 255 ($FF) at maximum resistance. The value is
\par   always valid and is updated every 512 (02 clock cycles. See the Pin
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Description section for information on pot and capacitor values.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   POTY (Register $1A)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Same as POTX for the pot tied to POTY (pin 23).
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  OSC 3/RANDOM (Register $1B)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     This register allows the microprocessor to read the upper 8 output bits
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of Oscillator 3. The character of the numbers generated is directly re-
\par   lated to the waveform selected. If the Sawtooth waveform of Oscillator 3
\par   is selected, this register will present a series of numbers incrementing
\par   from 0 to 255 ($FF) at a rate determined by the frequency of Oscillator
\par   3. If the Triangle waveform is selected, the output will increment from 0
\par   up to 255, then decrement down to 0. If the Pulse waveform is selected,
\par   the output will jump between 0 and 255. Selecting the Noise waveform
\par   will produce a series of random numbers, therefore, this register can be
\par   used as a random number generator for games. There are numerous timing
\par   and sequencing applications for the OSC 3 register, however, the chief
\par   function is probably that of a modulation generator. The numbers
\par   generated by this register can be added, via software, to the Oscillator
\par   or Filter Frequency registers or the Pulse Width registers in real-time.
\par   Many dynamic effects can be generated in this manner. Siren-like sounds
\par   can be created by adding the OSC 3 Sawtooth output to the frequency
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  control of another oscillator. Synthesizer "Sample and Hold" effects can
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  be produced by adding the OSC 3 Noise output to the Filter Frequency
\par   control registers. Vibrato can be produced by setting Oscillator 3 to a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  frequency around 7 Hz and adding the OSC 3 Triangle output (with proper
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  scaling) to the Frequency control of another oscillator. An unlimited
\par   range of effects are available by altering the frequency of Oscillator 3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and scaling the OSC 3 output. Normally, when Oscillator 3 is used for
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  modulation, the audio output of Voice 3 should be eliminated (3 OFF = 1).
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                            APPENDIX O   469
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ENV 3 (Register $1C)
\par 
\par     Same as OSC 3, but this register allows the microprocessor to read the
\par   output of the Voice 3 Envelope Generator. This output can be added to the
\par   Filter Frequency to produce harmonic envelopes, WAH-WAH, and similar
\par   effects. "Phaser" sounds can be created by adding this output to the
\par   frequency control registers of an oscillator. The Voice 3 Envelope
\par   Generator must be Gated in order to produce any output from this regis-
\par   ter. The OSC 3 register, however, always reflects the changing output of
\par   the oscillator and is not affected in any way by the Envelope Generator.
\par 
\par 
\par 
\par   SID PIN DESCRIPTION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CAP1A,CAP1B, (Pins 1,2)/ CAP2A,CAP2B (Pins 3,4)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    These pins are used to connect the two integrating capacitors required
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  by the programmable Filter. C1 connects between pins 1 and 2, C2 between
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  pins 3 and 4. Both capacitors should be the some value. Normal operation
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  of the Filter over the audio range (approximately 30 Hz-12 kHz) is
\par   accomplished with a value of 2200 pF for C1 and C2. Polystyrene
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  capacitors are preferred and in complex polyphonic systems, where many
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SID chips must track each other, matched capacitors are recommended.
\par     The frequency range of the Filter can be tailored to specific applica-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  tions by the choice of capacitor values. For example, a low-cost game may
\par   not require full high-frequency response. In this case, larger values
\par   for C1 and C2 could be chosen to provide more control over the bass
\par   frequencies of the Filter. The maximum Cutoff Frequency of the Filter is
\par   given by:
\par 
\par                              FCmax = 2.6E-5/C
\par 
\par   Where C is the capacitor value. The range of the Filter extends 9 octaves
\par   below the maximum Cutoff Frequency.
\par 
\par   RES (Pin 5)
\par 
\par     This TTL-level input is the reset control for SID. When brought low for
\par   at least ten 02 cycles, all internal registers are reset to zero and the
\par   audio output is silenced. This pin is normally connected to the reset
\par   line of the microprocessor or a power-on-clear circuit.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  470   APPENDIX O
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  02 (Pin 6)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    This TTL-Level input is the master clock for SID. All oscillator
\par   frequencies and envelope rates are referenced to this clock. 02 also
\par   controls data transfers between SID and the microprocessor. Data can only
\par   be transferred when (02 is high. Essentially, (02 acts as a high-active
\par   chip select as far as data transfers are concerned. This pin is normally
\par   connected to the system clock, with a nominal operating frequency of 1.0
\par   MHz.
\par 
\par   R/W  (Pin 7)
\par 
\par     This TTL-level input controls the direction of data transfers between
\par   SID and the microprocessor. If the chip select conditions have been met,
\par   a high on this line allows the microprocessor to Read data from the
\par   selected SID register and a low allows the microprocessor to Write data
\par   into the selected SID register. This pin is normally connected to the
\par   system Read/Write line.
\par 
\par   CS (Pin 8)
\par 
\par     This TTL-Level input is a low active chip select which controls data
\par   transfers between SID and the microprocessor. CS must be low for any
\par   transfer. A Read from the selected SID register can only occur if CS is
\par   low, 02 is high and R/W is high. A Write to the selected SID register can
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  only occur if CS is low, (02 is high and R/W is low. This pin is normally
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  connected to address decoding circuitry, allowing SID to reside in the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  memory map of a system.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   A0-A4 (Pins 9-13)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    These TTL-Level inputs are used to select one of the 29 SID registers.
\par   Although enough addresses are provided to select 1 of 32 registers, the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  remaining three register locations are not used. A Write to any of these
\par   three locations is ignored and a Read returns invalid data. These pins
\par   are normally connected to the corresponding address lines of the micro-
\par   processor so that SID may be addressed in the same manner as memory.
\par 
\par   GND (Pin 14)
\par 
\par     For best results, the ground line between SID and the power supply
\par   should be separate from ground lines to other digital circuitry. This
\par   will minimize digital noise at the audio output.
\par                                                            APPENDIX O   471
\par \page 
\par 
\par 
\par   D0-D7 (Pins 15-22)
\par 
\par     These bidirectional lines are used to transfer data between SID and the
\par   microprocessor. They are TTL compatible in the input mode and capable of
\par   driving 2 TTL loads in the output mode. The data buffers are usually in
\par   the high-impedance off state. During a Write operation, the data buffers
\par   remain in the off (input) state and the microprocessor supplies data to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SID over these lines. During a Read operation, the data buffers turn on
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  and SID supplies data to the microprocessor over these lines. The pins
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  are normally connected to the corresponding data lines of the micro-
\par   processor.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  POTX,POTY (Pins 24,23)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    These pins are inputs to the A/D converters used to digitize the posi-
\par   tion of potentiometers. The conversion process is based on the time con-
\par   stant of a capacitor tied from the POT pin to ground, charged by a
\par   potentiometer tied from the POT pin to +5 volts. The component values are
\par   determined by:
\par 
\par                                 RC = 4.7E-4
\par 
\par   Where R is the maximum resistance of the pot and C is the capacitor.
\par     The larger the capacitor, the smaller the POT value jitter. The recom-
\par   mended values for R and C are 470 komhs and 1000 pF. Note that a separate
\par   pot and cap are required for each POT pin.
\par 
\par   VCC (Pin 25)
\par 
\par     As with the GND line, a separate +5 VDC line should be run between SID
\par   Vcc and the power supply in order to minimize noise. A bypass capacitor
\par   should be located close to the pin.
\par 
\par   EXT IN (Pin 26)
\par 
\par     This analog input allows external audio signals to be mixed with the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  audio output of SID or processed through the Filter. Typical sources in-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  clude voice, guitar, and organ. The input impedance of this pin is on the
\par   order of 100 kohms. Any signal applied directly to the pin should ride at
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  a DC level of 6 volts and should not exceed 3 volts p-p. In order to pre-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  472   APPENDIX O
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   vent any interference caused by DC level differences, external signals
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  should be AC-coupled to EXT IN by an electrolytic capacitor in the 1-10
\par   uF range. As the direct audio path (FILTEX=0) has unity gain, EXT IN can
\par   be used to mix outputs of many SID chips by daisy-chaining. The number of
\par   chips that can be chained in this manner is determined by the amount of
\par   noise and distortion allowable at the final output. Note that the output
\par   Volume control will affect not only the three SID voices, but also any
\par   external inputs.
\par 
\par   AUDIO OUT (Pin 27)
\par 
\par     This open-source buffer is the final audio output of SID, comprised of
\par   the three SID voices, the Filter and any external input. The output level
\par   is set by the output Volume control and reaches a maximum of 2 volts p-p
\par   at a DC level of 6 volts. A source resistor from AUDIO OUT to ground is
\par   required for proper operation. The recommended resistance is 1 kohm for
\par   a standard output impedance.
\par     As the output of SID rides at a 6-volt DC level, it should be AC-
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  coupled to any audio amplifier with an electrolytic capacitor in the 1-10
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  uF range.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VDD (Pin 28)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    As with Vcc, a separate +12 VDC line should be run to SID VDD and a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  bypass capacitor should be used.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  6581 SID CHARACTERISTICS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ABSOLUTE MAXIMUM RATINGS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +--------------------------+------------+-----------------+-------------+
\par   |          RATING          |   SYMBOL   |      VALUE      |    UNITS    |
\par   +--------------------------+------------+-----------------+-------------+
\par   |  Supply Voltage          |    VDD     |   -0.3 to +17   |     VDC     |
\par   |  Supply Voltage          |    VCC     |   -0.3 to +7    |     VDC     |
\par   |  Input Voltage (analog)  |    Vina    |   -0.3 to +17   |     VDC     |
\par   |  Input Voltage (digital) |    Vind    |   -0.3 to +7    |     VDC     |
\par   |  Operating Temperature   |    Ta      |      0 to +70   |   Celsius   |
\par   |  Storage Temperature     |    Tstg    |   -55 to +150   |   Celsius   |
\par   +--------------------------+------------+-----------------+-------------+
\par 
\par                                                            APPENDIX O   473
\par \page 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {   ELECTRICAL CHARACTERISTICS (Vdd=12 VDC+-5%, Vcc=5 VDC+-5%,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {     Ta=0 to 70 Celsius)
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------------------+----+-----+---+-------+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |             CHARACTERISTIC               SYMBOL MIN |TYP|  MAX  |UNITS|
\par   +------------------------------------------+----+-----+---+-------+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Input High Voltage (RES, 02, RIN, CS,    | Vih|  2  | - |  Vcc  | VDC |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Input Low Voltage  A0-A4, D0-D7)         | Vil|-0.3 | - |  0.8  | VDC |
\par   +------------------------------------------+----+-----+---+-------+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Input Leakage Current (RES, 02, R/W, CS, | Iin|  -  | - |  2.5  |  uA |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |                       A0-A4; Vin=0-5 VDC)|    |     |   |       |     |
\par   | Three-State (Off)     (D0-D7; Vcc=max)   |Itsi|  -  | - |  10   |  uA |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------------------+----+-----+---+-------+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Input Leakage Current Vin=0.4-2.4 VDC    |    |     |   |       |     |
\par   +------------------------------------------+----+-----+---+-------+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Output High Voltage   (D0-D7; Vcc=min,   | Voh| 2.4 | - |Vcc-0.7| VDC |
\par   |                       I load=200 uA)     |    |     |   |       |     |
\par   +------------------------------------------+----+-----+---+-------+-----+
\par   | Output Low Voltage    (D0-D7; Vcc=max,   | Vol| GND | - |  0.4  | VDC |
\par   |                       I load=3.2 mA)     |    |     |   |       |     |
\par   +------------------------------------------+----+-----+---+-------+-----+
\par   | Output High Current   (D0-D7; Sourcing,  | Ioh| 200 | - |   -   |  uA |
\par   |                       Voh=2.4 VDC)       |    |     |   |       |     |
\par   +------------------------------------------+----+-----+---+-------+-----+
\par   | Output Low Current    (D0-D7; Sinking,   | Iol| 3.2 | - |   -   |  mA |
\par   |                       Vol=0.4 VDC)       |    |     |   |       |     |
\par   +------------------------------------------+----+-----+---+-------+-----+
\par   | Input Capacitance     (RES, 02, R/W, CS, | Cin|  -  | - |  10   |  pF |
\par   |                       A0-A4, D0-D7)      |    |     |   |       |     |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------------------+----+-----+---+-------+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Pot Trigger Voltage   (POTX, POTY)       |Vpot|  -  Vcc/2   -   | VDC |
\par   +------------------------------------------+----+-----+---+-------+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  | Pot Sink Current      (POTX, POTY)       |Ipot| 500 | - |   -   |  uA |
\par   +------------------------------------------+----+-----+---+-------+-----+
\par   | Input Impedance       (EXT IN)           | Rin| 100 |150|   -   |kohms|
\par   +------------------------------------------+----+-----+---+-------+-----+
\par   | Audio Input Voltage   (EXT IN)           | Vin| 5.7 | 6 |  6.3  | VDC |
\par   |                                          |    |  -  |0.5|   3   | VAC |
\par 
\par 
\par 
\par 
\par 
\par   474   APPENDIX O
\par \page 
\par 
\par 
\par   +------------------------------------------+----+-----+---+-------+-----+
\par   | Audio Output Voltage  (AUDIO OUT; 1 kohm |    |     |   |       |     |
\par   |                       load, volume=max)  |Vout| 5.7 | 6 |  6.3  | VDC |
\par   |                       One Voice on:      |    | 0.4 |0.5|  0.6  | VAC |
\par   |                       All Voices on:     |    | 1.0 |1.5|  2.0  | VAC |
\par   +------------------------------------------+----+-----+---+-------+-----+
\par   | Power Supply Current  (VDD)              | Idd|  -  | 20|   25  |  mA |
\par   +------------------------------------------+----+-----+---+-------+-----+
\par   | Power Supply Current  (VCC)              | Icc|  -  | 70|  100  |  mA |
\par   +------------------------------------------+----+-----+---+-------+-----+
\par   | Power Dissipation     (Total)            | Pd |  -  |600| 1000  |  mW |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +------------------------------------------+----+-----+---+-------+-----+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX O   475
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  6581 SID TIMING
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          [THE PICTURE IS MISSING!]
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   READ CYCLE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------+----------------------------+-------+-------+-------+-------+
\par   |  SYMBOL  |           NAME             |  MIN  |  TYP  |  MAX  | UNITS |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------+----------------------------+-------+-------+-------+-------+
\par   |   Tcyc   |   Clock Cycle Time         |    1  |   -   |    20 |   uA  |
\par   |   Tc     |   Clock High Pulse Width   |  450  |  500  |10,000 |   ns  |
\par   |   Tr,Tf  |   Clock Rise/Fall Time     |   -   |   -   |    25 |   ns  |
\par   |   Trs    |   Read Set-Up Time         |    0  |   -   |   -   |   ns  |
\par   |   Trh    |   Read Hold Time           |    0  |   -   |   -   |   ns  |
\par   |   Tacc   |   Access Time              |   -   |   -   |   300 |   ns  |
\par   |   Tah    |   Address Hold Time        |   10  |   -   |   -   |   ns  |
\par   |   Tch    |   Chip Select Hold Time    |    0  |   -   |   -   |   ns  |
\par   |   Tdh    |   Data Hold Time           |   20  |   -   |   -   |   ns  |
\par   +----------+----------------------------+-------+-------+-------+-------+
\par 
\par 
\par 
\par 
\par   476   APPENDIX O
\par \page 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          [THE PICTURE IS MISSING!]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  WRITE CYCLE
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------+----------------------------+-------+-------+-------+-------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |  SYMBOL  |           NAME             |  MIN  |  TYP  |  MAX  | UNITS |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  +----------+----------------------------+-------+-------+-------+-------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   Tw     |   Write Pulse Width        |  300  |   -   |   -   |   ns  |
\par   |   Twh    |   Write Hold Time          |    0  |   -   |   -   |   ns  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   Taws   |   Address Set-up Time      |    0  |   -   |   -   |   ns  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   Tah    |   Address Hold Time        |   10  |   -   |   -   |   ns  |
\par   |   Tch    |   Chip Select Hold Time    |    0  |   -   |   -   |   ns  |
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  |   Tvd    |   Valid Data               |   80  |   -   |   -   |   ns  |
\par   |   Tdh    |   Data Hold Time           |   10  |   -   |   -   |   ns  |
\par   +----------+----------------------------+-------+-------+-------+-------+
\par 
\par 
\par 
\par 
\par                                                            APPENDIX O   477
\par \page 
\par 
\par 
\par   EQUAL-TEMPERED MUSICAL SCALE VALUES
\par 
\par     The table in Appendix E lists the numerical values which must be stored
\par   in the SID Oscillator frequency control registers to produce the notes of
\par   the equal-tempered musical scale. The equal-tempered scale consists of an
\par   octave containing 12 semitones (notes): C,D,E,F,G,A,B and C#,D#,F#,G#,A#.
\par   The frequency of each semitone is exactly the 12th root of 2 times the
\par   frequency of the previous semitone. The table is based on a (02 clock of
\par   1.02 MHz. Refer to the equation given in the Register Description for use
\par   of other master clock frequencies. The scale selected is concert pitch,
\par   in which A-4 = 440 Hz. Transpositions of this scale and scales other than
\par   the equal-tempered scale are also possible.
\par     Although the table in Appendix E provides a simple and quick method for
\par   generating the equal-tempered scale, it is very memory inefficient as it
\par   requires 192 bytes for the table alone. Memory efficiency can be improved
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  by determining the note value algorithmically. Using the fact that each
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  note in an octave is exactly half the frequency of that note in the next
\par   octave, the note look-up table can be reduced from 96 entries to 12
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  entries, as there are 12 notes per octave. If the 12 entries (24 bytes)
\par   consist of the 16-bit values for the eighth octave (C-7 through B-7),
\par   then notes in lower octaves can be derived by choosing the appropriate
\par   note in the eighth octave and dividing the 16-bit value by two for each
\par   octave of difference. As division by two is nothing more than a right-
\par   shift of the value, the calculation can easily be accomplished by a
\par   simple software routine. Although note B-7 is beyond the range of the
\par   oscillators, this value should still be included in the table for
\par   calculation purposes (the MSB of B-7 would require a special software
\par   case, such as generating this bit in the CARRY before shifting). Each
\par   note must be specified in a form which indicates which of the 12
\par   semitones is desired, and which of the eight octaves the semitone is in.
\par   Since four bits are necessary to select 1 of 12 semitones and three bits
\par   are necessary to select 1 of 8 octaves, the information can fit in one
\par   byte, with the lower nybble selecting the semitone (by addressing the
\par   look-up table) and the upper nybble being used by the division routine to
\par   determine how many times the table value must be right-shifted.
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par   478  APPENDIX O
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SID ENVELOPE GENERATORS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par     The four-part ADSR (ATTACK, DECAY, SUSTAIN, RELEASE) envelope generator
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  has been proven in electronic music to provide the optimum trade-off
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  between flexibility and ease of amplitude control. Appropriate selection
\par   of envelope parameters allows the simulation of a wide range 2: of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  percussion and sustained instruments. The violin is a good example of a
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  sustained instrument. The violinist controls the volume by bowing the
\par   instrument. Typically, the volume builds slowly, reaches a peak, then
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  drops to an intermediate level. The violinist can maintain this level for
\par   as long as desired, then the volume is allowed to slowly die away. A
\par   "snapshot" of this envelope is shown below:
\par 
\par       PEAK AMPLITUDE ---      +  <- SUSTAIN  ->
\par                              / \\     PERIOD
\par                            A/  D\\      S         R
\par                            /     +------------+
\par                           /       INTERMEDIATE +
\par                          /            LEVEL      +
\par       ZERO AMPLITUDE ---+                           +--
\par 
\par     This volume envelope can be easily reproduced by the ADSR as shown
\par   below, with typical envelope rates:
\par                                                 +
\par                                                / \\
\par                                               /   +--------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ATTACK:  10 ($A)     500 ms                /              +
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  DECAY:    8          300 ms             --+ A  D     S     R +-
\par   SUSTAIN: 10 ($A)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RELEASE:  9          750 ms
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                        GATE+--------------+
\par                                           --+              +-----
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Note that the tone can be held at the intermediate SUSTAIN level for
\par   as long as desired. The tone will not begin to die away until GATE is
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  cleared. With minor alterations, this basic envelope can be used for
\par   brass and woodwinds as well as strings.
\par     An entirely different form of envelope is produced by percussion in-
\par   struments such as drums, cymbals and gongs, as well as certain
\par   keyboards such as pianos and harpsichords. The percussion envelope is
\par   characterized by a nearly instantaneous attack, immediately followed by
\par   a decay to zero volume. Percussion instruments cannot be sustained at
\par 
\par                                                            APPENDIX O   479
\par \page 
\par 
\par 
\par   a constant amplitude. For example, the instant a drum is struck, the
\par   sound reaches full volume and decays rapidly regardless of how it was
\par   struck. A typical cymbal envelope is shown below:
\par 
\par   ATTACK:   0       2 ms                        +
\par   DECAY:    9     750 ms                        |+
\par   SUSTAIN:  0                                   |  +
\par   RELEASE:  9     750 ms                    ----+     +--
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                               A    D
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Note that the tone immediately begins to decay to zero amplitude after
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  the peak is reached, regardless of when GATE is cleared. The amplitude
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  envelope of pianos and harpsichords is somewhat more complicated, but can
\par   be generated quite easily with the ADSR. These instruments reach full
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  volume when a key is first struck. The amplitude immediately begins to
\par   die away slowly as long as the key remains depressed. If the key is
\par   released before the sound has fully died away, the amplitude will
\par   immediately drop to zero. This envelope is shown below:
\par 
\par   ATTACK:   0       2 ms                        +
\par   DECAY:    9     750 ms                        |+
\par   SUSTAIN:  0                                   |  +
\par   RELEASE:  0       6 ms                    ----+  +-----
\par                                                A  D R
\par     Note that the tone decays slowly until GATE is cleared, at which point
\par   the amplitude drops rapidly to zero.
\par     The most simple envelope is that of the organ, When a key is pressed,
\par   the tone immediately reaches full volume and remains there. When the key
\par   is released, the tone drops immediately to zero volume. This envelope is
\par   shown below:
\par                                                 +----+
\par   ATTACK:   0       2 ms                        |    |
\par   DECAY:    0       6 ms                        |    |
\par   SUSTAIN: 15 ($F)                              |    |
\par   RELEASE:  0       6 ms                    ----+    +---
\par                                                A   S  R
\par     The real power of SID lies in the ability to create original sounds
\par   rather than simulations of acoustic instruments. The ADSR is capable of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  creating envelopes which do not correspond to any "real" instruments. A
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  good example would be the "backwards" envelope. This envelope is
\par   characterized by a slow attack and rapid decay which sounds very much
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  480   APPENDIX O
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  like an instrument that has been recorded on tape then played backwards.
\par   This envelope is shown below:                        S
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                  +----------+
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ATTACK: 10 ($A) 500 ms                       A /           | R
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  DECAY:   0        6 ms                        /            +
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SUSTAIN: 15 ($F)                             /              +
\par   RELEASE:  3      72 ms                    --+                 +--
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    Many unique sounds can be created by applying the amplitude envelope of
\par   one instrument to the harmonic structure of another. This produces sounds
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  similar to familiar acoustic instruments, yet notably different. In
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  general, sound is quite subjective and experimentation with various
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  envelope rates and harmonic contents will be necessary in order to
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  achieve the desired sound.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                           [THE PICTURE IS MISSING!]
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        TYPICAL 6581/SID APPLICATION
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                           APPENDIX O   481
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   APPENDIX P
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   GLOSSARY
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ADSR                  Attack/Decay/Sustain/Release envelope.
\par   attack                Rate at which musical note reaches peak volume.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  binary                Base-2 number system.
\par   Boolean operators     Logical operators.
\par   byte                  Memory location.
\par   CHROMA noise          Color distortion.
\par   CIA                   Complex Interface Adapter.
\par   DDR                   Data Direction Register.
\par   decay                 Rate at which musical note falls from peak
\par                         volume to sustain volume.
\par   decimal               Base-10 number system.
\par   e                     Mathematical constant (approx. 2.71828183).
\par   envelope              Shape of the volume of a note over time.
\par   FIFO                  First-In/First-Out.
\par   hexadecimal           Base-16 number system.
\par   integer               Whole number (without decimal point).
\par   jiffy clock           Hardware interval timer.
\par   NMI                   Non-Maskable Interrupt.
\par   octal                 Base-8 number system.
\par   operand               Parameter.
\par   OS                    Operating System.
\par   pixel                 Dot of resolution on the screen.
\par   queue                 Single-file line.
\par   register              Special memory storage location.
\par   release               Rate at which a musical note fails from
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                        sustain volume to no volume.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ROM                   Read-Only Memory.
\par   SID                   Sound Interface Device
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  signed numbers        Plus or minus numbers.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  subscript             Index variable.
\par   sustain               Volume level for sustain of musical note.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  syntax                Programming sentence structure.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  truncated             Cut off, eliminated (not rounded).
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VIC-II                Video Interface Chip.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  video screen          Television set
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   482   APPENDIX P
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INDEX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Abbreviations, BASIC Commands, Statements, and Functions, x, 29, 31-34,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    374-375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ABS function, 31, 35, 374
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Accessories, 335-371
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Accumulator, 213
\par   ACPTR, 272-274
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ADC, 232, 235, 254
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Addition, 3, 9-11, 16
\par   Addressing, 211, 215-217, 411-413
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  A/D/S/R, 183-185, 189, 196-199
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  AND, 232, 235, 254
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  AND operator, 13-16, 31, 35-36, 374
\par   Animation, xiii, 153, 166
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Applications, xiii-xvi
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Arithmetic expressions, 10-12
\par   Arithmetic operators, 10-12, 16
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Arrays, 10-12, 44-45
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ASC function, 31, 37, 374
\par   ASCII character codes, 31, 38, 340, 374
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ASL, 232, 236, 254
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Assembler, 215, 218, 227, 310
\par   ArcTaNgent function, 31, 38, 374
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Attack, (see A/D/S/R)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Bank selection, 101-102, 133
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BASIC abbreviations, 29, 31-34, 374-375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BASIC commands, 31-34, 41, 58-60, 62, 81-82, 91
\par   BASIC miscellaneous functions, 31-34, 43-44, 49, 56-57, 61, 69, 70, 80,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    83-85, 89
\par   BASIC numeric functions, 31-35, 37-38, 42, 46-47, 49, 83-84, 88-89
\par   BASIC operators, 3, 9-15, 31-36, 63-64, 68, 92
\par   BASIC statements, 18-26, 31-34, 39-55, 57, 62-67, 69-79, 86-87, 92
\par   BASIC string functions, 31-34, 38, 56, 61, 79, 87, 89
\par   BASIC variables, 7-26
\par   BCC, 232, 236, 254
\par   BCS, 232, 236, 254
\par   BEQ, 226-227, 232, 237, 254
\par   Bibliography, 388-390
\par   Binary, 69, 92, 108, 112, 216-217
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Bit, 99-149, 290, 298, 300-301, 305, 343-357, 359
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                                                                 INDEX   483
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BIT, 232, 237, 254
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Bit map mode, 121-130
\par   Bit map mode, multicolor, 127-130
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Bit mapping, 121-130
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BMI, 232, 237, 254
\par   BNE, 226-227, 232, 238, 254
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Boolean arithmetic, 14
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BPL, 232, 238, 254
\par   Branches and testing, 226-227
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BRK, 232, 238, 254
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Buffer, keyboard, 93
\par   Business aids, xiii-xvi
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BVC, 232, 239, 254
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  BVS, 232, 239, 254
\par   Byte, 9, 104, 108, 117-119, 124-127, 196, 213, 218-220, 222-227, 260-263,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    274, 278-279, 286, 292-293, 299, 307, 349, 357-359
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Cassette port, 337, 340-342
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Cassette, tape recorder, xiii, 39-41, 65-67, 81-82, 91, 187, 192, 283,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    293-294, 297, 320-321, 337-338, 340-342
\par   Character PEEKs and POKES, 104, 106, 109-111, 115, 118, 120-122, 127-130,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    134-137, 150, 154-155, 159-161, 165-166
\par   CHAREN, 260-261
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CHKIN, 272-273, 275
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CHKOUT, 272-273, 276
\par   CHRGET, 272-273, 307-308
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CHRIN, 272-273, 277-278
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CHROUT, 272-273, 278-279
\par   CHR$ function, 24, 31, 37-38, 45, 50, 55, 75-76, 93-94, 97, 120, 156,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    336-342, 374, 379-381
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CINT, 272-273, 280
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CIOUT, 272-273, 279-280
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CLALL, 272-273, 281
\par   CLC, 232, 239, 254
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CLD, 232, 240, 254
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CLI, 232, 240, 254
\par   Clock, 80, 89, 314, 329-332, 366, 406-408, 421-427, 431, 451
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Clock timing diagram, 406-408
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CLOSE, 272-273, 281-282
\par   CLOSE statement, 31, 39-41, 348, 354, 374
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CLR statement, 31, 39-40, 81, 109, 374
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CLRCHN, 272-273, 282
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  484   INDEX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CLR/HOME key, 220
\par   CLV, 232, 240, 254
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CMD statement, 31, 40-41, 374
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CMP, 232, 241, 254
\par   Collision detect, 144-145, 180
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Color adjustment, 113
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Color combinations chart, 152
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Color memory, 103
\par   Color register, 117, 120, 128, 135-136, 179
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Color screen, background, border, 115-119, 128, 135-137, 176, 179-180
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Commands, BASIC, 31-92
\par   Commodore magazine, xvii-xviii, 390
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Commodore 64 memory map, 310
\par   Complement, twos, 63-64
\par   Constants, floating-point, integer, string, 4-7, 46, 77-78
\par   CONTinue command, 31, 41-42, 46, 81, 86, 374
\par   ConTRoL key, 58, 72, 93-97, 171
\par   COSine function, 31-34, 42, 374
\par   CP/M, x, xiv, 368-371
\par   CPX, 227, 232, 241, 254
\par   CPY, 227, 232, 241, 254
\par   Crunching BASIC programs, 24-27, 156
\par   CuRSoR keys, 93-97, 336
\par 
\par   DATASSETTE(TM) recorder, (see cassette, tape recorder)
\par   DATA statement, 26, 31, 42-43, 76-77, 111-114, 164, 169, 174, 374
\par   DEC, 232, 242, 254
\par   Decay, (see AIDIS/R)
\par   DEFine FuNction statement, 31, 43-44, 374
\par   DELete key, 71-72, 95-96
\par   DEX, 226, 232 242, 254
\par   DEY, 226, 232: 242, 254
\par   DiMension statement, 9, 31, 44-45, 374
\par   Direct mode, 3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Division, 3, 10-11
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Edit mode, 93-97
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Editor, screen, 93-97
\par   END statement, 32, 46, 79, 93, 374
\par   Envelope generator, (see A/D/S/R)
\par   EOR, 232, 243, 254
\par   Equal, not-equal-to signs, 3, 9-12
\par 
\par                                                                 INDEX   485
\par \page 
\par 
\par   Error messages, 306, 400-401
\par   Expansion port(s), (also user port, serial port, RS-232 port), 335-371
\par   EXPonent function, 32, 46, 374
\par   Exponentiation, 5-6, 10, 12, 16
\par 
\par   Files (cassette), 40, 50, 55, 59-60, 65-66, 75, 84-85, 91, 337-338,
\par     340-342
\par   Files (disk), 40, 50, 55, 59-60, 65-66, 75, 84-85, 91, 337-338, 342
\par   Filtering, 183, 189, 199-202
\par   Fire button, joystick/paddle/lightpen, 328-329, 343-348
\par   FOR statement, 20-21, 32, 39, 47-48, 62-63, 77-78, 86, 110, 155-156,
\par     165-166, 169-171, 198-199, 309, 374
\par   Football, 45
\par   FREE function, 32, 49, 109, 374
\par   FuNction function, 32, 47, 374
\par   Functions, 31-34, 35, 37-38, 42, 46-47, 49, 56-57, 61, 69-70, 79-80,
\par     83-85, 87-90, 374-375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Game controls and ports, 343-348
\par   GET statement, 22-24, 32, 37, 49-50, 93, 374-375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  GETIN, 272-273, 283
\par   GET# statement, 32, 37, 50, 55, 65, 341-342, 348, 374
\par   GOSUB statement, 32, 39, 51-52, 77, 79, 85, 374
\par   GOTO (GO TO) statement, 32, 37, 48, 52-53, 64, 77,  81, 86, 374
\par   Graphics keys, xiv-xv, 70-74, 95-96, 108-114
\par   Graphics mode, xiv-xv, 99-183
\par   Graphics mode, bit mapped, 121-130
\par   Graphics symbols, (see graphics keys)
\par   Greater than, equal to or, 3, 12-13, 16
\par 
\par   Hexadecimal notation, 101, 209, 215-218
\par   Hierarchy of operations, 16
\par 
\par   IEEE-488 interface, (see serial port)
\par   IF...THEN statement, 32, 46-47, 49, 52-53, 64, 70, 86, 172-173, 180, 374
\par   INC, 232, 243, 254
\par   Income/expense program, 20-21
\par   Indexed indirect, 224-225
\par   Indexing, 223-225
\par   Indirect indexed, 223-224
\par   INPUT statement, 18-22, 32, 45, 53-55, 93, 374
\par   INPUT# statement, 32, 55, 75, 86, 88, 90, 374
\par   INSerT key, 72, 95-96
\par 
\par   486   INDEX
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   INTeger function, 32, 56, 80, 374
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Integer,, arrays, constants, variables, 4-5, 7-9
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INX, 226-227, 232, 243, 254
\par   INY, 226-227, 232, 244, 254
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  IOBASE, 272-273, 284
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  I/O Guide, 335-375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  IOINIT, 272-273, 285
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  I/O Pinouts, 395-397
\par   I/O Ports, 214, 260, 335-375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  I/O Registers, 104-106, 212-214
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  I/O Statements, 39, 50, 54-55, 65-67, 75
\par   IRQ, 308
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Joysticks, 343-345
\par   JMP, 228-230, 232, 244, 254, 270, 308
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  JSR, 228-230, 233, 244, 255, 268, 270
\par 
\par   KERNAL, 2, 94, 209, 228-230, 308, 268-306, 348-358
\par   Keyboard, 93-98
\par   Keywords, BASIC, 29-92
\par 
\par   LDA, 218-220, 233, 245, 255
\par   LDX, 233, 245, 255
\par   LDY, 233, 246, 255
\par   LEFT$ function, 32, 56, 375
\par   LENgth function, 32, 57, 375
\par   Less than, equal to or, 3, 12-13, 16
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LET statement, 32, 57, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LIST command, 32, 58, 375
\par   LISTEN, 272-273, 285
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LOAD, 272-273, 286
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LOAD command, 32, 59-60, 370, 375
\par   Loading programs from tape, disk, 59-60, 337-338, 340-342
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LOGarithm function, 32, 61, 375
\par   Lower case characters, 72-74, 105
\par   LPX (LPY), 348
\par   LSR, 233, 246, 255
\par 
\par   Machine language, 209-334, 411-413
\par   Mask, 92
\par   Mathematics formulas, 394
\par   Mathematical symbols, 3, 6-17, 394
\par 
\par                                                                 INDEX   487
\par \page 
\par 
\par 
\par   MEMBOT, 272-273, 287
\par   Memory maps, 212, 262-267, 272-273,
\par     310-3@4
\par   Memory map, abbreviated, 212
\par   Memory reallocation, 101-103
\par   MEMTOP, 272-273, 288
\par   MID$ function, 33, 61, 375
\par   Modem, xiii-xviii, 339-340
\par   Modulation, 183, 207-208
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Multiplication, 3, 10-11
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Music, 183-208
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  NEW command, 18, 33, 62, 111, 117, 185, 187,375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  NEXT command, 20-21, 33, 39, 47-48, 62-63, 77-78, 86, 110, 155-156,
\par     165-166, 169-171, 198-199, 309, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  NOP, 233, 246, 255
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  NOT operator, 13-16, 33, 63-64, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Note types, 190
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Numeric variables, 7-8, 26
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ON (ON...GOTO/GOSUB) statement, 33, 64,375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  OPEN, 272-273, 289
\par   OPEN statement, 33, 41, 65-67, 75-76, 85, 94, 337-339, 349-352, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operating system, 210-211
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operators, arithmetic, 3, 9-12, 16
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operators, logical, 13-16, 31-33, 35-37, 63-64, 68, 374-375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Operators, relational, 3, 10-12, 16
\par   OR operator, 13-26, 33, 68, 101-102, 104, 106, 115, 118, 120, 122,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    126-127, 129, 134, 136-137, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ORA, 233, 247, 255
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Parentheses, 3, 8, 30, 33, 83-84, 88, 375
\par   PEEK function, 33, 69, 93, 101-102, 104, 106, 108-111, 115, 118, 120-122,
\par     126-130, 134-137, 145, 150, 159-160, 176-177, 180, 185, 211, 361, 375
\par   Peripherals, (see I/O Guide)
\par   PHA, 233, 247, 255
\par   PHP, 233, 247, 255
\par   Pinouts, (also see I/O Pinouts), 363, 395-397
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PLA, 233, 248, 255
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PLOT, 273, 290
\par   PLP, 233, 248, 255
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   488   INDEX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   POKE statement, 25, 33, 69-70, 94, 101-102, 104, 106, 109-111, 115-116,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    118, 120-123, 126-130, 134-137, 150, 153-161, 165-166, 168-170,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    172-173, 177-178, 180, 184-186, 194, 198-199, 204-205, 211, 220, 309,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {    361, 375-376
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Ports, I/O, 214, 335-375, 395-397
\par   POSition function, 33, 70, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Power/Play, xvi, 390
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PRINT statement, 13-15, 18-22, 25, 33-54, 56-61, 63, 68-75, 79-80,
\par     83-84, 87-89, 94-96, 109, 168, 171, 210, 213, 220, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PRINT# statement, 33, 40-41, 75-76, 85, 94, 337, 340-341, 348, 353, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Printer, xv, 338-339
\par   Program counter, 214
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Program mode, 3
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Prompt, 45
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Quotation marks, xi, 3, 23, 72, 95, 337
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Quote mode, 72-73, 95-96
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RAM, 49, 100-101, 104-105, 107-108, 110-111, 117, 122, 260-262, 269, 340
\par   RAMTAS, 273, 291
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Random numbers, 53, 80
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RaNDom function, 33, 43, 53, 80, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Raster interrupt, 131, 150-152
\par   RDTIM, 273, 291
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  READST, 273, 292
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  READ statement, 33, 42, 76-77, 111, 170, 309,375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Release, (see A/D/S/R)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Register map, CIA chip, 428
\par   Register map, SID chip, 461
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Register map, VIC chip, 454-455
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  REMark statement, 25-26, 33, 37-38, 41-42, 45-46, 50, 77-78, 93-95, 101,
\par     118, 198-199, 338, 340, 356, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Reserved words, (see Keywords, BASIC)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RESTOR, 273, 293
\par   RESTORE key, 22, 92, 126, 353
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RESTORE statement, 33, 78, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RETURN key, 3, 18, 22, 41, 50-51, 74, 93-97,  154-155, 166, 217, 220,
\par     336-337, 370
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RETURN statement, 33, 51-52, 79, 85, 175, 375
\par   ReVerSe ON, OFF keys, 97
\par   RIGHT$ function, 33, 79, 375
\par   ROL, 233, 248, 255
\par   ROM, 261, 268-269
\par 
\par                                                                 INDEX   489
\par \page 
\par 
\par 
\par   ROM, character generator, 103-111, 134
\par   ROR, 233, 249, 255
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RS-232C, 335, 348-359
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RTI, 233, 249, 255, 308
\par   RTS, 233, 249, 255
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RUN command, 33, 40, 59, 81, 113, 154, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  RUN/STOP key, 22, 41-42, 52, 58, 86, 92, 126, 220, 353
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SAVE, 273, 293-294
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SAVE command, 34, 81-82, 375
\par   SBC, 233, 250, 255
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SCNKEY, 273, 295
\par   SCREEN, 273, 295-296
\par   Screen editor, 2, 94-97, 211
\par   Screen memory, 102-103
\par   Scrolling, 128-130, 166
\par   SEC, 233, 250, 255
\par   SECOND, 273, 296
\par   SED, 233, 250, 255
\par   SEI, 233, 251, 255
\par   Serial port (IEEE-488), 262, 331, 333, 362-366, 432-433
\par   SETLFS, 273, 297
\par   SETMSG, 273, 298
\par   SETNAM, 273, 299
\par   SETTIM, 273, 299-300
\par   SETTMO, 273, 300-301
\par   SGN function, 34, 83, 109, 375
\par   SHIFT key, 4, 30, 72, 74, 94, 96-97, 168, 220
\par   SID chip programming, xiv, 183-208
\par   SID chip specifications, 457-481
\par   SID chip memory map, 223-328
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SiNe function, 34, 83, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Sound waves, 186-187, 192-196
\par   SPaCe function, 27, 34, 83-84, 336, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Sprites, x, xiv, 99-100, 131-149, 153-182
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Sprite display priorities, 144, 161, 179
\par   Sprite positioning, 137-143, 157-161, 177
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SQuare Root function, 34, 84, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STA, 221, 233, 251, 255
\par   Stack pointer, 214, 222
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STATUS function, 34, 84-85, 354, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Status register, 214, 354
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  490   INDEX
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STEP keyword, (see FOR...TO), 34, 86
\par   STOP, 273, 301-302
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  STOP command, 34, 41, 86, 375
\par   STOP key, (see RUN/STOP key)
\par   String arrays, constants, variables, 4, 6-9
\par   String expressions, 9, 17
\par   String operators, 9, 16-17
\par   STR$ function, 34, 87, 375
\par   STX, 233, 251, 255
\par   STY, 233, 252, 255
\par   Subroutines, 222, 228-229,  270, 307
\par   Subtraction, 3, 10-11, 16
\par   Sustain, (see A/D/S/R)
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SYS statement, 34, 87, 121, 307, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   TAB function, 27, 34, 45, 88, 336, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TANgent function, 34, 88, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TALK, 273, 302
\par   TAX, 233, 252, 255
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TAY, 233, 252, 255
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  THEN keyword, (see IF...THEN), 34
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TIME function, 34, 89, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TIME$ function, 34, 89, 375
\par   TKSA, 273, 302-303
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TO keyword, (see FOR...TO), 34
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TSX, 233, 253, 255
\par   TXA, 229, 233, 253, 255
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TXS, 233, 253, 255
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TYA, 229, 233, 253, 255
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  UDTIM, 273, 303
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  UNLSN, 273, 304
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  UNTLK, 273, 304
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  User port, 355, 359-362
\par   USR function, 34, 90, 307, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VALue function, 34, 90, 375
\par   VECTOR, 273, 305-306
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VERIFY command, 34, 91, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Vibrato, 203
\par   Voices, 187-191
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Volume control, SID, 186
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                                                INDEX   491
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  WAIT statement, 13-14, 34, 92, 375
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   XOR, (see WAIT statement), 13-14
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  X index register, 213, 223-224
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   Y index register, 214, 223-224
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Z-80, (see CP/M)
\par   Zero page, 221-222, 358-359
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  492   INDEX
\par \page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par                       COMMODORE 64 QUICK REFERENCE CARD
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SIMPLE VARIABLES
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Type     Name     Range
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Real     XY       +-1.70141183E+38
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    +-2.93873588E-39
\par   Integer  XY%      +-32767
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  String   XY$      0 to 255 characters
\par 
\par     X is a letter (A-Z), Y is a letter or number (0-9). Variable names
\par   can be more than 2 characters, but only the first two are recognized.
\par 
\par 
\par   ARRAY VARIABLES
\par 
\par   Type                  Name
\par   Single Dimension      XY(5)
\par   Two-Dimension         XY(5,5)
\par   Three-Dimension       XY(5,5,5)
\par 
\par   Arrays of up to eleven elements (subscripts 0-10) can be used
\par   where needed. Arrays with more than eleven elements need to be
\par   DIMensioned.
\par 
\par   ALGEBRAIC OPERATORS             RELATIONAL AND LOGICAL OPERATORS
\par 
\par   = Assigns value to variable     =   Equal
\par   - Negation                      <>  Not Equal To
\par   ^ Exponentiation                <   Less Than
\par   * Multiplication                >   Greater Than
\par   / Division                      <=  Less Than or Equal To
\par   + Addition                      >=  Greater Than or Equal To
\par   - Substraction                  NOT Logical "Not"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                  AND Logical "And"
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                  OR  Logical "Or"
\par                                   Expression equals 1 if true, 0 if false
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\page 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SYSTEM COMMANDS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   LOAD"NAME"    Loads a program from tape
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SAVE"NAME"    Saves a program on tape
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LOAD"NAME",8  Loads a program from disk
\par   SAVE"NAME",8  Saves a program to disk
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  VERIFY"NAME"  Verifies that program was SAVEd without errors
\par   RUN           Executes a program
\par   RUN xxx       Executes program starting at line xxx
\par   STOP          Halts execution
\par   END           Ends execution
\par   CONT          Continues program execution from line where
\par                 program was halted
\par   PEEK(X)       Returns contents of memory location X
\par   POKE X,Y      Changes contents of location X to value Y
\par   SYS xxxxx     Jumps to execute a machine language program,
\par                 starting at xxxxx
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  WAIT X,Y,Z    Program waits until contents of location X,
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                when EORed with Z and ANDed with Y, is nonzero.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  USR(X)        Passes value of X to a machine language subroutine.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  EDITING AND FORMATTING COMMANDS
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   LIST          Lists entire program
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  LIST A-B      Lists from line A to line B
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  REM Message   Comment message can be listed but is ignored during
\par                 program execution
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  TAB(X)        Used in PRINT statement. Spaces X positions on screen
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SPC(X)        PRINTs X blanks on line
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  POS(X)        Returns current cursor position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CLR/HOME      Positions cursor to left corner of screen
\par   SHIFT+CLR/HOME Clears screen and places cursor in "Home" position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  SHIFT+INST/DEL Inserts space at current cursor position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  INST/DEL      Deletes character at current cursor position
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  CTRL          When used with numeric color key, selects text color.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                May be used in PRINT statement.
\par   CRSR keys     Moves cursor up, down, left, right on screen
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  Commodore Key When used with SHIFT selects between upper/lower case
\par                 and graphic display mode.
\par                 When used with numeric color key, selects optional
\par                 text color
\par 
\par 
\par 
\par \page 
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  ARRAYS AND STRINGS
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  DIM A(X,Y,Z)  Sets maximum subscripts for A; reserves space for
\par                 (X+1)*(Y+1)*(Z+1) elements starting at A(0,0,0)
\par   LEN(X$)       Returns number of characters in X$
\par   STR$(X)       Returns numeric value of X, converted to a string
\par   VAL(X$)       Returns numeric value of X$, up to first
\par                 non-numeric character
\par   CHR$(X)       Returns ASCII character whose code is X
\par   ASC(X$)       Returns ASCII code for first character of X$
\par   LEFT$(A$,X)   Returns leftmost X characters of A$
\par   RIGHT$(A$,X)  Returns rightmost X characters of A$
\par   MID$(A$,X,Y)  Returns Y characters of A$ starting at character X
\par 
\par   INPUT/OUTPUT COMMANDS
\par 
\par   INPUT A$ or A PRINTs "?" on screen and waits for user to enter
\par                 a string or value
\par   INPUT "ABC";A PRINTs message and waits for user to enter value.
\par                 Can also INPUT A$
\par   GET A$ or A   Waits for user to type one-character value; no
\par                 RETURN needed
\par   DATA A,"B",C  Initializes a set of values that can be used by
\par                 READ statement
\par   READ A$ or A  Assigns next DATA value to A$ or A
\par   RESTORE       Resets data pointer to start READing the DATA list again
\par   PRINT"A= ";A  PRINTs string "A=" and value of A
\par                 ";" suppresses spaces - "," tabs data to next field
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  PROGRAM FLOW
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par   GOTO X        Branches to line X
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {  IF A=1 TO 10  IF assertion is true THEN execute following part of
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                statement. IF false, execute next line number
\par   FOR A=1 TO 10 STEP 2   Executes all statements between FOR and
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                         corresponding NEXT, with A going from 1 to 10
\par                          by 2. Step size is 1 unless specified
\par   NEXT A        Defines end of loop. A is optional
\par   GOSUB 2000    Branches to subtoutine starting at line 2000
\par   RETURN        Marks end of subroutine. Returns to statement following
\par                 most recent GOSUB
\par   ON X GOTO A,B Branches to Xth line number on list. If X=1 branches
\par                 to A, etc.
\par   ON X GOSUB A,B Branches to subroutine at Xth line number in list
\par 
\par \page 
\par 
\par 
\par           ABOUT THE COMMODORE 64 PROGRAMMER'S REFERENCE GUIDE...
\par 
\par 
\par         ----------------------------------------------------------
\par 
\par 
\par 
\par         Game cartridge compability... spectacular sound... arcade
\par         style graphics... and high caliber computing capabilities
\par         make Commodore 64 the most advanced personal computer in
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        its class for home, business and educational use.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par         The COMMODORE 64 PROGRAMMER'S REFERENCE GUIDE tells you
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        everything you need to know about your Commodore 64. The
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        perfect companion to your Commodore 64 User's Guide, this
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        manual presents detailed information on everything from
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        graphics and sound to advanced machine language techniques.
\par         This book is a must for everyone from the beginner to the
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        advanced programmer.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par         For the beginner, the most complicated topics are explained
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        with many sample programs and an easy-to-read writing style.
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        For the advanced programmer, this book has been subjected
\par         to heavy pre-testing with your needs in mind. And it's
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        designed so that you can easily get the most out of your
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        Commodore 64's extensive capabilities.
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                               C= COMMODORE
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                  COMPUTER
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                    COMMODORE BUSINESS MACHINES (UK) LTD.
\par                                675 Ajax Avenue
\par                                 Trading Estate
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                          Slough, Berkshire SL1 4BG
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {                                   ENGLAND
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {        9.95 pounds/22056                        ISBN 0-672-22056-3
\par 
\par \page 
\par 
\par   *********
\par 
\par     The end of the Project 64 etext of the Commodore 64 Programmer's
\par   Reference Guide, first edition.
\par 
\par   *********
\par 
\par }}