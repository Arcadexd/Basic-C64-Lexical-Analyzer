<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<!-- saved from url=(0064)http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora058.html -->
<html style="zoom: 100%;"><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="booktitle" content="Developing Applications With Objective Caml">

<meta name="GENERATOR" content="hevea 1.05-7 of 2000-02-24">
<meta name="Author" content="Christian.Queinnec@lip6.fr">
<link rel="stylesheet" type="text/css" href="./BASIC interpreter_files/videoc-ocda.css">
<script language="JavaScript" src="./BASIC interpreter_files/videoc.js"><!--
//--></script><style type="text/css"></style>
<title>
 BASIC interpreter
</title>
</head>
<body class="regularBody">
<a href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora057.html"><img src="./BASIC interpreter_files/previous_motif.gif" alt="Previous"></a>
<a href="http://caml.inria.fr/pub/docs/oreilly-book/html/index.html"><img src="./BASIC interpreter_files/contents_motif.gif" alt="Contents"></a>
<a href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora059.html"><img src="./BASIC interpreter_files/next_motif.gif" alt="Next"></a>
<hr>

<h2> BASIC interpreter</h2>
<a name="sec-basic"></a>
The application described in this section is a program interpreter for
Basic. Thus, it is a program that can run other programs written in
Basic. Of course, we will only deal with a restricted language,
which contains the following commands:<br>
<br>
<ul>
<li>
 <b>PRINT</b> <i>expression</i> <br>
<br>
<table cellspacing="2" cellpadding="0">
<tbody><tr><td align="center" nowrap="">&nbsp;&nbsp;</td>
<td align="left" nowrap="">Prints the result of the evaluation of the expression.</td>
</tr></tbody></table><br>

</li><li> <b>INPUT</b> <i>variable</i> <br>
<br>
<table cellspacing="2" cellpadding="0">
<tbody><tr><td align="center" nowrap="">&nbsp;&nbsp;</td>
<td align="left" nowrap="">
 Prints a <i>prompt</i> (<tt>?</tt>), reads an integer typed in by the
user, and assigns its value to the variable.</td>
</tr></tbody></table><br>

</li><li> <b>LET</b> <i>variable</i> <b>=</b> <i>expression</i> <br>
<br>
<table cellspacing="2" cellpadding="0">
<tbody><tr><td align="center" nowrap="">&nbsp;&nbsp;</td>
<td align="left" nowrap="">Assigns the result of the evaluation of <i>expression</i> to the variable.</td>
</tr></tbody></table><br>

</li><li> <b>GOTO</b> <i>line number</i><br>
<br>
<table cellspacing="2" cellpadding="0">
<tbody><tr><td align="center" nowrap="">&nbsp;&nbsp;</td>
<td align="left" nowrap="">Continues execution at the given line.</td>
</tr></tbody></table><br>

</li><li> <b>IF</b> <i>condition</i> <b>THEN</b> <i>line number</i> <br>
<br>
<table cellspacing="2" cellpadding="0">
<tbody><tr><td align="center" nowrap="">&nbsp;&nbsp;</td>
<td align="left" nowrap="">
Continues execution at the given line if the <em>condition</em> is true.</td>
</tr></tbody></table><br>

</li><li> <b>REM</b> <i>any string</i> <br>
<br>
<table cellspacing="2" cellpadding="0">
<tbody><tr><td align="center" nowrap="">&nbsp;&nbsp;</td>
<td align="left" nowrap="">One-line comment.</td>
</tr></tbody></table></li></ul>Every line of a Basic program is labelled with a line number, and
contains only one command. For instance, a program that computes and
then prints the factorial of an integer given by the user is written:
<pre> 
 5  REM inputting the argument
10  PRINT " factorial of:"
20  INPUT A
30  LET B = 1 
35  REM beginning of the loop
40  IF A &lt;= 1 THEN 80 
50  LET B = B * A
60  LET A = A - 1
70  GOTO 40 
75  REM prints the result
80  PRINT B
</pre>We also wish to write a small text editor, working as a toplevel interactive
loop. It should be able to add new lines, display a program, execute
it, and display the result.
Execution of the program is started with the
<tt>RUN</tt> command. Here is an example of the evaluation of this
program:
<pre>&gt; RUN
 factorial of: ? 5
120
</pre>The interpreter is implemented in several distinct parts:
<dl compact="compact">
<dt>Description of the abstract syntax</dt><dd>: describes the definition of data
types to represent Basic programs, as well as their components
(lines, commands, expressions, etc.).<br>
<br>

</dd><dt>Program pretty printing</dt><dd>: consists of transforming the
internal representation of Basic programs to strings, in order
to display them.<br>
<br>

</dd><dt>Lexing and parsing</dt><dd>: accomplish the inverse 
transformation, that is, transform a string into the internal
representation of a Basic program (the abstract syntax).<br>
<br>

</dd><dt>Evaluation</dt><dd>: is the heart of the interpreter. It controls
and runs the program. As we will see, functional languages, such as
Objective CAML, are particularly well adapted for this kind of problem.<br>
<br>

</dd><dt>Toplevel interactive loop</dt><dd>: glues together all the previous parts.
</dd></dl><a name="toc79"></a>
<h3> Abstract syntax</h3>
<a name="subsec-gram-basic"></a>
Figure&nbsp;<a href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora058.html#fig-gram-basic">6.2</a> introduces the concrete syntax, as a BNF
grammar, of the Basic we will implement. This kind of description
for language syntaxes is described in chapter&nbsp;<a href="http://caml.inria.fr/pub/docs/oreilly-book/html/index.html#chap-AlexS">11</a>,
page&nbsp;<a href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora106.html#sec-BNF">??</a>.
<blockquote><div align="center"><hr width="80%" size="2"></div>
<div align="center">
<table cellspacing="2" cellpadding="0">
<tbody><tr><td align="right" nowrap=""><font color="navy">Unary_Op</font></td>
<td align="center" nowrap="">::=</td>
<td align="left" nowrap="">- &nbsp;&nbsp; | &nbsp;&nbsp; !</td>
</tr>
<tr><td align="right" nowrap=""><font color="navy">Binary_Op</font></td>
<td align="center" nowrap="">::=</td>
<td align="left" nowrap="">+ &nbsp;&nbsp; | &nbsp;&nbsp; - &nbsp;&nbsp; | &nbsp;&nbsp; * &nbsp;&nbsp; | &nbsp;&nbsp; / &nbsp;&nbsp; |
 &nbsp;&nbsp; %</td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
<td align="center" nowrap="">|</td>
<td align="left" nowrap="">= &nbsp;&nbsp; | &nbsp;&nbsp; &lt; &nbsp;&nbsp; | &nbsp;&nbsp; &gt; &nbsp;&nbsp; | &nbsp;&nbsp; &lt;= &nbsp;&nbsp; |
 &nbsp;&nbsp; &gt;= &nbsp;&nbsp; | &nbsp;&nbsp; &lt;&gt;</td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
<td align="center" nowrap="">|</td>
<td align="left" nowrap="">&amp; &nbsp;&nbsp; | &nbsp;&nbsp; '&nbsp;|&nbsp;'</td>
</tr>
<tr><td align="right" nowrap=""><font color="navy">Expression</font></td>
<td align="center" nowrap="">::=</td>
<td align="left" nowrap=""><em>integer</em></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
<td align="center" nowrap="">|</td>
<td align="left" nowrap=""><em>variable</em></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
<td align="center" nowrap="">|</td>
<td align="left" nowrap=""><tt>"string"</tt></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
<td align="center" nowrap="">|</td>
<td align="left" nowrap=""><font color="navy">Unary_Op</font> &nbsp;&nbsp;<font color="navy">Expression</font></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
<td align="center" nowrap="">|</td>
<td align="left" nowrap=""><font color="navy">Expression</font> &nbsp;&nbsp;<font color="navy">Binary_Op</font> &nbsp;&nbsp;<font color="navy">Expression</font></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
<td align="center" nowrap="">|</td>
<td align="left" nowrap="">(  <font color="navy">Expression</font>   )</td>
</tr>
<tr><td align="right" nowrap=""><font color="navy">Command</font></td>
<td align="center" nowrap="">::=</td>
<td align="left" nowrap=""><b>REM</b>  <em>string</em></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
<td align="center" nowrap="">|</td>
<td align="left" nowrap=""><b>GOTO</b>  <em>integer</em></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
<td align="center" nowrap="">|</td>
<td align="left" nowrap=""><b>LET</b>  <em>variable</em>  =  <font color="navy">Expression</font></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
<td align="center" nowrap="">|</td>
<td align="left" nowrap=""><b>PRINT</b>  <font color="navy">Expression</font></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
<td align="center" nowrap="">|</td>
<td align="left" nowrap=""><b>INPUT</b>  <em>variable</em></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
<td align="center" nowrap="">|</td>
<td align="left" nowrap=""><b>IF</b>  <font color="navy">Expression</font>  <b>THEN</b>  <em>integer</em></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
</tr>
<tr><td align="right" nowrap=""><font color="navy">Line</font></td>
<td align="center" nowrap="">::=</td>
<td align="left" nowrap=""><em>integer</em> <font color="navy">Command</font></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
</tr>
<tr><td align="right" nowrap=""><font color="navy">Program</font></td>
<td align="center" nowrap="">::=</td>
<td align="left" nowrap=""><font color="navy">Line</font></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
<td align="center" nowrap="">|</td>
<td align="left" nowrap=""><font color="navy">Line</font> <font color="navy">Program</font></td>
</tr>
<tr><td align="right" nowrap="">&nbsp;</td>
</tr>
<tr><td align="right" nowrap=""><font color="navy">Phrase</font></td>
<td align="center" nowrap="">::=</td>
<td align="left" nowrap=""><font color="navy">Line</font> | <b>RUN</b> | <b>LIST</b> | <b>END</b></td>
</tr></tbody></table>
</div>
<br>
<div align="center">Figure 6.2: BASIC Grammar.</div><br>

<a name="fig-gram-basic"></a>
<div align="center"><hr width="80%" size="2"></div></blockquote>We can see that the way expressions are defined does not ensure that a
well formed expression can be evaluated. For instance, <tt>1+"hello"</tt> is an expression, and yet it is not possible to evaluate
it. This deliberate choice lets us simplify both the abstract syntax 
and the parsing of the Basic language. The price to pay for
this choice is that a syntactically correct Basic program may generate
a runtime error because of a type mismatch.<br>
<br>
Defining Objective CAML data types for this abstract syntax is easy,
we simply translate the concrete syntax into a sum type:


<pre><br># <b>type</b><code> </code>unr_op<code> </code><code>=</code><code> </code>UMINUS<code> </code><code>|</code><code> </code>NOT<code> </code><code> </code>;;<br># <b>type</b><code> </code>bin_op<code> </code><code>=</code><code> </code>PLUS<code> </code><code>|</code><code> </code>MINUS<code> </code><code>|</code><code> </code>MULT<code> </code><code>|</code><code> </code>DIV<code> </code><code>|</code><code> </code>MOD<code> </code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>EQUAL<code> </code><code>|</code><code> </code>LESS<code> </code><code>|</code><code> </code>LESSEQ<code> </code><code>|</code><code> </code>GREAT<code> </code><code>|</code><code> </code>GREATEQ<code> </code><code>|</code><code> </code>DIFF<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>AND<code> </code><code>|</code><code> </code>OR<code> </code><code> </code>;;<br># <b>type</b><code> </code>expression<code> </code><code>=</code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>ExpInt<code> </code><b>of</b><code> </code>int<code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>ExpVar<code> </code><b>of</b><code> </code>string<br><code> </code><code> </code><code> </code><code>|</code><code> </code>ExpStr<code> </code><b>of</b><code> </code>string<code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>ExpUnr<code> </code><b>of</b><code> </code>unr_op<code> </code><code>*</code><code> </code>expression<br><code> </code><code> </code><code> </code><code>|</code><code> </code>ExpBin<code> </code><b>of</b><code> </code>expression<code> </code><code>*</code><code> </code>bin_op<code> </code><code>*</code><code> </code>expression<code> </code><code> </code>;;<br># <b>type</b><code> </code>command<code> </code><code>=</code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>Rem<code> </code><b>of</b><code> </code>string<br><code> </code><code> </code><code> </code><code>|</code><code> </code>Goto<code> </code><b>of</b><code> </code>int<code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>Print<code> </code><b>of</b><code> </code>expression<br><code> </code><code> </code><code> </code><code>|</code><code> </code>Input<code> </code><b>of</b><code> </code>string<code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>If<code> </code><b>of</b><code> </code>expression<code> </code><code>*</code><code> </code>int<code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>Let<code> </code><b>of</b><code> </code>string<code> </code><code>*</code><code> </code>expression<code> </code><code> </code>;;<br># <b>type</b><code> </code>line<code> </code><code>=</code><code> </code>{<code> </code>num<code> </code><code>:</code><code> </code>int<code> </code>;<code> </code>cmd<code> </code><code>:</code><code> </code>command<code> </code>}<code> </code><code> </code>;;<br># <b>type</b><code> </code>program<code> </code><code>=</code><code> </code>line<code> </code>list<code> </code><code> </code>;;<br>

</pre>
<br>
<br>
We also define the abstract syntax for the commands for the small
program editor:


<pre><br># <b>type</b><code> </code>phrase<code> </code><code>=</code><code> </code><code> </code>Line<code> </code><b>of</b><code> </code>line<code> </code><code>|</code><code> </code>List<code> </code><code>|</code><code> </code>Run<code> </code><code>|</code><code> </code>PEnd<code> </code><code> </code>;;<br>

</pre>
<br>
<br>
It is convenient to allow the programmer to skip some parentheses in
arithmetic expressions. For instance, the expression 1+3*4 is
usually interpreted as 1+(3*4). To this end, we associate an integer
with each operator of the language:


<pre><br># <b>let</b><code> </code>priority_uop<code> </code><code>=</code><code> </code><b>function</b><code> </code>NOT<code> </code>-&gt;<code> </code><code>1</code><code> </code><code>|</code><code> </code>UMINUS<code> </code>-&gt;<code> </code><code>7</code><br><code> </code><b>let</b><code> </code>priority_binop<code> </code><code>=</code><code> </code><b>function</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>MULT<code> </code><code>|</code><code> </code>DIV<code> </code><code> </code>-&gt;<code> </code><code>6</code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>PLUS<code> </code><code>|</code><code> </code>MINUS<code> </code>-&gt;<code> </code><code>5</code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>MOD<code> </code>-&gt;<code> </code><code>4</code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>EQUAL<code> </code><code>|</code><code> </code>LESS<code> </code><code>|</code><code> </code>LESSEQ<code> </code><code>|</code><code> </code>GREAT<code> </code><code>|</code><code> </code>GREATEQ<code> </code><code>|</code><code> </code>DIFF<code> </code>-&gt;<code> </code><code>3</code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>AND<code> </code><code>|</code><code> </code>OR<code> </code>-&gt;<code> </code><code>2</code><code> </code>;;<br><code>val priority_uop : unr_op -&gt; int = &lt;fun&gt;</code><br><code>val priority_binop : bin_op -&gt; int = &lt;fun&gt;</code><br>

</pre>

These integers indicate the priority of the operators. They
will be used to print and parse programs. <br>
<br>
<a name="toc80"></a>
<h3> Program pretty printing</h3>
To print a program, one needs to be able to convert abstract syntax
program lines into strings.<br>
<br>
Converting operators is easy:


<pre><br># <b>let</b><code> </code>pp_binop<code> </code><code>=</code><code> </code><b>function</b><code> </code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>PLUS<code> </code>-&gt;<code> </code><code>"+"</code><code> </code><code>|</code><code> </code>MULT<code> </code>-&gt;<code> </code><code>"*"</code><code> </code><code>|</code><code> </code>MOD<code> </code><code> </code><code> </code>-&gt;<code> </code><code>"%"</code><code> </code><code>|</code><code> </code>MINUS<code> </code>-&gt;<code> </code><code>"-"</code><code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>DIV<code> </code>-&gt;<code> </code><code>"/"</code><code> </code><code> </code><code>|</code><code> </code>EQUAL<code> </code>-&gt;<code> </code><code>" = "</code><code> </code><code>|</code><code> </code>LESS<code> </code>-&gt;<code> </code><code>" &lt; "</code><code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>LESSEQ<code> </code>-&gt;<code> </code><code>" &lt;= "</code><code> </code><code> </code><code> </code><code>|</code><code> </code>GREAT<code> </code><code> </code><code> </code>-&gt;<code> </code><code>" &gt; "</code><code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>GREATEQ<code> </code>-&gt;<code> </code><code>" &gt;= "</code><code> </code><code> </code><code> </code><code>|</code><code> </code>DIFF<code> </code><code> </code>-&gt;<code> </code><code>" &lt;&gt; "</code><code> </code><code>|</code><code> </code>AND<code> </code>-&gt;<code> </code><code>" &amp; "</code><code> </code><code>|</code><code> </code>OR<code> </code>-&gt;<code> </code><code>" | "</code><code> </code><code> </code><br><code> </code><b>let</b><code> </code>pp_unrop<code> </code><code>=</code><code> </code><b>function</b><code> </code>UMINUS<code> </code>-&gt;<code> </code><code>"-"</code><code> </code><code> </code><code>|</code><code> </code>NOT<code> </code>-&gt;<code> </code><code>"!"</code><code> </code><code> </code>;;<br><code>val pp_binop : bin_op -&gt; string = &lt;fun&gt;</code><br><code>val pp_unrop : unr_op -&gt; string = &lt;fun&gt;</code><br>

</pre>

Expression printing needs to take into account operator priority to
print as few parentheses as possible. For instance, parentheses are
put around a subexpression at the right of an operator only if the
subexpression's main operator has a lower priority that the main
operator of the whole expression. Also, arithmetic operators are
left-associative, thus the expression 1-2-3 is interpreted as
(1-2)-3.<br>
<br>
To deal with this, we use two auxiliary functions <tt>ppl</tt> and
<tt>ppr</tt> to print left and right subtrees, respectively. These
functions take two arguments: the tree to print and the priority of
the enclosing operator, which is used to decide if parentheses are 
necessary. Left
and right subtrees are distinguished to deal with associativity. If
the current operator priority is the same than the enclosing operator
priority, left trees do not need parentheses whereas right ones may
require them, as in 1-(2-3) or 1-(2+3).<br>
<br>
The initial tree is taken as a left subtree with minimal priority
(0).
The expression pretty printing function <tt>pp_expression</tt> is:


<pre><br># <b>let</b><code> </code>parenthesis<code> </code>x<code> </code><code>=</code><code> </code><code>"("</code><code> </code><code>^</code><code> </code>x<code> </code><code>^</code><code> </code><code>")"</code>;;<code> </code><code> </code><br><code>val parenthesis : string -&gt; string = &lt;fun&gt;</code><br># <b>let</b><code> </code>pp_expression<code> </code><code>=</code><code> </code><br><code> </code><code> </code><b>let</b><code> </code><b>rec</b><code> </code>ppl<code> </code>pr<code> </code><code>=</code><code> </code><b>function</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>ExpInt<code> </code>n<code> </code>-&gt;<code> </code><tt>(</tt>string_of_int<code> </code>n<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>ExpVar<code> </code>v<code> </code>-&gt;<code> </code>v<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>ExpStr<code> </code>s<code> </code>-&gt;<code> </code><code>"\""</code><code> </code><code>^</code><code> </code>s<code> </code><code>^</code><code> </code><code>"\""</code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>ExpUnr<code> </code><tt>(</tt>op<code>,</code>e<tt>)</tt><code> </code>-&gt;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>let</b><code> </code>res<code> </code><code>=</code><code> </code><tt>(</tt>pp_unrop<code> </code>op<tt>)</tt><code>^</code><tt>(</tt>ppl<code> </code><tt>(</tt>priority_uop<code> </code>op<tt>)</tt><code> </code>e<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code><b>if</b><code> </code>pr<code>=</code><code>0</code><code> </code><b>then</b><code> </code>res<code> </code><b>else</b><code> </code>parenthesis<code> </code>res<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>ExpBin<code> </code><tt>(</tt>e1<code>,</code>op<code>,</code>e2<tt>)</tt><code> </code>-&gt;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>let</b><code> </code>pr2<code> </code><code>=</code><code> </code>priority_binop<code> </code>op<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code><b>let</b><code> </code>res<code> </code><code>=</code><code> </code><tt>(</tt>ppl<code> </code>pr2<code> </code>e1<tt>)</tt><code>^</code><tt>(</tt>pp_binop<code> </code>op<tt>)</tt><code>^</code><tt>(</tt>ppr<code> </code>pr2<code> </code>e2<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>(* parenthesis if priority is not greater *)</code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code><b>if</b><code> </code>pr2<code> </code><code>&gt;=</code><code> </code>pr<code> </code><b>then</b><code> </code>res<code> </code><b>else</b><code> </code>parenthesis<code> </code>res<br><code> </code><code> </code><code> </code><b>and</b><code> </code>ppr<code> </code>pr<code> </code>exp<code> </code><code>=</code><code> </code><b>match</b><code> </code>exp<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>(*  right subtrees only differ for binary operators *)</code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>ExpBin<code> </code><tt>(</tt>e1<code>,</code>op<code>,</code>e2<tt>)</tt><code> </code>-&gt;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>let</b><code> </code>pr2<code> </code><code>=</code><code> </code>priority_binop<code> </code>op<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code><b>let</b><code> </code>res<code> </code><code>=</code><code> </code><tt>(</tt>ppl<code> </code>pr2<code> </code>e1<tt>)</tt><code>^</code><tt>(</tt>pp_binop<code> </code>op<tt>)</tt><code>^</code><tt>(</tt>ppr<code> </code>pr2<code> </code>e2<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code><b>if</b><code> </code>pr2<code> </code><code>&gt;</code><code> </code>pr<code> </code><b>then</b><code> </code>res<code> </code><b>else</b><code> </code>parenthesis<code> </code>res<br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>ppl<code> </code>pr<code> </code>exp<br><code> </code><code> </code><code> </code><b>in</b><code> </code>ppl<code> </code><code>0</code><code> </code>;;<br><code>val pp_expression : expression -&gt; string = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
Command pretty printing uses the expression pretty printing
function. Printing a line consists of printing the line number before
the command.


<pre><br># <b>let</b><code> </code>pp_command<code> </code><code>=</code><code> </code><b>function</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>Rem<code> </code>s<code> </code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code><code> </code><code>"REM "</code><code> </code><code>^</code><code> </code>s<br><code> </code><code> </code><code> </code><code>|</code><code> </code>Goto<code> </code>n<code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code><code> </code><code>"GOTO "</code><code> </code><code>^</code><code> </code><tt>(</tt>string_of_int<code> </code>n<tt>)</tt><br><code> </code><code> </code><code> </code><code>|</code><code> </code>Print<code> </code>e<code> </code><code> </code><code> </code>-&gt;<code> </code><code> </code><code>"PRINT "</code><code> </code><code>^</code><code> </code><tt>(</tt>pp_expression<code> </code>e<tt>)</tt><br><code> </code><code> </code><code> </code><code>|</code><code> </code>Input<code> </code>v<code> </code><code> </code><code> </code>-&gt;<code> </code><code> </code><code>"INPUT "</code><code> </code><code>^</code><code> </code>v<br><code> </code><code> </code><code> </code><code>|</code><code> </code>If<code> </code><tt>(</tt>e<code>,</code>n<tt>)</tt><code> </code><code> </code>-&gt;<code> </code><code> </code><code>"IF "</code><code>^</code><tt>(</tt>pp_expression<code> </code>e<tt>)</tt><code>^</code><code>" THEN "</code><code>^</code><tt>(</tt>string_of_int<code> </code>n<tt>)</tt><br><code> </code><code> </code><code> </code><code>|</code><code> </code>Let<code> </code><tt>(</tt>v<code>,</code>e<tt>)</tt><code> </code>-&gt;<code> </code><code> </code><code>"LET "</code><code> </code><code>^</code><code> </code>v<code> </code><code>^</code><code> </code><code>" = "</code><code> </code><code>^</code><code> </code><tt>(</tt>pp_expression<code> </code>e<tt>)</tt><code> </code><code> </code>;;<br><code>val pp_command : command -&gt; string = &lt;fun&gt;</code><br># <b>let</b><code> </code>pp_line<code> </code>l<code> </code><code>=</code><code> </code><tt>(</tt>string_of_int<code> </code>l<code>.</code>num<tt>)</tt><code> </code><code>^</code><code> </code><code>"  "</code><code> </code><code>^</code><code> </code><tt>(</tt>pp_command<code> </code>l<code>.</code>cmd<tt>)</tt><code> </code><code> </code>;;<br><code>val pp_line : line -&gt; string = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
<a name="toc81"></a>
<h3> Lexing</h3><a name="basic-lex0"></a>Lexing and parsing do the inverse transformation of
printing, going from a string to a syntax tree. Lexing
splits the text of a command line into independent lexical units
called lexemes, with Objective CAML type:


<pre><br># <b>type</b><code> </code>lexeme<code> </code><code>=</code><code> </code>Lint<code> </code><b>of</b><code> </code>int<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Lident<code> </code><b>of</b><code> </code>string<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Lsymbol<code> </code><b>of</b><code> </code>string<code> </code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Lstring<code> </code><b>of</b><code> </code>string<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Lend<code> </code>;;<br>

</pre>

A particular lexeme denotes the end of an expression: <tt>Lend</tt>.
It is not present in the text of the expression, but is created by the
lexing function (see the <tt>lexer</tt> function, page
<a href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora058.html#fun-lexer">??</a>).<br>
<br>
The string being lexed is kept in a record that contains a mutable
field indicating the position after which lexing has not been
done yet. Since the size of the string is used several times and does
not change, it is also stored in the record:


<pre><br># <b>type</b><code> </code>string_lexer<code> </code><code>=</code><code> </code>{string<code>:</code>string;<code> </code><b>mutable</b><code> </code>current<code>:</code>int;<code> </code>size<code>:</code>int<code> </code>}<code> </code>;;<br>

</pre>

This representation lets us define the lexing of a string as the
application of a function to a value of type <i>string_lexer</i>
returning a value of type <i>lexeme</i>. Modifying the current
position in the string is done as a side effect.<br>
<br>


<pre><br># <b>let</b><code> </code>init_lex<code> </code>s<code> </code><code>=</code><code> </code>{<code> </code>string<code>=</code>s;<code> </code>current<code>=</code><code>0</code><code> </code>;<code> </code>size<code>=</code>String.length<code> </code>s<code> </code>}<code> </code>;;<br><code>val init_lex : string -&gt; string_lexer = &lt;fun&gt;</code><br># <b>let</b><code> </code>forward<code> </code>cl<code> </code><code>=</code><code> </code>cl<code>.</code>current<code> </code><code>&lt;-</code><code> </code>cl<code>.</code>current<code>+</code><code>1</code><code> </code><code> </code>;;<br><code>val forward : string_lexer -&gt; unit = &lt;fun&gt;</code><br># <b>let</b><code> </code>forward_n<code> </code>cl<code> </code>n<code> </code><code>=</code><code> </code>cl<code>.</code>current<code> </code><code>&lt;-</code><code> </code>cl<code>.</code>current<code>+</code>n<code> </code>;;<br><code>val forward_n : string_lexer -&gt; int -&gt; unit = &lt;fun&gt;</code><br># <b>let</b><code> </code>extract<code> </code>pred<code> </code>cl<code> </code><code>=</code><code> </code><br><code> </code><code> </code><code> </code><b>let</b><code> </code>st<code> </code><code>=</code><code> </code>cl<code>.</code>string<code> </code><b>and</b><code> </code>pos<code> </code><code>=</code><code> </code>cl<code>.</code>current<code> </code><b>in</b><br><code> </code><code> </code><code> </code><b>let</b><code> </code><b>rec</b><code> </code>ext<code> </code>n<code> </code><code>=</code><code> </code><b>if</b><code> </code>n<code>&lt;</code>cl<code>.</code>size<code> </code><code>&amp;&amp;</code><code> </code><tt>(</tt>pred<code> </code>st<code>.[</code>n<code>]</code><tt>)</tt><code> </code><b>then</b><code> </code>ext<code> </code><tt>(</tt>n<code>+</code><code>1</code><tt>)</tt><code> </code><b>else</b><code> </code>n<code> </code><b>in</b><code> </code><br><code> </code><code> </code><code> </code><b>let</b><code> </code>res<code> </code><code>=</code><code> </code>ext<code> </code>pos<br><code> </code><code> </code><code> </code><b>in</b><code> </code>cl<code>.</code>current<code> </code><code>&lt;-</code><code> </code>res<code> </code>;<code> </code>String.sub<code> </code>cl<code>.</code>string<code> </code>pos<code> </code><tt>(</tt>res<code>-</code>pos<tt>)</tt><code> </code><code> </code>;;<br><code>val extract : (char -&gt; bool) -&gt; string_lexer -&gt; string = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
The following functions extract a lexeme from the string and modify
the current position. The two functions <tt>extract_int</tt> and
<tt>extract_ident</tt> extract an integer and an identifier,
respectively.


<pre><br># <b>let</b><code> </code>extract_int<code> </code><code>=</code><code> </code><br><code> </code><code> </code><code> </code><code> </code><b>let</b><code> </code>is_int<code> </code><code>=</code><code> </code><b>function</b><code> </code><code>'0'</code><code>..</code><code>'9'</code><code> </code>-&gt;<code> </code><b>true</b><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code><b>false</b><code> </code><code> </code><br><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code><b>function</b><code> </code>cl<code> </code>-&gt;<code> </code>int_of_string<code> </code><tt>(</tt>extract<code> </code>is_int<code> </code>cl<tt>)</tt><br><code> </code><b>let</b><code> </code>extract_ident<code> </code><code>=</code><br><code> </code><code> </code><code> </code><code> </code><b>let</b><code> </code>is_alpha_num<code> </code><code>=</code><code> </code><b>function</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>'a'</code><code>..</code><code>'z'</code><code> </code><code>|</code><code> </code><code>'A'</code><code>..</code><code>'Z'</code><code> </code><code>|</code><code> </code><code>'0'</code><code> </code><code>..</code><code> </code><code>'9'</code><code> </code><code>|</code><code> </code><code>'_'</code><code> </code>-&gt;<code> </code><b>true</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code><b>false</b><code> </code><code> </code><br><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code>extract<code> </code>is_alpha_num<code> </code>;;<br><code>val extract_int : string_lexer -&gt; int = &lt;fun&gt;</code><br><code>val extract_ident : string_lexer -&gt; string = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
The <tt>lexer</tt> function uses the two previous functions to extract
a lexeme.


<pre><br># <b>exception</b><code> </code>LexerError<code> </code>;;<br><code>exception LexerError</code><br># <b>let</b><code> </code><code> </code><b>rec</b><code> </code>lexer<code> </code>cl<code> </code><code>=</code><code> </code><br><code> </code><code> </code><code> </code><b>let</b><code> </code>lexer_char<code> </code>c<code> </code><code>=</code><code> </code><b>match</b><code> </code>c<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>' '</code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>'\t'</code><code> </code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code>forward<code> </code>cl<code> </code>;<code> </code>lexer<code> </code>cl<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>'a'</code><code>..</code><code>'z'</code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>'A'</code><code>..</code><code>'Z'</code><code> </code>-&gt;<code> </code>Lident<code> </code><tt>(</tt>extract_ident<code> </code>cl<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>'0'</code><code>..</code><code>'9'</code><code> </code>-&gt;<code> </code>Lint<code> </code><tt>(</tt>extract_int<code> </code>cl<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>'"'</code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code>forward<code> </code>cl<code> </code>;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>let</b><code> </code>res<code> </code><code>=</code><code> </code>Lstring<code> </code><tt>(</tt>extract<code> </code><tt>(</tt><tt>(</tt><code>&lt;&gt;</code><tt>)</tt><code> </code><code>'"'</code><tt>)</tt><code> </code>cl<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code>forward<code> </code>cl<code> </code>;<code> </code>res<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>'+'</code><code> </code><code>|</code><code> </code><code>'-'</code><code> </code><code>|</code><code> </code><code>'*'</code><code> </code><code>|</code><code> </code><code>'/'</code><code> </code><code>|</code><code> </code><code>'%'</code><code> </code><code>|</code><code> </code><code>'&amp;'</code><code> </code><code>|</code><code> </code><code>'|'</code><code> </code><code>|</code><code> </code><code>'!'</code><code> </code><code>|</code><code> </code><code>'='</code><code> </code><code>|</code><code> </code><code>'('</code><code> </code><code>|</code><code> </code><code>')'</code><code> </code><code> </code>-&gt;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>forward<code> </code>cl;<code> </code>Lsymbol<code> </code><tt>(</tt>String.make<code> </code><code>1</code><code> </code>c<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>'&lt;'</code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>'&gt;'</code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code>forward<code> </code>cl;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>if</b><code> </code>cl<code>.</code>current<code> </code><code>&gt;=</code><code> </code>cl<code>.</code>size<code> </code><b>then</b><code> </code>Lsymbol<code> </code><tt>(</tt>String.make<code> </code><code>1</code><code> </code>c<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>else</b><code> </code><code> </code><b>let</b><code> </code>cs<code> </code><code>=</code><code> </code>cl<code>.</code>string<code>.[</code>cl<code>.</code>current<code>]</code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code><tt>(</tt><code> </code><b>match</b><code> </code><tt>(</tt>c<code>,</code>cs<tt>)</tt><code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><tt>(</tt><code>'&lt;'</code><code>,</code><code>'='</code><tt>)</tt><code> </code>-&gt;<code> </code>forward<code> </code>cl;<code> </code>Lsymbol<code> </code><code>"&lt;="</code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><tt>(</tt><code>'&gt;'</code><code>,</code><code>'='</code><tt>)</tt><code> </code>-&gt;<code> </code>forward<code> </code>cl;<code> </code>Lsymbol<code> </code><code>"&gt;="</code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><tt>(</tt><code>'&lt;'</code><code>,</code><code>'&gt;'</code><tt>)</tt><code> </code>-&gt;<code> </code>forward<code> </code>cl;<code> </code>Lsymbol<code> </code><code>"&lt;&gt;"</code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code> </code><code> </code><code> </code><code> </code><code>_</code><code> </code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code>Lsymbol<code> </code><tt>(</tt>String.make<code> </code><code>1</code><code> </code>c<tt>)</tt><code> </code><tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>raise<code> </code>LexerError<br><code> </code><code> </code><code> </code><b>in</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>if</b><code> </code>cl<code>.</code>current<code> </code><code>&gt;=</code><code> </code>cl<code>.</code>size<code> </code><b>then</b><code> </code>Lend<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>else</b><code> </code>lexer_char<code> </code>cl<code>.</code>string<code>.[</code>cl<code>.</code>current<code>]</code><code> </code>;;<br><code>val lexer : string_lexer -&gt; lexeme = &lt;fun&gt;</code><br>

</pre>
<a name="fun-lexer"></a><br>
<br>
The <tt>lexer</tt> function is very simple: it matches the current
character of a string and, based on its value, extracts the
corresponding lexeme and modifies the current position to the start of
the next lexeme. The code is simple because, for all characters except
two, the current character defines which lexeme to extract. In the
more complicated cases of <code>'&lt;'</code>, we need to look at the next
character, which might be a <code>'='</code> or a <code>'&gt;'</code>, producing two different
lexemes. The same problem arises with <code>'&gt;'</code>.<br>
<br>
<a name="toc82"></a>
<h3> Parsing</h3><a name="basic-synt0"></a>
The only difficulty in parsing our language comes from expressions.
Indeed, knowing the beginning of an expression is not enough to know
its structure. For instance, having parsed the beginning of an
expression as being 1+2+3, the resulting syntax tree for this part
depends on the rest of the expression: its structure is different when
it is followed by +4 or *4 (see figure <a href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora058.html#fig-basic-ex1">6.3</a>).
<blockquote><div align="center"><hr width="80%" size="2"></div>
<div align="center">
<img src="./BASIC interpreter_files/book-ora022.gif"> </div>
<br>
<div align="center">Figure 6.3: Basic: abstract syntax tree examples<a name="fig-basic-ex1"></a>.</div><br>

<div align="center"><hr width="80%" size="2"></div></blockquote>
However, since the tree structure for 1+2 is the same in both cases,
it can be built. As the position of +3 in the structure is not fully
known, it is temporarily stored.<br>
<br>
To build the abstract syntax tree, we use a pushdown automaton
similar to the one built by <em>yacc</em> (see page
<a href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora106.html#sec-ocamlyacc">??</a>). Lexemes are read one by one and put
on a stack until there is enough information to build the
expression. They are then removed from the stack and replaced by the
expression. This latter operation is called reduction.<br>
<br>
The stack elements have type:


<pre><br># <b>type</b><code> </code>exp_elem<code> </code><code>=</code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>Texp<code> </code><b>of</b><code> </code>expression<code> </code><code> </code><code> </code><code>(* expression       *)</code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>Tbin<code> </code><b>of</b><code> </code>bin_op<code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>(* binary operator  *)</code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>Tunr<code> </code><b>of</b><code> </code>unr_op<code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>(* unary operator   *)</code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>Tlp<code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>(* left parenthesis *)</code><code> </code>;;<br>

</pre>

Right parentheses are not stored on the stack as only left parentheses
matter for reduction.<br>
<br>
Figure <a href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora058.html#fig-basic-ex2">6.4</a> illustrates the way the stack is used to
parse the expression (1+2*3)+4. The character above the arrow is the
current character of the string.
<blockquote><div align="center"><hr width="80%" size="2"></div>
<div align="center">
<img src="./BASIC interpreter_files/book-ora023.gif">
</div>
<br>
<div align="center">Figure 6.4: Basic: abstract syntax tree construction
 example<a name="fig-basic-ex2"></a>.</div><br>

<div align="center"><hr width="80%" size="2"></div></blockquote>We define an exception for syntax errors.


<pre><br># <b>exception</b><code> </code>ParseError<code> </code>;;<br>

</pre>

The first step consists of transforming symbols into operators:


<pre><br># <b>let</b><code> </code>unr_symb<code> </code><code>=</code><code> </code><b>function</b><code> </code><br><code> </code><code> </code><code> </code><code>"!"</code><code> </code>-&gt;<code> </code>NOT<code> </code><code>|</code><code> </code><code>"-"</code><code> </code>-&gt;<code> </code>UMINUS<code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>raise<code> </code>ParseError<code> </code><br><code> </code><b>let</b><code> </code>bin_symb<code> </code><code>=</code><code> </code><b>function</b><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>"+"</code><code> </code>-&gt;<code> </code>PLUS<code> </code><code>|</code><code> </code><code>"-"</code><code> </code>-&gt;<code> </code>MINUS<code> </code><code>|</code><code> </code><code>"*"</code><code> </code>-&gt;<code> </code>MULT<code> </code><code>|</code><code> </code><code>"/"</code><code> </code>-&gt;<code> </code>DIV<code> </code><code>|</code><code> </code><code>"%"</code><code> </code>-&gt;<code> </code>MOD<code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code><code>"="</code><code> </code>-&gt;<code> </code>EQUAL<code> </code><code>|</code><code> </code><code>"&lt;"</code><code> </code>-&gt;<code> </code>LESS<code> </code><code>|</code><code> </code><code>"&lt;="</code><code> </code>-&gt;<code> </code>LESSEQ<code> </code><code>|</code><code> </code><code>"&gt;"</code><code> </code>-&gt;<code> </code>GREAT<code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code><code>"&gt;="</code><code> </code>-&gt;<code> </code>GREATEQ<code> </code><code>|</code><code> </code><code>"&lt;&gt;"</code><code> </code>-&gt;<code> </code>DIFF<code> </code><code>|</code><code> </code><code>"&amp;"</code><code> </code>-&gt;<code> </code>AND<code> </code><code>|</code><code> </code><code>"|"</code><code> </code>-&gt;<code> </code>OR<code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>raise<code> </code>ParseError<code> </code><br><code> </code><b>let</b><code> </code>tsymb<code> </code>s<code> </code><code>=</code><code> </code><b>try</b><code> </code>Tbin<code> </code><tt>(</tt>bin_symb<code> </code>s<tt>)</tt><code> </code><b>with</b><code> </code>ParseError<code> </code>-&gt;<code> </code>Tunr<code> </code><tt>(</tt>unr_symb<code> </code>s<tt>)</tt><code> </code>;;<br><code>val unr_symb : string -&gt; unr_op = &lt;fun&gt;</code><br><code>val bin_symb : string -&gt; bin_op = &lt;fun&gt;</code><br><code>val tsymb : string -&gt; exp_elem = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
The <tt>reduce</tt> function implements stack reduction. There are two
cases to consider, whether the stack starts with:
<ul>
<li>
 
an expression followed by a unary operator,

</li><li> 
an expression followed by a binary operator and an expression.
</li></ul>
Moreover, <tt>reduce</tt> takes an argument indicating the minimal
priority that an operator should have to trigger reduction. To avoid
this reduction condition, it suffices to give the minimal value, zero, 
as the priority.


<pre><br># <b>let</b><code> </code>reduce<code> </code>pr<code> </code><code>=</code><code> </code><b>function</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><tt>(</tt>Texp<code> </code>e<tt>)</tt>::<tt>(</tt>Tunr<code> </code>op<tt>)</tt>::st<code> </code><code> </code><b>when</b><code> </code><code> </code><tt>(</tt>priority_uop<code> </code>op<tt>)</tt><code> </code><code>&gt;=</code><code> </code>pr<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code><tt>(</tt>Texp<code> </code><tt>(</tt>ExpUnr<code> </code><tt>(</tt>op<code>,</code>e<tt>)</tt><tt>)</tt><tt>)</tt>::st<br><code> </code><code> </code><code> </code><code>|</code><code> </code><tt>(</tt>Texp<code> </code>e1<tt>)</tt>::<tt>(</tt>Tbin<code> </code>op<tt>)</tt>::<tt>(</tt>Texp<code> </code>e2<tt>)</tt>::st<code> </code><code> </code><b>when</b><code> </code><code> </code><tt>(</tt>priority_binop<code> </code>op<tt>)</tt><code> </code><code>&gt;=</code><code> </code>pr<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code><tt>(</tt>Texp<code> </code><tt>(</tt>ExpBin<code> </code><tt>(</tt>e2<code>,</code>op<code>,</code>e1<tt>)</tt><tt>)</tt><tt>)</tt>::st<code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>raise<code> </code>ParseError<code> </code>;;<br><code>val reduce : int -&gt; exp_elem list -&gt; exp_elem list = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
Notice that expression elements are stacked as they are read. Thus it
is necessary to swap them when they are arguments of a binary
operator.<br>
<br>
The main function of our parser is <tt>stack_or_reduce</tt> that,
according to the lexeme given in argument, puts it on the stack or
triggers a reduction.


<pre><br># <b>let</b><code> </code><b>rec</b><code> </code>stack_or_reduce<code> </code>lex<code> </code>stack<code> </code><code>=</code><code> </code><b>match</b><code> </code>lex<code> </code><code>,</code><code> </code>stack<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>Lint<code> </code>n<code> </code><code>,</code><code> </code><code> </code><code>_</code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code><code> </code><tt>(</tt>Texp<code> </code><tt>(</tt>ExpInt<code> </code>n<tt>)</tt><tt>)</tt>::stack<code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>Lident<code> </code>v<code> </code><code>,</code><code> </code><code> </code><code>_</code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code><code> </code><tt>(</tt>Texp<code> </code><tt>(</tt>ExpVar<code> </code>v<tt>)</tt><tt>)</tt>::stack<code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>Lstring<code> </code>s<code> </code><code>,</code><code> </code><code>_</code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code><code> </code><tt>(</tt>Texp<code> </code><tt>(</tt>ExpStr<code> </code>s<tt>)</tt><tt>)</tt>::stack<br><code> </code><code> </code><code> </code><code>|</code><code> </code>Lsymbol<code> </code><code>"("</code><code> </code><code>,</code><code> </code><code>_</code><code> </code><code> </code>-&gt;<code> </code><code> </code>Tlp::stack<br><code> </code><code> </code><code> </code><code>|</code><code> </code>Lsymbol<code> </code><code>")"</code><code> </code><code>,</code><code> </code><tt>(</tt>Texp<code> </code>e<tt>)</tt>::Tlp::st<code> </code><code> </code>-&gt;<code> </code><code> </code><tt>(</tt>Texp<code> </code>e<tt>)</tt>::st<br><code> </code><code> </code><code> </code><code>|</code><code> </code>Lsymbol<code> </code><code>")"</code><code> </code><code>,</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>stack_or_reduce<code> </code>lex<code> </code><tt>(</tt>reduce<code> </code><code>0</code><code> </code>stack<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>Lsymbol<code> </code>s<code> </code><code>,</code><code> </code><code>_</code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code><b>let</b><code> </code>symbol<code> </code><code>=</code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>if</b><code> </code>s<code>&lt;&gt;</code><code>"-"</code><code> </code><b>then</b><code> </code>tsymb<code> </code>s<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>(* remove the ambiguity of the ``-'' symbol           *)</code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>(* according to the last exp element put on the stack *)</code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>else</b><code> </code><b>match</b><code> </code>stack<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>with</b><code> </code><tt>(</tt>Texp<code> </code><code>_</code><tt>)</tt><code>::_</code><code> </code><code> </code>-&gt;<code> </code><code> </code>Tbin<code> </code>MINUS<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code><code> </code>Tunr<code> </code>UMINUS<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code><tt>(</tt><code> </code><b>match</b><code> </code>symbol<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>Tunr<code> </code>op<code> </code><code> </code>-&gt;<code> </code><code> </code><tt>(</tt>Tunr<code> </code>op<tt>)</tt>::stack<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Tbin<code> </code>op<code> </code><code> </code>-&gt;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><tt>(</tt><code> </code><b>try</b><code> </code>stack_or_reduce<code> </code>lex<code> </code><tt>(</tt>reduce<code> </code><tt>(</tt>priority_binop<code> </code>op<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>stack<code> </code><tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>with</b><code> </code>ParseError<code> </code>-&gt;<code> </code><tt>(</tt>Tbin<code> </code>op<tt>)</tt>::stack<code> </code><tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>raise<code> </code>ParseError<code> </code><tt>)</tt><br><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code><code>,</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>raise<code> </code>ParseError<code> </code>;;<br><code>val stack_or_reduce : lexeme -&gt; exp_elem list -&gt; exp_elem list = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
Once all lexemes are defined and stacked, the function
<tt>reduce_all</tt> builds the abstract syntax tree with the elements
remaining in the stack. If the expression being parsed is well formed,
only one element should remain in the stack, containing the tree for
this expression.


<pre><br># <b>let</b><code> </code><b>rec</b><code> </code>reduce_all<code> </code><code>=</code><code> </code><b>function</b><code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>[]<code> </code>-&gt;<code> </code>raise<code> </code>ParseError<br><code> </code><code> </code><code> </code><code>|</code><code> </code><code>[</code>Texp<code> </code>x<code>]</code><code> </code>-&gt;<code> </code>x<code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>st<code> </code>-&gt;<code> </code>reduce_all<code> </code><tt>(</tt>reduce<code> </code><code>0</code><code> </code>st<tt>)</tt><code> </code>;;<br><code>val reduce_all : exp_elem list -&gt; expression = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
The <tt>parse_exp</tt> function is the main expression parsing
function. It reads a string, extracts its lexemes and passes them to the
<tt>stack_or_reduce</tt> function. Parsing stops when the current
lexeme satisfies a predicate that is given as an argument.


<pre><br># <b>let</b><code> </code>parse_exp<code> </code>stop<code> </code>cl<code> </code><code>=</code><code> </code><br><code> </code><code> </code><code> </code><b>let</b><code> </code>p<code> </code><code>=</code><code> </code>ref<code> </code><code>0</code><code> </code><b>in</b><code> </code><br><code> </code><code> </code><code> </code><b>let</b><code> </code><b>rec</b><code> </code>parse_one<code> </code>stack<code> </code><code> </code><code>=</code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><b>let</b><code> </code>l<code> </code><code>=</code><code> </code><tt>(</tt><code> </code>p<code>:=</code>cl<code>.</code>current<code> </code>;<code> </code>lexer<code> </code>cl<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code><b>if</b><code> </code>not<code> </code><tt>(</tt>stop<code> </code>l<tt>)</tt><code> </code><b>then</b><code> </code>parse_one<code> </code><tt>(</tt>stack_or_reduce<code> </code>l<code> </code>stack<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>else</b><code> </code><tt>(</tt><code> </code>cl<code>.</code>current<code> </code><code>&lt;-</code><code> </code><code>!</code>p<code> </code>;<code> </code>reduce_all<code> </code>stack<code> </code><tt>)</tt><br><code> </code><code> </code><code> </code><b>in</b><code> </code>parse_one<code> </code>[]<code> </code><code> </code>;;<br><code>val parse_exp : (lexeme -&gt; bool) -&gt; string_lexer -&gt; expression = &lt;fun&gt;</code><br>

</pre>

Notice that the lexeme that made the parsing stop is not used to build
the expression. It is thus necessary to modify the current position to
its beginning (variable <tt>p</tt>) to parse it later.<br>
<br>
We can now parse a command line:


<pre><br># <b>let</b><code> </code>parse_cmd<code> </code>cl<code> </code><code>=</code><code> </code><b>match</b><code> </code>lexer<code> </code>cl<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>Lident<code> </code>s<code> </code>-&gt;<code> </code><tt>(</tt><code> </code><b>match</b><code> </code>s<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>"REM"</code><code> </code>-&gt;<code> </code>Rem<code> </code><tt>(</tt>extract<code> </code><tt>(</tt><b>fun</b><code> </code><code>_</code><code> </code>-&gt;<code> </code><b>true</b><tt>)</tt><code> </code>cl<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>"GOTO"</code><code> </code>-&gt;<code> </code>Goto<code> </code><tt>(</tt><b>match</b><code> </code>lexer<code> </code>cl<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>Lint<code> </code>p<code> </code>-&gt;<code> </code>p<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>raise<code> </code>ParseError<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>"INPUT"</code><code> </code>-&gt;<code> </code>Input<code> </code><tt>(</tt><b>match</b><code> </code>lexer<code> </code>cl<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>Lident<code> </code>v<code> </code>-&gt;<code> </code>v<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>raise<code> </code>ParseError<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>"PRINT"</code><code> </code>-&gt;<code> </code>Print<code> </code><tt>(</tt>parse_exp<code> </code><tt>(</tt><tt>(</tt><code>=</code><tt>)</tt><code> </code>Lend<tt>)</tt><code> </code>cl<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>"LET"</code><code> </code>-&gt;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>let</b><code> </code>l2<code> </code><code>=</code><code> </code>lexer<code> </code>cl<code> </code><b>and</b><code> </code>l3<code> </code><code>=</code><code> </code>lexer<code> </code>cl<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code><tt>(</tt><code> </code><b>match</b><code> </code>l2<code> </code><code>,</code>l3<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><tt>(</tt>Lident<code> </code>v<code>,</code>Lsymbol<code> </code><code>"="</code><tt>)</tt><code> </code>-&gt;<code> </code>Let<code> </code><tt>(</tt>v<code>,</code>parse_exp<code> </code><tt>(</tt><tt>(</tt><code>=</code><tt>)</tt><code> </code>Lend<tt>)</tt><code> </code>cl<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>raise<code> </code>ParseError<code> </code><tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>"IF"</code><code> </code>-&gt;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>let</b><code> </code>test<code> </code><code>=</code><code> </code>parse_exp<code> </code><tt>(</tt><tt>(</tt><code>=</code><tt>)</tt><code> </code><tt>(</tt>Lident<code> </code><code>"THEN"</code><tt>)</tt><tt>)</tt><code> </code>cl<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code><tt>(</tt><code> </code><b>match</b><code> </code>ignore<code> </code><tt>(</tt>lexer<code> </code>cl<tt>)</tt><code> </code>;<code> </code>lexer<code> </code>cl<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>Lint<code> </code>n<code> </code><code> </code>-&gt;<code> </code><code> </code>If<code> </code><tt>(</tt>test<code>,</code>n<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>raise<code> </code>ParseError<code> </code><tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>raise<code> </code>ParseError<code> </code><tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>raise<code> </code>ParseError<code> </code><code> </code>;;<br><code>val parse_cmd : string_lexer -&gt; command = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
Finally, we implement the function to parse commands typed by the
user:
<a name="fun-basic-parse"></a>


<pre><br># <b>let</b><code> </code>parse<code> </code>str<code> </code><code>=</code><code> </code><br><code> </code><code> </code><code> </code><b>let</b><code> </code>cl<code> </code><code>=</code><code> </code>init_lex<code> </code>str<code> </code><br><code> </code><code> </code><code> </code><b>in</b><code> </code><b>match</b><code> </code>lexer<code> </code>cl<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>Lint<code> </code>n<code> </code>-&gt;<code> </code>Line<code> </code>{<code> </code>num<code>=</code>n<code> </code>;<code> </code>cmd<code>=</code>parse_cmd<code> </code>cl<code> </code>}<br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Lident<code> </code><code>"LIST"</code><code> </code>-&gt;<code> </code>List<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Lident<code> </code><code>"RUN"</code><code> </code>-&gt;<code> </code>Run<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Lident<code> </code><code>"END"</code><code> </code>-&gt;<code> </code>PEnd<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>raise<code> </code>ParseError<code> </code><code> </code>;;<br><code>val parse : string -&gt; phrase = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
<a name="toc83"></a>
<h3> Evaluation</h3>
A Basic program is a list of lines. Execution starts at the first
line. Interpreting a program line consists of executing the task
corresponding to its command. There are three different kinds of
commands: input-output (<b>PRINT</b> and <b>INPUT</b>), variable
declaration or modification (<b>LET</b>), and flow control
(<b>GOTO</b> and <b>IF...THEN</b>). Input-output commands interact 
with the user and use the corresponding Objective CAML functions.<br>
<br>
Variable declaration and modification commands need to know how to
compute the value of an arithmetic expression and the memory
location to store the result. Expression evaluation returns an
integer, a boolean, or a string. Their type is <tt>value</tt>.


<pre><br># <b>type</b><code> </code>value<code> </code><code>=</code><code> </code>Vint<code> </code><b>of</b><code> </code>int<code> </code><code>|</code><code> </code>Vstr<code> </code><b>of</b><code> </code>string<code> </code><code>|</code><code> </code>Vbool<code> </code><b>of</b><code> </code>bool<code> </code><code> </code>;;<br>

</pre>
<br>
<br>
Variable declaration should allocate some memory to store the
associated value. Similarly, variable modification requires the
modification of the associated value. Thus, evaluation of a Basic
program uses an <em>environment</em> that stores the association
between a variable name and its value. It is represented by an
association list of tuples (name,value):


<pre><code> </code><br># <b>type</b><code> </code>environment<code> </code><code>=</code><code> </code><tt>(</tt>string<code> </code><code>*</code><code> </code>value<tt>)</tt><code> </code>list<code> </code>;;<br>

</pre>

The variable name is used to access its value. Variable modification
modifies the association.<br>
<br>
Flow control commands, conditional or unconditional, specify the
number of the next line to execute. By default, it is the next
line. To do this, it is necessary to remember
the number of the current line.<br>
<br>
The list of commands representing the program being edited under
the toplevel is not an efficient data structure for running the
program. Indeed, it is then necessary to look at the whole list of
lines to find the line indicated by a flow control command
(<code>If</code> and <code>goto</code>). Replacing the list of lines with an array
of commands allows direct access to the command following a
flow control command, using the array index instead of the line
number in the flow control command. This solution requires some
preprocessing called assembly before executing a <tt>RUN</tt>
command. For reasons that will be detailed shortly, a program
after assembly is not represented as an array of commands but as an
array of lines:


<pre><br># <b>type</b><code> </code>code<code> </code><code>=</code><code> </code>line<code> </code>array<code> </code>;;<br>

</pre>
<br>
<br>
As in the calculator example of previous chapters, the interpreter
uses a state that is modified for each command evaluation. At each
step, we need to remember the whole program, the next line to
interpret and the values of the variables. The program being
interpreted is not exactly the one that was entered in the toplevel:
instead of a list of commands, it is an array of commands. Thus
the state of a program during execution is:


<pre><br># <b>type</b><code> </code>state_exec<code> </code><code>=</code><code> </code>{<code> </code>line<code>:</code>int<code> </code>;<code> </code>xprog<code>:</code>code<code> </code>;<code> </code>xenv<code>:</code>environment<code> </code>}<code> </code>;;<br>

</pre>
<br>
<br>
Two different reasons may lead to an error during the evaluation of a
line: an error while computing an expression, or branching to an
absent line. They must be dealt with so that the interpreter exits
nicely, printing an error message. We define an exception as well as a
function to raise it, indicating the line where the error occurred.


<pre><br># <b>exception</b><code> </code>RunError<code> </code><b>of</b><code> </code>int<code> </code><br><code> </code><b>let</b><code> </code>runerr<code> </code>n<code> </code><code>=</code><code> </code>raise<code> </code><tt>(</tt>RunError<code> </code>n<tt>)</tt><code> </code>;;<br><code>exception RunError of int</code><br><code>val runerr : int -&gt; 'a = &lt;fun&gt;</code><br>

</pre>
<br>
<br>

<h5> Assembly</h5>
Assembling a program that is a list of numbered lines (type
<i>program</i>) consists of transforming this list into an array and
modifying the flow control commands. This last modification only
needs an association table between line numbers and array indexes.
This is easily provided by storing lines (with their line numbers),
instead of commands, in the array: to find the association between
a line number and the index in the array, we look the line number up
in the array and return the corresponding index. If no line is found
with this number, the index returned is <code>-</code><code>1</code>.


<pre><br># <b>exception</b><code> </code>Result_lookup_index<code> </code><b>of</b><code> </code>int<code> </code>;;<br><code>exception Result_lookup_index of int</code><br># <b>let</b><code> </code>lookup_index<code> </code>tprog<code> </code>num_line<code> </code><code>=</code><br><code> </code><code> </code><code> </code><b>try</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><b>for</b><code> </code>i<code>=</code><code>0</code><code> </code><b>to</b><code> </code><tt>(</tt>Array.length<code> </code>tprog<tt>)</tt><code>-</code><code>1</code><code> </code><b>do</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>let</b><code> </code>num_i<code> </code><code>=</code><code> </code>tprog<code>.</code><tt>(</tt>i<tt>)</tt><code>.</code>num<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code><b>if</b><code> </code>num_i<code>=</code>num_line<code> </code><b>then</b><code> </code>raise<code> </code><tt>(</tt>Result_lookup_index<code> </code>i<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>else</b><code> </code><b>if</b><code> </code>num_i<code>&gt;</code>num_line<code> </code><b>then</b><code> </code>raise<code> </code><tt>(</tt>Result_lookup_index<code> </code><tt>(</tt><code>-</code><code>1</code><tt>)</tt><tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><b>done</b><code> </code>;<br><code> </code><code> </code><code> </code><code> </code><code> </code><tt>(</tt><code>-</code><code>1</code><code> </code><tt>)</tt><br><code> </code><code> </code><code> </code><b>with</b><code> </code>Result_lookup_index<code> </code>i<code> </code>-&gt;<code> </code>i<code> </code>;;<br><code>val lookup_index : line array -&gt; int -&gt; int = &lt;fun&gt;</code><br><br># <b>let</b><code> </code>assemble<code> </code>prog<code> </code><code>=</code><br><code> </code><code> </code><code> </code><b>let</b><code> </code>tprog<code> </code><code>=</code><code> </code>Array.of_list<code> </code>prog<code> </code><b>in</b><br><code> </code><code> </code><code> </code><code> </code><code> </code><b>for</b><code> </code>i<code>=</code><code>0</code><code> </code><b>to</b><code> </code><tt>(</tt>Array.length<code> </code>tprog<tt>)</tt><code>-</code><code>1</code><code> </code><b>do</b><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>match</b><code> </code>tprog<code>.</code><tt>(</tt>i<tt>)</tt><code>.</code>cmd<code> </code><b>with</b><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>Goto<code> </code>n<code> </code>-&gt;<code> </code><b>let</b><code> </code>index<code> </code><code>=</code><code> </code>lookup_index<code> </code>tprog<code> </code>n<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code>tprog<code>.</code><tt>(</tt>i<tt>)</tt><code> </code><code>&lt;-</code><code> </code>{<code> </code>tprog<code>.</code><tt>(</tt>i<tt>)</tt><code> </code><b>with</b><code> </code>cmd<code> </code><code>=</code><code> </code>Goto<code> </code>index<code> </code>}<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>If<tt>(</tt>c<code>,</code>n<tt>)</tt><code> </code>-&gt;<code> </code><b>let</b><code> </code>index<code> </code><code>=</code><code> </code>lookup_index<code> </code>tprog<code> </code>n<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code>tprog<code>.</code><tt>(</tt>i<tt>)</tt><code> </code><code>&lt;-</code><code> </code>{<code> </code>tprog<code>.</code><tt>(</tt>i<tt>)</tt><code> </code><b>with</b><code> </code>cmd<code> </code><code>=</code><code> </code>If<code> </code><tt>(</tt>c<code>,</code>index<tt>)</tt><code> </code>}<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>()<br><code> </code><code> </code><code> </code><code> </code><code> </code><b>done</b><code> </code>;<br><code> </code><code> </code><code> </code>tprog<code> </code>;;<br><code>val assemble : line list -&gt; line array = &lt;fun&gt;</code><br>

</pre>
<br>
<br>

<h5> Expression evaluation</h5>
<a name="sec-basic-evaluation"></a>
The evaluation function does a depth-first traversal on the abstract syntax
tree, and executes the operations indicated at each node.<br>
<br>
The <tt>RunError</tt> exception is raised in case of type
inconsistency, division by zero, or an undeclared variable.


<pre><br># <b>let</b><code> </code><b>rec</b><code> </code>eval_exp<code> </code>n<code> </code>envt<code> </code>expr<code> </code><code>=</code><code> </code><b>match</b><code> </code>expr<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>ExpInt<code> </code>p<code> </code><code> </code>-&gt;<code> </code><code> </code>Vint<code> </code>p<br><code> </code><code> </code><code> </code><code>|</code><code> </code>ExpVar<code> </code>v<code> </code><code> </code>-&gt;<code> </code><tt>(</tt><code> </code><b>try</b><code> </code>List.assoc<code> </code>v<code> </code>envt<code> </code><b>with</b><code> </code>Not_found<code> </code>-&gt;<code> </code>runerr<code> </code>n<code> </code><tt>)</tt><br><code> </code><code> </code><code> </code><code>|</code><code> </code>ExpUnr<code> </code><tt>(</tt>UMINUS<code>,</code>e<tt>)</tt><code> </code>-&gt;<code> </code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><tt>(</tt><code> </code><b>match</b><code> </code>eval_exp<code> </code>n<code> </code>envt<code> </code>e<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>Vint<code> </code>p<code> </code>-&gt;<code> </code>Vint<code> </code><tt>(</tt><code>-</code>p<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>runerr<code> </code>n<code> </code><tt>)</tt><br><code> </code><code> </code><code> </code><code>|</code><code> </code>ExpUnr<code> </code><tt>(</tt>NOT<code>,</code>e<tt>)</tt><code> </code>-&gt;<code> </code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><tt>(</tt><code> </code><b>match</b><code> </code>eval_exp<code> </code>n<code> </code>envt<code> </code>e<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>Vbool<code> </code>p<code> </code>-&gt;<code> </code>Vbool<code> </code><tt>(</tt>not<code> </code>p<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>runerr<code> </code>n<code> </code><tt>)</tt><br><code> </code><code> </code><code> </code><code>|</code><code> </code>ExpStr<code> </code>s<code> </code>-&gt;<code> </code>Vstr<code> </code>s<code> </code><code> </code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>ExpBin<code> </code><tt>(</tt>e1<code>,</code>op<code>,</code>e2<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code><b>match</b><code> </code>eval_exp<code> </code>n<code> </code>envt<code> </code>e1<code> </code><code>,</code><code> </code>op<code> </code><code>,</code><code> </code>eval_exp<code> </code>n<code> </code>envt<code> </code>e2<code> </code><b>with</b><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>Vint<code> </code>v1<code> </code><code>,</code><code> </code>PLUS<code> </code><code> </code><code> </code><code>,</code><code> </code>Vint<code> </code>v2<code> </code><code> </code>-&gt;<code> </code><code> </code>Vint<code> </code><tt>(</tt>v1<code> </code><code>+</code><code> </code>v2<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vint<code> </code>v1<code> </code><code>,</code><code> </code>MINUS<code> </code><code> </code><code>,</code><code> </code>Vint<code> </code>v2<code> </code><code> </code>-&gt;<code> </code><code> </code>Vint<code> </code><tt>(</tt>v1<code> </code><code>-</code><code> </code>v2<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vint<code> </code>v1<code> </code><code>,</code><code> </code>MULT<code> </code><code> </code><code> </code><code>,</code><code> </code>Vint<code> </code>v2<code> </code><code> </code>-&gt;<code> </code><code> </code>Vint<code> </code><tt>(</tt>v1<code> </code><code>*</code><code> </code>v2<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vint<code> </code>v1<code> </code><code>,</code><code> </code><code> </code>DIV<code> </code><code> </code><code> </code><code>,</code><code> </code>Vint<code> </code>v2<code> </code><code> </code><b>when</b><code> </code>v2<code>&lt;&gt;</code><code>0</code><code> </code>-&gt;<code> </code><code> </code>Vint<code> </code><tt>(</tt>v1<code> </code><code>/</code><code> </code>v2<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vint<code> </code>v1<code> </code><code>,</code><code> </code><code> </code>MOD<code> </code><code> </code><code> </code><code>,</code><code> </code>Vint<code> </code>v2<code> </code><code> </code><b>when</b><code> </code>v2<code>&lt;&gt;</code><code>0</code><code> </code>-&gt;<code> </code><code> </code>Vint<code> </code><tt>(</tt>v1<code> </code><b>mod</b><code> </code>v2<tt>)</tt><code> </code><br><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vint<code> </code>v1<code> </code><code>,</code><code> </code>EQUAL<code> </code><code> </code><code> </code><code>,</code><code> </code>Vint<code> </code>v2<code> </code><code> </code>-&gt;<code> </code><code> </code>Vbool<code> </code><tt>(</tt>v1<code> </code><code>=</code><code> </code>v2<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vint<code> </code>v1<code> </code><code>,</code><code> </code>DIFF<code> </code><code> </code><code> </code><code> </code><code>,</code><code> </code>Vint<code> </code>v2<code> </code><code> </code>-&gt;<code> </code><code> </code>Vbool<code> </code><tt>(</tt>v1<code> </code><code>&lt;&gt;</code><code> </code>v2<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vint<code> </code>v1<code> </code><code>,</code><code> </code><code> </code>LESS<code> </code><code> </code><code> </code><code>,</code><code> </code>Vint<code> </code>v2<code> </code><code> </code>-&gt;<code> </code><code> </code>Vbool<code> </code><tt>(</tt>v1<code> </code><code>&lt;</code><code> </code>v2<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vint<code> </code>v1<code> </code><code>,</code><code> </code><code> </code>GREAT<code> </code><code> </code><code>,</code><code> </code>Vint<code> </code>v2<code> </code><code> </code>-&gt;<code> </code><code> </code>Vbool<code> </code><tt>(</tt>v1<code> </code><code>&gt;</code><code> </code>v2<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vint<code> </code>v1<code> </code><code>,</code><code> </code>LESSEQ<code> </code><code> </code><code>,</code><code> </code>Vint<code> </code>v2<code> </code><code> </code>-&gt;<code> </code><code> </code>Vbool<code> </code><tt>(</tt>v1<code> </code><code>&lt;=</code><code> </code>v2<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vint<code> </code>v1<code> </code><code>,</code><code> </code>GREATEQ<code> </code><code>,</code><code> </code>Vint<code> </code>v2<code> </code><code> </code>-&gt;<code> </code><code> </code>Vbool<code> </code><tt>(</tt>v1<code> </code><code>&gt;=</code><code> </code>v2<tt>)</tt><code> </code><br><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vbool<code> </code>v1<code> </code><code>,</code><code> </code>AND<code> </code><code>,</code><code> </code>Vbool<code> </code>v2<code> </code><code> </code>-&gt;<code> </code><code> </code>Vbool<code> </code><tt>(</tt>v1<code> </code><code>&amp;&amp;</code><code> </code>v2<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vbool<code> </code>v1<code> </code><code>,</code><code> </code>OR<code> </code><code>,</code><code> </code>Vbool<code> </code>v2<code> </code><code> </code>-&gt;<code> </code><code> </code>Vbool<code> </code><tt>(</tt>v1<code> </code><code>||</code><code> </code>v2<tt>)</tt><code> </code><br><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vstr<code> </code>v1<code> </code><code>,</code><code> </code>PLUS<code> </code><code>,</code><code> </code>Vstr<code> </code>v2<code> </code>-&gt;<code> </code>Vstr<code> </code><tt>(</tt>v1<code> </code><code>^</code><code> </code>v2<tt>)</tt><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code><code>,</code><code> </code><code>_</code><code> </code><code>,</code><code> </code><code>_</code><code> </code><code> </code>-&gt;<code> </code>runerr<code> </code>n<code> </code><code> </code>;;<br><code>val eval_exp : int -&gt; (string * value) list -&gt; expression -&gt; value = &lt;fun&gt;</code><br>

</pre>
<br>
<br>

<h5> Command evaluation</h5>
To evaluate a command, we need a few additional functions.<br>
<br>
We add an association to an environment by removing a previous
association for the same variable name if there is one:


<pre><br># <b>let</b><code> </code><b>rec</b><code> </code>add<code> </code>v<code> </code>e<code> </code>env<code> </code><code>=</code><code> </code><b>match</b><code> </code>env<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>[]<code> </code>-&gt;<code> </code><code>[</code>v<code>,</code>e<code>]</code><br><code> </code><code> </code><code> </code><code>|</code><code> </code><tt>(</tt>w<code>,</code>f<tt>)</tt>::l<code> </code>-&gt;<code> </code><b>if</b><code> </code>w<code>=</code>v<code> </code><b>then</b><code> </code><tt>(</tt>v<code>,</code>e<tt>)</tt>::l<code> </code><b>else</b><code> </code><tt>(</tt>w<code>,</code>f<tt>)</tt>::<tt>(</tt>add<code> </code>v<code> </code>e<code> </code>l<tt>)</tt><code> </code>;;<br><code>val add : 'a -&gt; 'b -&gt; ('a * 'b) list -&gt; ('a * 'b) list = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
A function that prints the value of an integer or string is useful
for evaluation of the <code>PRINT</code> command.


<pre><br># <b>let</b><code> </code>print_value<code> </code>v<code> </code><code>=</code><code> </code><b>match</b><code> </code>v<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>Vint<code> </code>n<code> </code>-&gt;<code> </code>print_int<code> </code>n<br><code> </code><code> </code><code> </code><code>|</code><code> </code>Vbool<code> </code><b>true</b><code> </code>-&gt;<code> </code>print_string<code> </code><code>"true"</code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>Vbool<code> </code><b>false</b><code> </code>-&gt;<code> </code>print_string<code> </code><code>"false"</code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>Vstr<code> </code>s<code> </code>-&gt;<code> </code>print_string<code> </code>s<code> </code>;;<br><code>val print_value : value -&gt; unit = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
The execution of a command corresponds to a transition from one
state to another. More precisely, the environment is modified if the
command is an assignment. Furthermore, the next line to execute is always
modified. As a convention, if the next line to execute does not exist, 
we set its value to <code>-</code><code>1</code>


<pre><br># <b>let</b><code> </code>next_line<code> </code>state<code> </code><code>=</code><br><code> </code><code> </code><b>let</b><code> </code>n<code> </code><code>=</code><code> </code>state<code>.</code>line<code>+</code><code>1</code><code> </code><b>in</b><br><code> </code><code> </code><code> </code><b>if</b><code> </code>n<code> </code><code>&lt;</code><code> </code>Array.length<code> </code>state<code>.</code>xprog<code> </code><b>then</b><code> </code>n<code> </code><b>else</b><code> </code><code>-</code><code>1</code><code> </code>;;<br><code>val next_line : state_exec -&gt; int = &lt;fun&gt;</code><br># <b>let</b><code> </code>eval_cmd<code> </code>state<code> </code><code>=</code><br><code> </code><code> </code><code> </code><b>match</b><code> </code>state<code>.</code>xprog<code>.</code><tt>(</tt>state<code>.</code>line<tt>)</tt><code>.</code>cmd<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>Rem<code> </code><code>_</code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code><code> </code>{<code> </code>state<code> </code><b>with</b><code> </code>line<code> </code><code>=</code><code> </code>next_line<code> </code>state<code> </code>}<br><code> </code><code> </code><code> </code><code>|</code><code> </code>Print<code> </code>e<code> </code><code> </code>-&gt;<code> </code><code> </code>print_value<code> </code><tt>(</tt>eval_exp<code> </code>state<code>.</code>line<code> </code>state<code>.</code>xenv<code> </code>e<tt>)</tt><code> </code>;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>print_newline<code> </code>()<code> </code>;<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>{<code> </code>state<code> </code><b>with</b><code> </code>line<code> </code><code>=</code><code> </code>next_line<code> </code>state<code> </code>}<br><code> </code><code> </code><code> </code><code>|</code><code> </code>Let<tt>(</tt>v<code>,</code>e<tt>)</tt><code> </code>-&gt;<code> </code><code> </code><b>let</b><code> </code>ev<code> </code><code>=</code><code> </code>eval_exp<code> </code>state<code>.</code>line<code> </code>state<code>.</code>xenv<code> </code>e<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code>{<code> </code>state<code> </code><b>with</b><code> </code>line<code> </code><code>=</code><code> </code>next_line<code> </code>state<code> </code>;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>xenv<code> </code><code>=</code><code> </code>add<code> </code>v<code> </code>ev<code> </code>state<code>.</code>xenv<code> </code>}<br><code> </code><code> </code><code> </code><code>|</code><code> </code>Goto<code> </code>n<code> </code><code> </code><code> </code>-&gt;<code> </code><code> </code>{<code> </code>state<code> </code><b>with</b><code> </code>line<code> </code><code>=</code><code> </code>n<code> </code>}<br><code> </code><code> </code><code> </code><code>|</code><code> </code>Input<code> </code>v<code> </code><code> </code>-&gt;<code> </code><code> </code><b>let</b><code> </code>x<code> </code><code>=</code><code> </code><b>try</b><code> </code>read_int<code> </code>()<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>with</b><code> </code>Failure<code> </code><code>"int_of_string"</code><code> </code>-&gt;<code> </code><code>0</code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>in</b><code> </code>{<code> </code>state<code> </code><b>with</b><code> </code>line<code> </code><code>=</code><code> </code>next_line<code> </code>state;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>xenv<code> </code><code>=</code><code> </code>add<code> </code>v<code> </code><tt>(</tt>Vint<code> </code>x<tt>)</tt><code> </code>state<code>.</code>xenv<code> </code>}<br><code> </code><code> </code><code> </code><code>|</code><code> </code>If<code> </code><tt>(</tt>t<code>,</code>n<tt>)</tt><code> </code>-&gt;<code> </code><code> </code><b>match</b><code> </code>eval_exp<code> </code>state<code>.</code>line<code> </code>state<code>.</code>xenv<code> </code>t<code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>Vbool<code> </code><b>true</b><code> </code><code> </code>-&gt;<code> </code>{<code> </code>state<code> </code><b>with</b><code> </code>line<code> </code><code>=</code><code> </code>n<code> </code>}<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Vbool<code> </code><b>false</b><code> </code>-&gt;<code> </code>{<code> </code>state<code> </code><b>with</b><code> </code>line<code> </code><code>=</code><code> </code>next_line<code> </code>state<code> </code>}<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code><code>_</code><code> </code>-&gt;<code> </code>runerr<code> </code>state<code>.</code>line<code> </code><code> </code>;;<br><code>val eval_cmd : state_exec -&gt; state_exec = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
On each call of the transition function <tt>eval_cmd</tt>, we
look up the current line, run it, then set the number of the next
line to run as the current line. If the last line of the program is
reached, the current line is given the value <em>-1</em>. This
will tell us when to stop.<br>
<br>

<h5> Program evaluation</h5>
We recursively apply the transition function until we reach a state
where the current line number is <code>-</code><code>1</code>.


<pre><br># <b>let</b><code> </code><b>rec</b><code> </code>run<code> </code>state<code> </code><code>=</code><code> </code><br><code> </code><code> </code><b>if</b><code> </code>state<code>.</code>line<code> </code><code>=</code><code> </code><code>-</code><code>1</code><code> </code><b>then</b><code> </code>state<code> </code><b>else</b><code> </code>run<code> </code><tt>(</tt>eval_cmd<code> </code>state<tt>)</tt><code> </code>;;<br><code>val run : state_exec -&gt; state_exec = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
<a name="toc84"></a>
<h3> Finishing touches</h3><a name="basic-meo"></a>
The only thing left to do is to write a small editor and to plug
together all the functions we wrote in the previous sections.<br>
<br>
The <tt>insert</tt> function adds a new line in the program at the
requested place.


<pre><br># <b>let</b><code> </code><b>rec</b><code> </code>insert<code> </code>line<code> </code>p<code> </code><code>=</code><code> </code><b>match</b><code> </code>p<code> </code><b>with</b><code> </code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>[]<code> </code>-&gt;<code> </code><code>[</code>line<code>]</code><br><code> </code><code> </code><code> </code><code>|</code><code> </code>l::prog<code> </code>-&gt;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>if</b><code> </code>l<code>.</code>num<code> </code><code>&lt;</code><code> </code>line<code>.</code>num<code> </code><b>then</b><code> </code>l::<tt>(</tt>insert<code> </code>line<code> </code>prog<tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>else</b><code> </code><b>if</b><code> </code>l<code>.</code>num<code>=</code>line<code>.</code>num<code> </code><b>then</b><code> </code>line::prog<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>else</b><code> </code>line::l::prog<code> </code>;;<br><code>val insert : line -&gt; line list -&gt; line list = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
The <tt>print_prog</tt> function prints the source code of a
program.


<pre><br># <b>let</b><code> </code>print_prog<code> </code>prog<code> </code><code>=</code><code> </code><br><code> </code><code> </code><code> </code><b>let</b><code> </code>print_line<code> </code>x<code> </code><code>=</code><code> </code>print_string<code> </code><tt>(</tt>pp_line<code> </code>x<tt>)</tt><code> </code>;<code> </code>print_newline<code> </code>()<code> </code><b>in</b><br><code> </code><code> </code><code> </code><code> </code>print_newline<code> </code>()<code> </code>;<br><code> </code><code> </code><code> </code><code> </code>List.iter<code> </code>print_line<code> </code>prog<code> </code>;<br><code> </code><code> </code><code> </code><code> </code>print_newline<code> </code>()<code> </code>;;<br><code>val print_prog : line list -&gt; unit = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
The <tt>one_command</tt> function processes the insertion of a line
or the execution of a command. It modifies the state of the toplevel
loop, which consists of a program and an environment. This
state, represented by the <i>loop_state</i> type, is different from
the evaluation state.


<pre><br># <b>type</b><code> </code>loop_state<code> </code><code>=</code><code> </code>{<code> </code>prog<code>:</code>program;<code> </code>env<code>:</code>environment<code> </code>}<code> </code>;;<br># <b>exception</b><code> </code>End<code> </code>;;<br>

</pre>

<a name="fun-une-commande"></a>


<pre><br># <b>let</b><code> </code>one_command<code> </code>state<code> </code><code>=</code><br><code> </code><code> </code><code> </code>print_string<code> </code><code>"&gt; "</code><code> </code>;<code> </code>flush<code> </code>stdout<code> </code>;<br><code> </code><code> </code><code> </code><b>try</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><b>match</b><code> </code>parse<code> </code><tt>(</tt>input_line<code> </code>stdin<tt>)</tt><code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>Line<code> </code>l<code> </code>-&gt;<code> </code>{<code> </code>state<code> </code><b>with</b><code> </code>prog<code> </code><code>=</code><code> </code>insert<code> </code>l<code> </code>state<code>.</code>prog<code> </code>}<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>List<code> </code><code> </code>-&gt;<code> </code><tt>(</tt>print_prog<code> </code>state<code>.</code>prog<code> </code>;<code> </code>state<code> </code><tt>)</tt><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>Run<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>-&gt;<code> </code><b>let</b><code> </code>tprog<code> </code><code>=</code><code> </code>assemble<code> </code>state<code>.</code>prog<code> </code><b>in</b><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><b>let</b><code> </code>xstate<code> </code><code>=</code><code> </code>run<code> </code>{<code> </code>line<code> </code><code>=</code><code> </code><code>0</code>;<code> </code>xprog<code> </code><code>=</code><code> </code>tprog;<code> </code>xenv<code> </code><code>=</code><code> </code>state<code>.</code>env<code> </code>}<code> </code><b>in</b><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>{state<code> </code><b>with</b><code> </code>env<code> </code><code>=</code><code> </code>xstate<code>.</code>xenv<code> </code>}<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>PEnd<code> </code>-&gt;<code> </code>raise<code> </code>End<br><code> </code><code> </code><code> </code><b>with</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>LexerError<code> </code>-&gt;<code> </code>print_string<code> </code><code>"Illegal character\n"</code>;<code> </code>state<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>ParseError<code> </code>-&gt;<code> </code>print_string<code> </code><code>"syntax error\n"</code>;<code> </code>state<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code>|</code><code> </code>RunError<code> </code>n<code> </code>-&gt;<code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>print_string<code> </code><code>"runtime error at line "</code>;<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>print_int<code> </code>n<code> </code>;<br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>print_string<code> </code><code>"\n"</code>;<code> </code><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code><code> </code>state<code> </code>;;<br><code>val one_command : loop_state -&gt; loop_state = &lt;fun&gt;</code><br>

</pre>
<br>
<br>
The main function is the <tt>go</tt> function, which starts the
toplevel loop of our Basic.


<pre><br># <b>let</b><code> </code>go<code> </code>()<code> </code><code>=</code><code> </code><br><code> </code><b>try</b><code> </code><br><code> </code><code> </code><code> </code>print_string<code> </code><code>"Mini-BASIC version 0.1\n\n"</code>;<br><code> </code><code> </code><code> </code><b>let</b><code> </code><b>rec</b><code> </code>loop<code> </code>state<code> </code><code>=</code><code> </code>loop<code> </code><tt>(</tt>one_command<code> </code>state<tt>)</tt><code> </code><code> </code><b>in</b><code> </code><br><code> </code><code> </code><code> </code><code> </code><code> </code>loop<code> </code>{<code> </code>prog<code> </code><code>=</code><code> </code>[];<code> </code>env<code> </code><code>=</code><code> </code>[]<code> </code>}<br><code> </code><b>with</b><code> </code>End<code> </code>-&gt;<code> </code>print_string<code> </code><code>"See you later...\n"</code>;;<br><code>val go : unit -&gt; unit = &lt;fun&gt;</code><br>

</pre>

The loop is implemented by the local function <tt>loop</tt>. It
stops when the <tt>End</tt> exception is raised by the
<tt>one_command</tt> function.<br>
<br>

<h4> Example: C+/C-</h4>
We return to the example of the C+/C- game described in chapter&nbsp;<a href="http://caml.inria.fr/pub/docs/oreilly-book/html/index.html#chap-PI">3</a>,
page&nbsp;<a href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora027.html#cpcm">??</a>. Here is the Basic program corresponding to that
Objective CAML program:<br>
<br>
<pre>10 PRINT "Give the hidden number: "
20 INPUT N
30 PRINT "Give a number: "
40 INPUT R
50 IF R = N THEN 110
60 IF R &lt; N THEN 90
70 PRINT "C-"
80 GOTO 30
90 PRINT "C+"
100 GOTO 30
110 PRINT "CONGRATULATIONS"
</pre>And here is a sample run of this program.<br>
<br>
<pre>&gt; RUN
Give the hidden number:
64
Give a number:
88
C-
Give a number:
44
C+
Give a number:
64
CONGRATULATIONS
</pre><a name="toc85"></a>
<h3> Further work</h3>
The Basic we implemented is minimalist. If you want to go further,
the following exercises hint at some possible extensions.<br>
<br>
<ol type="1">
<li> <em>Floating-point numbers</em>: as is, our language only deals with
integers, strings and booleans. Add floats, as well as the
corresponding arithmetic operations in the language grammar. We need
to modify not only parsing, but also evaluation, taking into
account the implicit conversions between integers and floats.<br>
<br>

</li><li> <em>Arrays</em>: Add to the syntax the command <tt>DIM
 var[x]</tt> that declares an array <tt>var</tt> of size <tt>x</tt>, and the
 expression <tt>var[i]</tt> that references the <tt>i</tt>th element of the
 array <tt>var</tt>.<br>
<br>

</li><li> <em>Toplevel directives</em>: Add the toplevel directives <tt>SAVE "file_name"</tt> and <tt>LOAD "file_name"</tt> that save a Basic
 program to the hard disk, and load a Basic program from the hard
 disk, respectively.<br>
<br>

</li><li> <em>Sub-program</em>: Add sub-programs. The <tt>GOSUB line
 number</tt> command calls a sub-program by branching to the given
 line number while storing the line from where the call is made. The
 <tt>RETURN</tt> command resumes execution at the line following the
 last <tt>GOSUB</tt> call executed, if there is one, or exits the
 program otherwise. Adding sub-programs requires evaluation to
 manage not only the environement but also a stack containing the
 return addresses of the current <tt>GOSUB</tt> calls. The <tt>GOSUB</tt>
 command adds the possibility of defining recursive sub-programs.
</li></ol><hr>
<a href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora057.html"><img src="./BASIC interpreter_files/previous_motif.gif" alt="Previous"></a>
<a href="http://caml.inria.fr/pub/docs/oreilly-book/html/index.html"><img src="./BASIC interpreter_files/contents_motif.gif" alt="Contents"></a>
<a href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora059.html"><img src="./BASIC interpreter_files/next_motif.gif" alt="Next"></a>


</body></html>